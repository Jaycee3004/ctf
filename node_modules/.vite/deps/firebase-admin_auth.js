import {
  require_api_request,
  require_app,
  require_credential_internal,
  require_deep_copy,
  require_error,
  require_events,
  require_http,
  require_https,
  require_jsonwebtoken,
  require_ms,
  require_url,
  require_util,
  require_utils,
  require_validator
} from "./chunk-M63NWLCU.js";
import {
  require_crypto
} from "./chunk-K25ZT5SG.js";
import {
  __commonJS,
  __esm,
  __export,
  __toCommonJS,
  __toESM
} from "./chunk-ROME4SDB.js";

// node_modules/firebase-admin/lib/auth/user-import-builder.js
var require_user_import_builder = __commonJS({
  "node_modules/firebase-admin/lib/auth/user-import-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserImportBuilder = exports.convertMultiFactorInfoToServerFormat = void 0;
    var deep_copy_1 = require_deep_copy();
    var utils = require_utils();
    var validator = require_validator();
    var error_1 = require_error();
    function convertMultiFactorInfoToServerFormat(multiFactorInfo) {
      let enrolledAt;
      if (typeof multiFactorInfo.enrollmentTime !== "undefined") {
        if (validator.isUTCDateString(multiFactorInfo.enrollmentTime)) {
          enrolledAt = new Date(multiFactorInfo.enrollmentTime).toISOString();
        } else {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor "enrollmentTime" for "${multiFactorInfo.uid}" must be a valid UTC date string.`);
        }
      }
      if (isPhoneFactor(multiFactorInfo)) {
        const authFactorInfo = {
          mfaEnrollmentId: multiFactorInfo.uid,
          displayName: multiFactorInfo.displayName,
          // Required for all phone second factors.
          phoneInfo: multiFactorInfo.phoneNumber,
          enrolledAt
        };
        for (const objKey in authFactorInfo) {
          if (typeof authFactorInfo[objKey] === "undefined") {
            delete authFactorInfo[objKey];
          }
        }
        return authFactorInfo;
      } else {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.UNSUPPORTED_SECOND_FACTOR, `Unsupported second factor "${JSON.stringify(multiFactorInfo)}" provided.`);
      }
    }
    exports.convertMultiFactorInfoToServerFormat = convertMultiFactorInfoToServerFormat;
    function isPhoneFactor(multiFactorInfo) {
      return multiFactorInfo.factorId === "phone";
    }
    function getNumberField(obj, key) {
      if (typeof obj[key] !== "undefined" && obj[key] !== null) {
        return parseInt(obj[key].toString(), 10);
      }
      return NaN;
    }
    function populateUploadAccountUser(user, userValidator) {
      const result = {
        localId: user.uid,
        email: user.email,
        emailVerified: user.emailVerified,
        displayName: user.displayName,
        disabled: user.disabled,
        photoUrl: user.photoURL,
        phoneNumber: user.phoneNumber,
        providerUserInfo: [],
        mfaInfo: [],
        tenantId: user.tenantId,
        customAttributes: user.customClaims && JSON.stringify(user.customClaims)
      };
      if (typeof user.passwordHash !== "undefined") {
        if (!validator.isBuffer(user.passwordHash)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);
        }
        result.passwordHash = utils.toWebSafeBase64(user.passwordHash);
      }
      if (typeof user.passwordSalt !== "undefined") {
        if (!validator.isBuffer(user.passwordSalt)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);
        }
        result.salt = utils.toWebSafeBase64(user.passwordSalt);
      }
      if (validator.isNonNullObject(user.metadata)) {
        if (validator.isNonEmptyString(user.metadata.creationTime)) {
          result.createdAt = new Date(user.metadata.creationTime).getTime();
        }
        if (validator.isNonEmptyString(user.metadata.lastSignInTime)) {
          result.lastLoginAt = new Date(user.metadata.lastSignInTime).getTime();
        }
      }
      if (validator.isArray(user.providerData)) {
        user.providerData.forEach((providerData) => {
          result.providerUserInfo.push({
            providerId: providerData.providerId,
            rawId: providerData.uid,
            email: providerData.email,
            displayName: providerData.displayName,
            photoUrl: providerData.photoURL
          });
        });
      }
      if (validator.isNonNullObject(user.multiFactor) && validator.isNonEmptyArray(user.multiFactor.enrolledFactors)) {
        user.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {
          result.mfaInfo.push(convertMultiFactorInfoToServerFormat(multiFactorInfo));
        });
      }
      let key;
      for (key in result) {
        if (typeof result[key] === "undefined") {
          delete result[key];
        }
      }
      if (result.providerUserInfo.length === 0) {
        delete result.providerUserInfo;
      }
      if (result.mfaInfo.length === 0) {
        delete result.mfaInfo;
      }
      if (typeof userValidator === "function") {
        userValidator(result);
      }
      return result;
    }
    var UserImportBuilder = class {
      /**
       * @param {UserImportRecord[]} users The list of user records to import.
       * @param {UserImportOptions=} options The import options which includes hashing
       *     algorithm details.
       * @param {ValidatorFunction=} userRequestValidator The user request validator function.
       * @constructor
       */
      constructor(users, options, userRequestValidator) {
        this.requiresHashOptions = false;
        this.validatedUsers = [];
        this.userImportResultErrors = [];
        this.indexMap = {};
        this.validatedUsers = this.populateUsers(users, userRequestValidator);
        this.validatedOptions = this.populateOptions(options, this.requiresHashOptions);
      }
      /**
       * Returns the corresponding constructed uploadAccount request.
       * @returns {UploadAccountRequest} The constructed uploadAccount request.
       */
      buildRequest() {
        const users = this.validatedUsers.map((user) => {
          return (0, deep_copy_1.deepCopy)(user);
        });
        return (0, deep_copy_1.deepExtend)({ users }, (0, deep_copy_1.deepCopy)(this.validatedOptions));
      }
      /**
       * Populates the UserImportResult using the client side detected errors and the server
       * side returned errors.
       * @returns {UserImportResult} The user import result based on the returned failed
       *     uploadAccount response.
       */
      buildResponse(failedUploads) {
        const importResult = {
          successCount: this.validatedUsers.length,
          failureCount: this.userImportResultErrors.length,
          errors: (0, deep_copy_1.deepCopy)(this.userImportResultErrors)
        };
        importResult.failureCount += failedUploads.length;
        importResult.successCount -= failedUploads.length;
        failedUploads.forEach((failedUpload) => {
          importResult.errors.push({
            // Map backend request index to original developer provided array index.
            index: this.indexMap[failedUpload.index],
            error: new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_USER_IMPORT, failedUpload.message)
          });
        });
        importResult.errors.sort((a, b) => {
          return a.index - b.index;
        });
        return importResult;
      }
      /**
       * Validates and returns the hashing options of the uploadAccount request.
       * Throws an error whenever an invalid or missing options is detected.
       * @param {UserImportOptions} options The UserImportOptions.
       * @param {boolean} requiresHashOptions Whether to require hash options.
       * @returns {UploadAccountOptions} The populated UploadAccount options.
       */
      populateOptions(options, requiresHashOptions) {
        let populatedOptions;
        if (!requiresHashOptions) {
          return {};
        }
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"UserImportOptions" are required when importing users with passwords.');
        }
        if (!validator.isNonNullObject(options.hash)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_HASH_ALGORITHM, '"hash.algorithm" is missing from the provided "UserImportOptions".');
        }
        if (typeof options.hash.algorithm === "undefined" || !validator.isNonEmptyString(options.hash.algorithm)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, '"hash.algorithm" must be a string matching the list of supported algorithms.');
        }
        let rounds;
        switch (options.hash.algorithm) {
          case "HMAC_SHA512":
          case "HMAC_SHA256":
          case "HMAC_SHA1":
          case "HMAC_MD5":
            if (!validator.isBuffer(options.hash.key)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, `A non-empty "hash.key" byte buffer must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm,
              signerKey: utils.toWebSafeBase64(options.hash.key)
            };
            break;
          case "MD5":
          case "SHA1":
          case "SHA256":
          case "SHA512": {
            rounds = getNumberField(options.hash, "rounds");
            const minRounds = options.hash.algorithm === "MD5" ? 0 : 1;
            if (isNaN(rounds) || rounds < minRounds || rounds > 8192) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid "hash.rounds" number between ${minRounds} and 8192 must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm,
              rounds
            };
            break;
          }
          case "PBKDF_SHA1":
          case "PBKDF2_SHA256":
            rounds = getNumberField(options.hash, "rounds");
            if (isNaN(rounds) || rounds < 0 || rounds > 12e4) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid "hash.rounds" number between 0 and 120000 must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm,
              rounds
            };
            break;
          case "SCRYPT": {
            if (!validator.isBuffer(options.hash.key)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_KEY, `A "hash.key" byte buffer must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            rounds = getNumberField(options.hash, "rounds");
            if (isNaN(rounds) || rounds <= 0 || rounds > 8) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ROUNDS, `A valid "hash.rounds" number between 1 and 8 must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            const memoryCost = getNumberField(options.hash, "memoryCost");
            if (isNaN(memoryCost) || memoryCost <= 0 || memoryCost > 14) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, `A valid "hash.memoryCost" number between 1 and 14 must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            if (typeof options.hash.saltSeparator !== "undefined" && !validator.isBuffer(options.hash.saltSeparator)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_SALT_SEPARATOR, '"hash.saltSeparator" must be a byte buffer.');
            }
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm,
              signerKey: utils.toWebSafeBase64(options.hash.key),
              rounds,
              memoryCost,
              saltSeparator: utils.toWebSafeBase64(options.hash.saltSeparator || Buffer.from(""))
            };
            break;
          }
          case "BCRYPT":
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm
            };
            break;
          case "STANDARD_SCRYPT": {
            const cpuMemCost = getNumberField(options.hash, "memoryCost");
            if (isNaN(cpuMemCost)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_MEMORY_COST, `A valid "hash.memoryCost" number must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            const parallelization = getNumberField(options.hash, "parallelization");
            if (isNaN(parallelization)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_PARALLELIZATION, `A valid "hash.parallelization" number must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            const blockSize = getNumberField(options.hash, "blockSize");
            if (isNaN(blockSize)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_BLOCK_SIZE, `A valid "hash.blockSize" number must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            const dkLen = getNumberField(options.hash, "derivedKeyLength");
            if (isNaN(dkLen)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_DERIVED_KEY_LENGTH, `A valid "hash.derivedKeyLength" number must be provided for hash algorithm ${options.hash.algorithm}.`);
            }
            populatedOptions = {
              hashAlgorithm: options.hash.algorithm,
              cpuMemCost,
              parallelization,
              blockSize,
              dkLen
            };
            break;
          }
          default:
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_HASH_ALGORITHM, `Unsupported hash algorithm provider "${options.hash.algorithm}".`);
        }
        return populatedOptions;
      }
      /**
       * Validates and returns the users list of the uploadAccount request.
       * Whenever a user with an error is detected, the error is cached and will later be
       * merged into the user import result. This allows the processing of valid users without
       * failing early on the first error detected.
       * @param {UserImportRecord[]} users The UserImportRecords to convert to UnploadAccountUser
       *     objects.
       * @param {ValidatorFunction=} userValidator The user validator function.
       * @returns {UploadAccountUser[]} The populated uploadAccount users.
       */
      populateUsers(users, userValidator) {
        const populatedUsers = [];
        users.forEach((user, index) => {
          try {
            const result = populateUploadAccountUser(user, userValidator);
            if (typeof result.passwordHash !== "undefined") {
              this.requiresHashOptions = true;
            }
            populatedUsers.push(result);
            this.indexMap[populatedUsers.length - 1] = index;
          } catch (error) {
            this.userImportResultErrors.push({
              index,
              error
            });
          }
        });
        return populatedUsers;
      }
    };
    exports.UserImportBuilder = UserImportBuilder;
  }
});

// node_modules/firebase-admin/lib/auth/action-code-settings-builder.js
var require_action_code_settings_builder = __commonJS({
  "node_modules/firebase-admin/lib/auth/action-code-settings-builder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ActionCodeSettingsBuilder = void 0;
    var validator = require_validator();
    var error_1 = require_error();
    var ActionCodeSettingsBuilder = class {
      /**
       * ActionCodeSettingsBuilder constructor.
       *
       * @param {ActionCodeSettings} actionCodeSettings The ActionCodeSettings
       *     object used to initiliaze this server request builder.
       * @constructor
       */
      constructor(actionCodeSettings) {
        if (!validator.isNonNullObject(actionCodeSettings)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings" must be a non-null object.');
        }
        if (typeof actionCodeSettings.url === "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_CONTINUE_URI);
        } else if (!validator.isURL(actionCodeSettings.url)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONTINUE_URI);
        }
        this.continueUrl = actionCodeSettings.url;
        if (typeof actionCodeSettings.handleCodeInApp !== "undefined" && !validator.isBoolean(actionCodeSettings.handleCodeInApp)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.handleCodeInApp" must be a boolean.');
        }
        this.canHandleCodeInApp = actionCodeSettings.handleCodeInApp || false;
        if (typeof actionCodeSettings.dynamicLinkDomain !== "undefined" && !validator.isNonEmptyString(actionCodeSettings.dynamicLinkDomain)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DYNAMIC_LINK_DOMAIN);
        }
        this.dynamicLinkDomain = actionCodeSettings.dynamicLinkDomain;
        if (typeof actionCodeSettings.iOS !== "undefined") {
          if (!validator.isNonNullObject(actionCodeSettings.iOS)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.iOS" must be a valid non-null object.');
          } else if (typeof actionCodeSettings.iOS.bundleId === "undefined") {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_IOS_BUNDLE_ID);
          } else if (!validator.isNonEmptyString(actionCodeSettings.iOS.bundleId)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.iOS.bundleId" must be a valid non-empty string.');
          }
          this.ibi = actionCodeSettings.iOS.bundleId;
        }
        if (typeof actionCodeSettings.android !== "undefined") {
          if (!validator.isNonNullObject(actionCodeSettings.android)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android" must be a valid non-null object.');
          } else if (typeof actionCodeSettings.android.packageName === "undefined") {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_ANDROID_PACKAGE_NAME);
          } else if (!validator.isNonEmptyString(actionCodeSettings.android.packageName)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.packageName" must be a valid non-empty string.');
          } else if (typeof actionCodeSettings.android.minimumVersion !== "undefined" && !validator.isNonEmptyString(actionCodeSettings.android.minimumVersion)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.minimumVersion" must be a valid non-empty string.');
          } else if (typeof actionCodeSettings.android.installApp !== "undefined" && !validator.isBoolean(actionCodeSettings.android.installApp)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"ActionCodeSettings.android.installApp" must be a valid boolean.');
          }
          this.apn = actionCodeSettings.android.packageName;
          this.amv = actionCodeSettings.android.minimumVersion;
          this.installApp = actionCodeSettings.android.installApp || false;
        }
      }
      /**
       * Returns the corresponding constructed server request corresponding to the
       * current ActionCodeSettings.
       *
       * @returns The constructed EmailActionCodeRequest request.
       */
      buildRequest() {
        const request = {
          continueUrl: this.continueUrl,
          canHandleCodeInApp: this.canHandleCodeInApp,
          dynamicLinkDomain: this.dynamicLinkDomain,
          androidPackageName: this.apn,
          androidMinimumVersion: this.amv,
          androidInstallApp: this.installApp,
          iOSBundleId: this.ibi
        };
        for (const key in request) {
          if (Object.prototype.hasOwnProperty.call(request, key)) {
            if (typeof request[key] === "undefined" || request[key] === null) {
              delete request[key];
            }
          }
        }
        return request;
      }
    };
    exports.ActionCodeSettingsBuilder = ActionCodeSettingsBuilder;
  }
});

// node_modules/firebase-admin/lib/auth/auth-config.js
var require_auth_config = __commonJS({
  "node_modules/firebase-admin/lib/auth/auth-config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EmailPrivacyAuthConfig = exports.PasswordPolicyAuthConfig = exports.RecaptchaAuthConfig = exports.SmsRegionsAuthConfig = exports.OIDCConfig = exports.SAMLConfig = exports.EmailSignInConfig = exports.validateTestPhoneNumbers = exports.MultiFactorAuthConfig = exports.MAXIMUM_TEST_PHONE_NUMBERS = void 0;
    var validator = require_validator();
    var deep_copy_1 = require_deep_copy();
    var error_1 = require_error();
    exports.MAXIMUM_TEST_PHONE_NUMBERS = 10;
    var AUTH_FACTOR_CLIENT_TO_SERVER_TYPE = {
      phone: "PHONE_SMS"
    };
    var AUTH_FACTOR_SERVER_TO_CLIENT_TYPE = Object.keys(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE).reduce((res, key) => {
      res[AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[key]] = key;
      return res;
    }, {});
    var MultiFactorAuthConfig = class _MultiFactorAuthConfig {
      /**
       * Static method to convert a client side request to a MultiFactorAuthServerConfig.
       * Throws an error if validation fails.
       *
       * @param options - The options object to convert to a server request.
       * @returns The resulting server request.
       * @internal
       */
      static buildServerRequest(options) {
        const request = {};
        _MultiFactorAuthConfig.validate(options);
        if (Object.prototype.hasOwnProperty.call(options, "state")) {
          request.state = options.state;
        }
        if (Object.prototype.hasOwnProperty.call(options, "factorIds")) {
          (options.factorIds || []).forEach((factorId) => {
            if (typeof request.enabledProviders === "undefined") {
              request.enabledProviders = [];
            }
            request.enabledProviders.push(AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId]);
          });
          if (options.factorIds && options.factorIds.length === 0) {
            request.enabledProviders = [];
          }
        }
        if (Object.prototype.hasOwnProperty.call(options, "providerConfigs")) {
          request.providerConfigs = options.providerConfigs;
        }
        return request;
      }
      /**
       * Validates the MultiFactorConfig options object. Throws an error on failure.
       *
       * @param options - The options object to validate.
       */
      static validate(options) {
        const validKeys = {
          state: true,
          factorIds: true,
          providerConfigs: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig" must be a non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid MultiFactorConfig parameter.`);
          }
        }
        if (typeof options.state !== "undefined" && options.state !== "ENABLED" && options.state !== "DISABLED") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.state" must be either "ENABLED" or "DISABLED".');
        }
        if (typeof options.factorIds !== "undefined") {
          if (!validator.isArray(options.factorIds)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.factorIds" must be an array of valid "AuthFactorTypes".');
          }
          options.factorIds.forEach((factorId) => {
            if (typeof AUTH_FACTOR_CLIENT_TO_SERVER_TYPE[factorId] === "undefined") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${factorId}" is not a valid "AuthFactorType".`);
            }
          });
        }
        if (typeof options.providerConfigs !== "undefined") {
          if (!validator.isArray(options.providerConfigs)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs" must be an array of valid "MultiFactorProviderConfig."');
          }
          options.providerConfigs.forEach((multiFactorProviderConfig) => {
            if (typeof multiFactorProviderConfig === "undefined" || !validator.isObject(multiFactorProviderConfig)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${multiFactorProviderConfig}" is not a valid "MultiFactorProviderConfig" type.`);
            }
            const validProviderConfigKeys = {
              state: true,
              totpProviderConfig: true
            };
            for (const key in multiFactorProviderConfig) {
              if (!(key in validProviderConfigKeys)) {
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid ProviderConfig parameter.`);
              }
            }
            if (typeof multiFactorProviderConfig.state === "undefined" || multiFactorProviderConfig.state !== "ENABLED" && multiFactorProviderConfig.state !== "DISABLED") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs.state" must be either "ENABLED" or "DISABLED".');
            }
            if (typeof multiFactorProviderConfig.totpProviderConfig === "undefined") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"MultiFactorConfig.providerConfigs.totpProviderConfig" must be defined.');
            }
            const validTotpProviderConfigKeys = {
              adjacentIntervals: true
            };
            for (const key in multiFactorProviderConfig.totpProviderConfig) {
              if (!(key in validTotpProviderConfigKeys)) {
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid TotpProviderConfig parameter.`);
              }
            }
            const adjIntervals = multiFactorProviderConfig.totpProviderConfig.adjacentIntervals;
            if (typeof adjIntervals !== "undefined" && (!Number.isInteger(adjIntervals) || adjIntervals < 0 || adjIntervals > 10)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"MultiFactorConfig.providerConfigs.totpProviderConfig.adjacentIntervals" must be a valid number between 0 and 10 (both inclusive).');
            }
          });
        }
      }
      /**
       * The MultiFactorAuthConfig constructor.
       *
       * @param response - The server side response used to initialize the
       *     MultiFactorAuthConfig object.
       * @constructor
       * @internal
       */
      constructor(response) {
        if (typeof response.state === "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor configuration response");
        }
        this.state = response.state;
        this.factorIds = [];
        (response.enabledProviders || []).forEach((enabledProvider) => {
          if (typeof AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider] !== "undefined") {
            this.factorIds.push(AUTH_FACTOR_SERVER_TO_CLIENT_TYPE[enabledProvider]);
          }
        });
        this.providerConfigs = [];
        (response.providerConfigs || []).forEach((providerConfig) => {
          if (typeof providerConfig !== "undefined") {
            if (typeof providerConfig.state === "undefined" || typeof providerConfig.totpProviderConfig === "undefined" || typeof providerConfig.totpProviderConfig.adjacentIntervals !== "undefined" && typeof providerConfig.totpProviderConfig.adjacentIntervals !== "number") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor configuration response");
            }
            this.providerConfigs.push(providerConfig);
          }
        });
      }
      /** Converts MultiFactorConfig to JSON object
       * @returns The plain object representation of the multi-factor config instance. */
      toJSON() {
        return {
          state: this.state,
          factorIds: this.factorIds,
          providerConfigs: this.providerConfigs
        };
      }
    };
    exports.MultiFactorAuthConfig = MultiFactorAuthConfig;
    function validateTestPhoneNumbers(testPhoneNumbers) {
      if (!validator.isObject(testPhoneNumbers)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"testPhoneNumbers" must be a map of phone number / code pairs.');
      }
      if (Object.keys(testPhoneNumbers).length > exports.MAXIMUM_TEST_PHONE_NUMBERS) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_TEST_PHONE_NUMBER_EXCEEDED);
      }
      for (const phoneNumber in testPhoneNumbers) {
        if (!validator.isPhoneNumber(phoneNumber)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `"${phoneNumber}" is not a valid E.164 standard compliant phone number.`);
        }
        if (!validator.isString(testPhoneNumbers[phoneNumber]) || !/^[\d]{6}$/.test(testPhoneNumbers[phoneNumber])) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TESTING_PHONE_NUMBER, `"${testPhoneNumbers[phoneNumber]}" is not a valid 6 digit code string.`);
        }
      }
    }
    exports.validateTestPhoneNumbers = validateTestPhoneNumbers;
    var EmailSignInConfig = class _EmailSignInConfig {
      /**
       * Static method to convert a client side request to a EmailSignInConfigServerRequest.
       * Throws an error if validation fails.
       *
       * @param options - The options object to convert to a server request.
       * @returns The resulting server request.
       * @internal
       */
      static buildServerRequest(options) {
        const request = {};
        _EmailSignInConfig.validate(options);
        if (Object.prototype.hasOwnProperty.call(options, "enabled")) {
          request.allowPasswordSignup = options.enabled;
        }
        if (Object.prototype.hasOwnProperty.call(options, "passwordRequired")) {
          request.enableEmailLinkSignin = !options.passwordRequired;
        }
        return request;
      }
      /**
       * Validates the EmailSignInConfig options object. Throws an error on failure.
       *
       * @param options - The options object to validate.
       */
      static validate(options) {
        const validKeys = {
          enabled: true,
          passwordRequired: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig" must be a non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${key}" is not a valid EmailSignInConfig parameter.`);
          }
        }
        if (typeof options.enabled !== "undefined" && !validator.isBoolean(options.enabled)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig.enabled" must be a boolean.');
        }
        if (typeof options.passwordRequired !== "undefined" && !validator.isBoolean(options.passwordRequired)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"EmailSignInConfig.passwordRequired" must be a boolean.');
        }
      }
      /**
       * The EmailSignInConfig constructor.
       *
       * @param response - The server side response used to initialize the
       *     EmailSignInConfig object.
       * @constructor
       */
      constructor(response) {
        if (typeof response.allowPasswordSignup === "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid email sign-in configuration response");
        }
        this.enabled = response.allowPasswordSignup;
        this.passwordRequired = !response.enableEmailLinkSignin;
      }
      /** @returns The plain object representation of the email sign-in config. */
      toJSON() {
        return {
          enabled: this.enabled,
          passwordRequired: this.passwordRequired
        };
      }
    };
    exports.EmailSignInConfig = EmailSignInConfig;
    var SAMLConfig = class _SAMLConfig {
      /**
       * Converts a client side request to a SAMLConfigServerRequest which is the format
       * accepted by the backend server.
       * Throws an error if validation fails. If the request is not a SAMLConfig request,
       * returns null.
       *
       * @param options - The options object to convert to a server request.
       * @param ignoreMissingFields - Whether to ignore missing fields.
       * @returns The resulting server request or null if not valid.
       */
      static buildServerRequest(options, ignoreMissingFields = false) {
        const makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);
        if (!makeRequest) {
          return null;
        }
        const request = {};
        _SAMLConfig.validate(options, ignoreMissingFields);
        request.enabled = options.enabled;
        request.displayName = options.displayName;
        if (options.idpEntityId || options.ssoURL || options.x509Certificates) {
          request.idpConfig = {
            idpEntityId: options.idpEntityId,
            ssoUrl: options.ssoURL,
            signRequest: options.enableRequestSigning,
            idpCertificates: typeof options.x509Certificates === "undefined" ? void 0 : []
          };
          if (options.x509Certificates) {
            for (const cert of options.x509Certificates || []) {
              request.idpConfig.idpCertificates.push({ x509Certificate: cert });
            }
          }
        }
        if (options.callbackURL || options.rpEntityId) {
          request.spConfig = {
            spEntityId: options.rpEntityId,
            callbackUri: options.callbackURL
          };
        }
        return request;
      }
      /**
       * Returns the provider ID corresponding to the resource name if available.
       *
       * @param resourceName - The server side resource name.
       * @returns The provider ID corresponding to the resource, null otherwise.
       */
      static getProviderIdFromResourceName(resourceName) {
        const matchProviderRes = resourceName.match(/\/inboundSamlConfigs\/(saml\..*)$/);
        if (!matchProviderRes || matchProviderRes.length < 2) {
          return null;
        }
        return matchProviderRes[1];
      }
      /**
       * @param providerId - The provider ID to check.
       * @returns Whether the provider ID corresponds to a SAML provider.
       */
      static isProviderId(providerId) {
        return validator.isNonEmptyString(providerId) && providerId.indexOf("saml.") === 0;
      }
      /**
       * Validates the SAMLConfig options object. Throws an error on failure.
       *
       * @param options - The options object to validate.
       * @param ignoreMissingFields - Whether to ignore missing fields.
       */
      static validate(options, ignoreMissingFields = false) {
        const validKeys = {
          enabled: true,
          displayName: true,
          providerId: true,
          idpEntityId: true,
          ssoURL: true,
          x509Certificates: true,
          rpEntityId: true,
          callbackURL: true,
          enableRequestSigning: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig" must be a valid non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SAML config parameter.`);
          }
        }
        if (validator.isNonEmptyString(options.providerId)) {
          if (options.providerId.indexOf("saml.") !== 0) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"SAMLAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "saml.".');
          }
        } else if (!ignoreMissingFields) {
          throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"SAMLAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "saml.".');
        }
        if (!(ignoreMissingFields && typeof options.idpEntityId === "undefined") && !validator.isNonEmptyString(options.idpEntityId)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.idpEntityId" must be a valid non-empty string.');
        }
        if (!(ignoreMissingFields && typeof options.ssoURL === "undefined") && !validator.isURL(options.ssoURL)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.ssoURL" must be a valid URL string.');
        }
        if (!(ignoreMissingFields && typeof options.rpEntityId === "undefined") && !validator.isNonEmptyString(options.rpEntityId)) {
          throw new error_1.FirebaseAuthError(!options.rpEntityId ? error_1.AuthClientErrorCode.MISSING_SAML_RELYING_PARTY_CONFIG : error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.rpEntityId" must be a valid non-empty string.');
        }
        if (!(ignoreMissingFields && typeof options.callbackURL === "undefined") && !validator.isURL(options.callbackURL)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.callbackURL" must be a valid URL string.');
        }
        if (!(ignoreMissingFields && typeof options.x509Certificates === "undefined") && !validator.isArray(options.x509Certificates)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.x509Certificates" must be a valid array of X509 certificate strings.');
        }
        (options.x509Certificates || []).forEach((cert) => {
          if (!validator.isNonEmptyString(cert)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.x509Certificates" must be a valid array of X509 certificate strings.');
          }
        });
        if (typeof options.enableRequestSigning !== "undefined" && !validator.isBoolean(options.enableRequestSigning)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.enableRequestSigning" must be a boolean.');
        }
        if (typeof options.enabled !== "undefined" && !validator.isBoolean(options.enabled)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.enabled" must be a boolean.');
        }
        if (typeof options.displayName !== "undefined" && !validator.isString(options.displayName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SAMLAuthProviderConfig.displayName" must be a valid string.');
        }
      }
      /**
       * The SAMLConfig constructor.
       *
       * @param response - The server side response used to initialize the SAMLConfig object.
       * @constructor
       */
      constructor(response) {
        if (!response || !response.idpConfig || !response.idpConfig.idpEntityId || !response.idpConfig.ssoUrl || !response.spConfig || !response.spConfig.spEntityId || !response.name || !(validator.isString(response.name) && _SAMLConfig.getProviderIdFromResourceName(response.name))) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid SAML configuration response");
        }
        const providerId = _SAMLConfig.getProviderIdFromResourceName(response.name);
        if (!providerId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid SAML configuration response");
        }
        this.providerId = providerId;
        this.rpEntityId = response.spConfig.spEntityId;
        this.callbackURL = response.spConfig.callbackUri;
        this.idpEntityId = response.idpConfig.idpEntityId;
        this.ssoURL = response.idpConfig.ssoUrl;
        this.enableRequestSigning = !!response.idpConfig.signRequest;
        const x509Certificates = [];
        for (const cert of response.idpConfig.idpCertificates || []) {
          if (cert.x509Certificate) {
            x509Certificates.push(cert.x509Certificate);
          }
        }
        this.x509Certificates = x509Certificates;
        this.enabled = !!response.enabled;
        this.displayName = response.displayName;
      }
      /** @returns The plain object representation of the SAMLConfig. */
      toJSON() {
        return {
          enabled: this.enabled,
          displayName: this.displayName,
          providerId: this.providerId,
          idpEntityId: this.idpEntityId,
          ssoURL: this.ssoURL,
          x509Certificates: (0, deep_copy_1.deepCopy)(this.x509Certificates),
          rpEntityId: this.rpEntityId,
          callbackURL: this.callbackURL,
          enableRequestSigning: this.enableRequestSigning
        };
      }
    };
    exports.SAMLConfig = SAMLConfig;
    var OIDCConfig = class _OIDCConfig {
      /**
       * Converts a client side request to a OIDCConfigServerRequest which is the format
       * accepted by the backend server.
       * Throws an error if validation fails. If the request is not a OIDCConfig request,
       * returns null.
       *
       * @param options - The options object to convert to a server request.
       * @param ignoreMissingFields - Whether to ignore missing fields.
       * @returns The resulting server request or null if not valid.
       */
      static buildServerRequest(options, ignoreMissingFields = false) {
        const makeRequest = validator.isNonNullObject(options) && (options.providerId || ignoreMissingFields);
        if (!makeRequest) {
          return null;
        }
        const request = {};
        _OIDCConfig.validate(options, ignoreMissingFields);
        request.enabled = options.enabled;
        request.displayName = options.displayName;
        request.issuer = options.issuer;
        request.clientId = options.clientId;
        if (typeof options.clientSecret !== "undefined") {
          request.clientSecret = options.clientSecret;
        }
        if (typeof options.responseType !== "undefined") {
          request.responseType = options.responseType;
        }
        return request;
      }
      /**
       * Returns the provider ID corresponding to the resource name if available.
       *
       * @param resourceName - The server side resource name
       * @returns The provider ID corresponding to the resource, null otherwise.
       */
      static getProviderIdFromResourceName(resourceName) {
        const matchProviderRes = resourceName.match(/\/oauthIdpConfigs\/(oidc\..*)$/);
        if (!matchProviderRes || matchProviderRes.length < 2) {
          return null;
        }
        return matchProviderRes[1];
      }
      /**
       * @param providerId - The provider ID to check.
       * @returns Whether the provider ID corresponds to an OIDC provider.
       */
      static isProviderId(providerId) {
        return validator.isNonEmptyString(providerId) && providerId.indexOf("oidc.") === 0;
      }
      /**
       * Validates the OIDCConfig options object. Throws an error on failure.
       *
       * @param options - The options object to validate.
       * @param ignoreMissingFields - Whether to ignore missing fields.
       */
      static validate(options, ignoreMissingFields = false) {
        const validKeys = {
          enabled: true,
          displayName: true,
          providerId: true,
          clientId: true,
          issuer: true,
          clientSecret: true,
          responseType: true
        };
        const validResponseTypes = {
          idToken: true,
          code: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig" must be a valid non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid OIDC config parameter.`);
          }
        }
        if (validator.isNonEmptyString(options.providerId)) {
          if (options.providerId.indexOf("oidc.") !== 0) {
            throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"OIDCAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "oidc.".');
          }
        } else if (!ignoreMissingFields) {
          throw new error_1.FirebaseAuthError(!options.providerId ? error_1.AuthClientErrorCode.MISSING_PROVIDER_ID : error_1.AuthClientErrorCode.INVALID_PROVIDER_ID, '"OIDCAuthProviderConfig.providerId" must be a valid non-empty string prefixed with "oidc.".');
        }
        if (!(ignoreMissingFields && typeof options.clientId === "undefined") && !validator.isNonEmptyString(options.clientId)) {
          throw new error_1.FirebaseAuthError(!options.clientId ? error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_ID : error_1.AuthClientErrorCode.INVALID_OAUTH_CLIENT_ID, '"OIDCAuthProviderConfig.clientId" must be a valid non-empty string.');
        }
        if (!(ignoreMissingFields && typeof options.issuer === "undefined") && !validator.isURL(options.issuer)) {
          throw new error_1.FirebaseAuthError(!options.issuer ? error_1.AuthClientErrorCode.MISSING_ISSUER : error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.issuer" must be a valid URL string.');
        }
        if (typeof options.enabled !== "undefined" && !validator.isBoolean(options.enabled)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.enabled" must be a boolean.');
        }
        if (typeof options.displayName !== "undefined" && !validator.isString(options.displayName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.displayName" must be a valid string.');
        }
        if (typeof options.clientSecret !== "undefined" && !validator.isNonEmptyString(options.clientSecret)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"OIDCAuthProviderConfig.clientSecret" must be a valid string.');
        }
        if (validator.isNonNullObject(options.responseType) && typeof options.responseType !== "undefined") {
          Object.keys(options.responseType).forEach((key) => {
            if (!(key in validResponseTypes)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid OAuthResponseType parameter.`);
            }
          });
          const idToken = options.responseType.idToken;
          if (typeof idToken !== "undefined" && !validator.isBoolean(idToken)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"OIDCAuthProviderConfig.responseType.idToken" must be a boolean.');
          }
          const code = options.responseType.code;
          if (typeof code !== "undefined") {
            if (!validator.isBoolean(code)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"OIDCAuthProviderConfig.responseType.code" must be a boolean.');
            }
            if (code && typeof options.clientSecret === "undefined") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISSING_OAUTH_CLIENT_SECRET, "The OAuth configuration client secret is required to enable OIDC code flow.");
            }
          }
          const allKeys = Object.keys(options.responseType).length;
          const enabledCount = Object.values(options.responseType).filter(Boolean).length;
          if (allKeys > 1 && enabledCount !== 1) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_OAUTH_RESPONSETYPE, "Only exactly one OAuth responseType should be set to true.");
          }
        }
      }
      /**
       * The OIDCConfig constructor.
       *
       * @param response - The server side response used to initialize the OIDCConfig object.
       * @constructor
       */
      constructor(response) {
        if (!response || !response.issuer || !response.clientId || !response.name || !(validator.isString(response.name) && _OIDCConfig.getProviderIdFromResourceName(response.name))) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid OIDC configuration response");
        }
        const providerId = _OIDCConfig.getProviderIdFromResourceName(response.name);
        if (!providerId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid SAML configuration response");
        }
        this.providerId = providerId;
        this.clientId = response.clientId;
        this.issuer = response.issuer;
        this.enabled = !!response.enabled;
        this.displayName = response.displayName;
        if (typeof response.clientSecret !== "undefined") {
          this.clientSecret = response.clientSecret;
        }
        if (typeof response.responseType !== "undefined") {
          this.responseType = response.responseType;
        }
      }
      /** @returns The plain object representation of the OIDCConfig. */
      toJSON() {
        return {
          enabled: this.enabled,
          displayName: this.displayName,
          providerId: this.providerId,
          issuer: this.issuer,
          clientId: this.clientId,
          clientSecret: (0, deep_copy_1.deepCopy)(this.clientSecret),
          responseType: (0, deep_copy_1.deepCopy)(this.responseType)
        };
      }
    };
    exports.OIDCConfig = OIDCConfig;
    var SmsRegionsAuthConfig = class {
      static validate(options) {
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig" must be a non-null object.');
        }
        const validKeys = {
          allowlistOnly: true,
          allowByDefault: true
        };
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SmsRegionConfig parameter.`);
          }
        }
        if (typeof options.allowByDefault !== "undefined" && typeof options.allowlistOnly !== "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'SmsRegionConfig cannot have both "allowByDefault" and "allowlistOnly" parameters.');
        }
        if (typeof options.allowByDefault !== "undefined") {
          const allowByDefaultValidKeys = {
            disallowedRegions: true
          };
          for (const key in options.allowByDefault) {
            if (!(key in allowByDefaultValidKeys)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SmsRegionConfig.allowByDefault parameter.`);
            }
          }
          if (typeof options.allowByDefault.disallowedRegions !== "undefined" && !validator.isArray(options.allowByDefault.disallowedRegions)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig.allowByDefault.disallowedRegions" must be a valid string array.');
          }
        }
        if (typeof options.allowlistOnly !== "undefined") {
          const allowListOnlyValidKeys = {
            allowedRegions: true
          };
          for (const key in options.allowlistOnly) {
            if (!(key in allowListOnlyValidKeys)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid SmsRegionConfig.allowlistOnly parameter.`);
            }
          }
          if (typeof options.allowlistOnly.allowedRegions !== "undefined" && !validator.isArray(options.allowlistOnly.allowedRegions)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"SmsRegionConfig.allowlistOnly.allowedRegions" must be a valid string array.');
          }
        }
      }
    };
    exports.SmsRegionsAuthConfig = SmsRegionsAuthConfig;
    var RecaptchaAuthConfig = class _RecaptchaAuthConfig {
      constructor(recaptchaConfig) {
        this.emailPasswordEnforcementState = recaptchaConfig.emailPasswordEnforcementState;
        this.managedRules = recaptchaConfig.managedRules;
        this.recaptchaKeys = recaptchaConfig.recaptchaKeys;
        this.useAccountDefender = recaptchaConfig.useAccountDefender;
      }
      /**
       * Validates the RecaptchaConfig options object. Throws an error on failure.
       * @param options - The options object to validate.
       */
      static validate(options) {
        const validKeys = {
          emailPasswordEnforcementState: true,
          managedRules: true,
          recaptchaKeys: true,
          useAccountDefender: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig" must be a non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid RecaptchaConfig parameter.`);
          }
        }
        if (typeof options.emailPasswordEnforcementState !== void 0) {
          if (!validator.isNonEmptyString(options.emailPasswordEnforcementState)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"RecaptchaConfig.emailPasswordEnforcementState" must be a valid non-empty string.');
          }
          if (options.emailPasswordEnforcementState !== "OFF" && options.emailPasswordEnforcementState !== "AUDIT" && options.emailPasswordEnforcementState !== "ENFORCE") {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.emailPasswordEnforcementState" must be either "OFF", "AUDIT" or "ENFORCE".');
          }
        }
        if (typeof options.managedRules !== "undefined") {
          if (!validator.isArray(options.managedRules)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.managedRules" must be an array of valid "RecaptchaManagedRule".');
          }
          options.managedRules.forEach((managedRule) => {
            _RecaptchaAuthConfig.validateManagedRule(managedRule);
          });
        }
        if (typeof options.useAccountDefender !== "undefined") {
          if (!validator.isBoolean(options.useAccountDefender)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaConfig.useAccountDefender" must be a boolean value".');
          }
        }
      }
      /**
       * Validate each element in ManagedRule array
       * @param options - The options object to validate.
       */
      static validateManagedRule(options) {
        const validKeys = {
          endScore: true,
          action: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaManagedRule" must be a non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid RecaptchaManagedRule parameter.`);
          }
        }
        if (typeof options.action !== "undefined" && options.action !== "BLOCK") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"RecaptchaManagedRule.action" must be "BLOCK".');
        }
      }
      /**
       * Returns a JSON-serializable representation of this object.
       * @returns The JSON-serializable object representation of the ReCaptcha config instance
       */
      toJSON() {
        const json = {
          emailPasswordEnforcementState: this.emailPasswordEnforcementState,
          managedRules: (0, deep_copy_1.deepCopy)(this.managedRules),
          recaptchaKeys: (0, deep_copy_1.deepCopy)(this.recaptchaKeys),
          useAccountDefender: this.useAccountDefender
        };
        if (typeof json.emailPasswordEnforcementState === "undefined") {
          delete json.emailPasswordEnforcementState;
        }
        if (typeof json.managedRules === "undefined") {
          delete json.managedRules;
        }
        if (typeof json.recaptchaKeys === "undefined") {
          delete json.recaptchaKeys;
        }
        if (typeof json.useAccountDefender === "undefined") {
          delete json.useAccountDefender;
        }
        return json;
      }
    };
    exports.RecaptchaAuthConfig = RecaptchaAuthConfig;
    var PasswordPolicyAuthConfig = class _PasswordPolicyAuthConfig {
      /**
       * Static method to convert a client side request to a PasswordPolicyAuthServerConfig.
       * Throws an error if validation fails.
       *
       * @param options - The options object to convert to a server request.
       * @returns The resulting server request.
       * @internal
       */
      static buildServerRequest(options) {
        var _a, _b, _c, _d, _e, _f;
        const request = {};
        _PasswordPolicyAuthConfig.validate(options);
        if (Object.prototype.hasOwnProperty.call(options, "enforcementState")) {
          request.passwordPolicyEnforcementState = options.enforcementState;
        }
        request.forceUpgradeOnSignin = false;
        if (Object.prototype.hasOwnProperty.call(options, "forceUpgradeOnSignin")) {
          request.forceUpgradeOnSignin = options.forceUpgradeOnSignin;
        }
        const constraintsRequest = {
          containsUppercaseCharacter: false,
          containsLowercaseCharacter: false,
          containsNonAlphanumericCharacter: false,
          containsNumericCharacter: false,
          minPasswordLength: 6,
          maxPasswordLength: 4096
        };
        request.passwordPolicyVersions = [];
        if (Object.prototype.hasOwnProperty.call(options, "constraints")) {
          if (options) {
            if (((_a = options.constraints) == null ? void 0 : _a.requireUppercase) !== void 0) {
              constraintsRequest.containsUppercaseCharacter = options.constraints.requireUppercase;
            }
            if (((_b = options.constraints) == null ? void 0 : _b.requireLowercase) !== void 0) {
              constraintsRequest.containsLowercaseCharacter = options.constraints.requireLowercase;
            }
            if (((_c = options.constraints) == null ? void 0 : _c.requireNonAlphanumeric) !== void 0) {
              constraintsRequest.containsNonAlphanumericCharacter = options.constraints.requireNonAlphanumeric;
            }
            if (((_d = options.constraints) == null ? void 0 : _d.requireNumeric) !== void 0) {
              constraintsRequest.containsNumericCharacter = options.constraints.requireNumeric;
            }
            if (((_e = options.constraints) == null ? void 0 : _e.minLength) !== void 0) {
              constraintsRequest.minPasswordLength = options.constraints.minLength;
            }
            if (((_f = options.constraints) == null ? void 0 : _f.maxLength) !== void 0) {
              constraintsRequest.maxPasswordLength = options.constraints.maxLength;
            }
          }
        }
        request.passwordPolicyVersions.push({ customStrengthOptions: constraintsRequest });
        return request;
      }
      /**
       * Validates the PasswordPolicyConfig options object. Throws an error on failure.
       *
       * @param options - The options object to validate.
       * @internal
       */
      static validate(options) {
        const validKeys = {
          enforcementState: true,
          forceUpgradeOnSignin: true,
          constraints: true
        };
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig" must be a non-null object.');
        }
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid PasswordPolicyConfig parameter.`);
          }
        }
        if (typeof options.enforcementState === "undefined" || !(options.enforcementState === "ENFORCE" || options.enforcementState === "OFF")) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.enforcementState" must be either "ENFORCE" or "OFF".');
        }
        if (typeof options.forceUpgradeOnSignin !== "undefined") {
          if (!validator.isBoolean(options.forceUpgradeOnSignin)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.forceUpgradeOnSignin" must be a boolean.');
          }
        }
        if (typeof options.constraints !== "undefined") {
          if (options.enforcementState === "ENFORCE" && !validator.isNonNullObject(options.constraints)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints" must be a non-empty object.');
          }
          const validCharKeys = {
            requireUppercase: true,
            requireLowercase: true,
            requireNumeric: true,
            requireNonAlphanumeric: true,
            minLength: true,
            maxLength: true
          };
          for (const key in options.constraints) {
            if (!(key in validCharKeys)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid PasswordPolicyConfig.constraints parameter.`);
            }
          }
          if (typeof options.constraints.requireUppercase !== "undefined" && !validator.isBoolean(options.constraints.requireUppercase)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireUppercase" must be a boolean.');
          }
          if (typeof options.constraints.requireLowercase !== "undefined" && !validator.isBoolean(options.constraints.requireLowercase)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireLowercase" must be a boolean.');
          }
          if (typeof options.constraints.requireNonAlphanumeric !== "undefined" && !validator.isBoolean(options.constraints.requireNonAlphanumeric)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireNonAlphanumeric" must be a boolean.');
          }
          if (typeof options.constraints.requireNumeric !== "undefined" && !validator.isBoolean(options.constraints.requireNumeric)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.requireNumeric" must be a boolean.');
          }
          if (typeof options.constraints.minLength === "undefined") {
            options.constraints.minLength = 6;
          } else if (!validator.isNumber(options.constraints.minLength)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.minLength" must be a number.');
          } else {
            if (!(options.constraints.minLength >= 6 && options.constraints.minLength <= 30)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.minLength" must be an integer between 6 and 30, inclusive.');
            }
          }
          if (typeof options.constraints.maxLength === "undefined") {
            options.constraints.maxLength = 4096;
          } else if (!validator.isNumber(options.constraints.maxLength)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.maxLength" must be a number.');
          } else {
            if (!(options.constraints.maxLength >= options.constraints.minLength && options.constraints.maxLength <= 4096)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints.maxLength" must be greater than or equal to minLength and at max 4096.');
            }
          }
        } else {
          if (options.enforcementState === "ENFORCE") {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"PasswordPolicyConfig.constraints" must be defined.');
          }
        }
      }
      /**
       * The PasswordPolicyAuthConfig constructor.
       *
       * @param response - The server side response used to initialize the
       *     PasswordPolicyAuthConfig object.
       * @constructor
       * @internal
       */
      constructor(response) {
        if (typeof response.passwordPolicyEnforcementState === "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid password policy configuration response");
        }
        this.enforcementState = response.passwordPolicyEnforcementState;
        let constraintsResponse = {};
        if (typeof response.passwordPolicyVersions !== "undefined") {
          (response.passwordPolicyVersions || []).forEach((policyVersion) => {
            var _a, _b, _c, _d, _e, _f;
            constraintsResponse = {
              requireLowercase: (_a = policyVersion.customStrengthOptions) == null ? void 0 : _a.containsLowercaseCharacter,
              requireUppercase: (_b = policyVersion.customStrengthOptions) == null ? void 0 : _b.containsUppercaseCharacter,
              requireNonAlphanumeric: (_c = policyVersion.customStrengthOptions) == null ? void 0 : _c.containsNonAlphanumericCharacter,
              requireNumeric: (_d = policyVersion.customStrengthOptions) == null ? void 0 : _d.containsNumericCharacter,
              minLength: (_e = policyVersion.customStrengthOptions) == null ? void 0 : _e.minPasswordLength,
              maxLength: (_f = policyVersion.customStrengthOptions) == null ? void 0 : _f.maxPasswordLength
            };
          });
        }
        this.constraints = constraintsResponse;
        this.forceUpgradeOnSignin = response.forceUpgradeOnSignin ? true : false;
      }
    };
    exports.PasswordPolicyAuthConfig = PasswordPolicyAuthConfig;
    var EmailPrivacyAuthConfig = class {
      static validate(options) {
        if (!validator.isNonNullObject(options)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"EmailPrivacyConfig" must be a non-null object.');
        }
        const validKeys = {
          enableImprovedEmailPrivacy: true
        };
        for (const key in options) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, `"${key}" is not a valid "EmailPrivacyConfig" parameter.`);
          }
        }
        if (typeof options.enableImprovedEmailPrivacy !== "undefined" && !validator.isBoolean(options.enableImprovedEmailPrivacy)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, '"EmailPrivacyConfig.enableImprovedEmailPrivacy" must be a valid boolean value.');
        }
      }
    };
    exports.EmailPrivacyAuthConfig = EmailPrivacyAuthConfig;
  }
});

// node_modules/firebase-admin/lib/auth/tenant.js
var require_tenant = __commonJS({
  "node_modules/firebase-admin/lib/auth/tenant.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Tenant = void 0;
    var validator = require_validator();
    var deep_copy_1 = require_deep_copy();
    var error_1 = require_error();
    var auth_config_1 = require_auth_config();
    var Tenant2 = class _Tenant {
      /**
       * Builds the corresponding server request for a TenantOptions object.
       *
       * @param tenantOptions - The properties to convert to a server request.
       * @param createRequest - Whether this is a create request.
       * @returns The equivalent server request.
       *
       * @internal
       */
      static buildServerRequest(tenantOptions, createRequest) {
        _Tenant.validate(tenantOptions, createRequest);
        let request = {};
        if (typeof tenantOptions.emailSignInConfig !== "undefined") {
          request = auth_config_1.EmailSignInConfig.buildServerRequest(tenantOptions.emailSignInConfig);
        }
        if (typeof tenantOptions.displayName !== "undefined") {
          request.displayName = tenantOptions.displayName;
        }
        if (typeof tenantOptions.anonymousSignInEnabled !== "undefined") {
          request.enableAnonymousUser = tenantOptions.anonymousSignInEnabled;
        }
        if (typeof tenantOptions.multiFactorConfig !== "undefined") {
          request.mfaConfig = auth_config_1.MultiFactorAuthConfig.buildServerRequest(tenantOptions.multiFactorConfig);
        }
        if (typeof tenantOptions.testPhoneNumbers !== "undefined") {
          request.testPhoneNumbers = tenantOptions.testPhoneNumbers ?? {};
        }
        if (typeof tenantOptions.smsRegionConfig !== "undefined") {
          request.smsRegionConfig = tenantOptions.smsRegionConfig;
        }
        if (typeof tenantOptions.recaptchaConfig !== "undefined") {
          request.recaptchaConfig = tenantOptions.recaptchaConfig;
        }
        if (typeof tenantOptions.passwordPolicyConfig !== "undefined") {
          request.passwordPolicyConfig = auth_config_1.PasswordPolicyAuthConfig.buildServerRequest(tenantOptions.passwordPolicyConfig);
        }
        if (typeof tenantOptions.emailPrivacyConfig !== "undefined") {
          request.emailPrivacyConfig = tenantOptions.emailPrivacyConfig;
        }
        return request;
      }
      /**
       * Returns the tenant ID corresponding to the resource name if available.
       *
       * @param resourceName - The server side resource name
       * @returns The tenant ID corresponding to the resource, null otherwise.
       *
       * @internal
       */
      static getTenantIdFromResourceName(resourceName) {
        const matchTenantRes = resourceName.match(/\/tenants\/(.*)$/);
        if (!matchTenantRes || matchTenantRes.length < 2) {
          return null;
        }
        return matchTenantRes[1];
      }
      /**
       * Validates a tenant options object. Throws an error on failure.
       *
       * @param request - The tenant options object to validate.
       * @param createRequest - Whether this is a create request.
       */
      static validate(request, createRequest) {
        const validKeys = {
          displayName: true,
          emailSignInConfig: true,
          anonymousSignInEnabled: true,
          multiFactorConfig: true,
          testPhoneNumbers: true,
          smsRegionConfig: true,
          recaptchaConfig: true,
          passwordPolicyConfig: true,
          emailPrivacyConfig: true
        };
        const label = createRequest ? "CreateTenantRequest" : "UpdateTenantRequest";
        if (!validator.isNonNullObject(request)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${label}" must be a valid non-null object.`);
        }
        for (const key in request) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${key}" is not a valid ${label} parameter.`);
          }
        }
        if (typeof request.displayName !== "undefined" && !validator.isNonEmptyString(request.displayName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${label}.displayName" must be a valid non-empty string.`);
        }
        if (typeof request.emailSignInConfig !== "undefined") {
          auth_config_1.EmailSignInConfig.buildServerRequest(request.emailSignInConfig);
        }
        if (typeof request.testPhoneNumbers !== "undefined" && request.testPhoneNumbers !== null) {
          (0, auth_config_1.validateTestPhoneNumbers)(request.testPhoneNumbers);
        } else if (request.testPhoneNumbers === null && createRequest) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${label}.testPhoneNumbers" must be a non-null object.`);
        }
        if (typeof request.multiFactorConfig !== "undefined") {
          auth_config_1.MultiFactorAuthConfig.buildServerRequest(request.multiFactorConfig);
        }
        if (typeof request.smsRegionConfig !== "undefined") {
          auth_config_1.SmsRegionsAuthConfig.validate(request.smsRegionConfig);
        }
        if (typeof request.recaptchaConfig !== "undefined") {
          auth_config_1.RecaptchaAuthConfig.validate(request.recaptchaConfig);
        }
        if (typeof request.passwordPolicyConfig !== "undefined") {
          auth_config_1.PasswordPolicyAuthConfig.buildServerRequest(request.passwordPolicyConfig);
        }
        if (typeof request.emailPrivacyConfig !== "undefined") {
          auth_config_1.EmailPrivacyAuthConfig.validate(request.emailPrivacyConfig);
        }
      }
      /**
       * The Tenant object constructor.
       *
       * @param response - The server side response used to initialize the Tenant object.
       * @constructor
       * @internal
       */
      constructor(response) {
        const tenantId = _Tenant.getTenantIdFromResourceName(response.name);
        if (!tenantId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid tenant response");
        }
        this.tenantId = tenantId;
        this.displayName = response.displayName;
        try {
          this.emailSignInConfig_ = new auth_config_1.EmailSignInConfig(response);
        } catch (e) {
          this.emailSignInConfig_ = new auth_config_1.EmailSignInConfig({
            allowPasswordSignup: false
          });
        }
        this.anonymousSignInEnabled = !!response.enableAnonymousUser;
        if (typeof response.mfaConfig !== "undefined") {
          this.multiFactorConfig_ = new auth_config_1.MultiFactorAuthConfig(response.mfaConfig);
        }
        if (typeof response.testPhoneNumbers !== "undefined") {
          this.testPhoneNumbers = (0, deep_copy_1.deepCopy)(response.testPhoneNumbers || {});
        }
        if (typeof response.smsRegionConfig !== "undefined") {
          this.smsRegionConfig = (0, deep_copy_1.deepCopy)(response.smsRegionConfig);
        }
        if (typeof response.recaptchaConfig !== "undefined") {
          this.recaptchaConfig_ = new auth_config_1.RecaptchaAuthConfig(response.recaptchaConfig);
        }
        if (typeof response.passwordPolicyConfig !== "undefined") {
          this.passwordPolicyConfig = new auth_config_1.PasswordPolicyAuthConfig(response.passwordPolicyConfig);
        }
        if (typeof response.emailPrivacyConfig !== "undefined") {
          this.emailPrivacyConfig = (0, deep_copy_1.deepCopy)(response.emailPrivacyConfig);
        }
      }
      /**
       * The email sign in provider configuration.
       */
      get emailSignInConfig() {
        return this.emailSignInConfig_;
      }
      /**
       * The multi-factor auth configuration on the current tenant.
       */
      get multiFactorConfig() {
        return this.multiFactorConfig_;
      }
      /**
       * The recaptcha config auth configuration of the current tenant.
       */
      get recaptchaConfig() {
        return this.recaptchaConfig_;
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        var _a, _b, _c;
        const json = {
          tenantId: this.tenantId,
          displayName: this.displayName,
          emailSignInConfig: (_a = this.emailSignInConfig_) == null ? void 0 : _a.toJSON(),
          multiFactorConfig: (_b = this.multiFactorConfig_) == null ? void 0 : _b.toJSON(),
          anonymousSignInEnabled: this.anonymousSignInEnabled,
          testPhoneNumbers: this.testPhoneNumbers,
          smsRegionConfig: (0, deep_copy_1.deepCopy)(this.smsRegionConfig),
          recaptchaConfig: (_c = this.recaptchaConfig_) == null ? void 0 : _c.toJSON(),
          passwordPolicyConfig: (0, deep_copy_1.deepCopy)(this.passwordPolicyConfig),
          emailPrivacyConfig: (0, deep_copy_1.deepCopy)(this.emailPrivacyConfig)
        };
        if (typeof json.multiFactorConfig === "undefined") {
          delete json.multiFactorConfig;
        }
        if (typeof json.testPhoneNumbers === "undefined") {
          delete json.testPhoneNumbers;
        }
        if (typeof json.smsRegionConfig === "undefined") {
          delete json.smsRegionConfig;
        }
        if (typeof json.recaptchaConfig === "undefined") {
          delete json.recaptchaConfig;
        }
        if (typeof json.passwordPolicyConfig === "undefined") {
          delete json.passwordPolicyConfig;
        }
        if (typeof json.emailPrivacyConfig === "undefined") {
          delete json.emailPrivacyConfig;
        }
        return json;
      }
    };
    exports.Tenant = Tenant2;
  }
});

// node_modules/firebase-admin/lib/auth/identifier.js
var require_identifier = __commonJS({
  "node_modules/firebase-admin/lib/auth/identifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.isProviderIdentifier = exports.isPhoneIdentifier = exports.isEmailIdentifier = exports.isUidIdentifier = void 0;
    function isUidIdentifier(id) {
      return id.uid !== void 0;
    }
    exports.isUidIdentifier = isUidIdentifier;
    function isEmailIdentifier(id) {
      return id.email !== void 0;
    }
    exports.isEmailIdentifier = isEmailIdentifier;
    function isPhoneIdentifier(id) {
      return id.phoneNumber !== void 0;
    }
    exports.isPhoneIdentifier = isPhoneIdentifier;
    function isProviderIdentifier(id) {
      const pid = id;
      return pid.providerId !== void 0 && pid.providerUid !== void 0;
    }
    exports.isProviderIdentifier = isProviderIdentifier;
  }
});

// node_modules/firebase-admin/lib/auth/project-config.js
var require_project_config = __commonJS({
  "node_modules/firebase-admin/lib/auth/project-config.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectConfig = void 0;
    var validator = require_validator();
    var error_1 = require_error();
    var auth_config_1 = require_auth_config();
    var deep_copy_1 = require_deep_copy();
    var ProjectConfig2 = class _ProjectConfig {
      /**
       * The multi-factor auth configuration.
       */
      get multiFactorConfig() {
        return this.multiFactorConfig_;
      }
      /**
       * Validates a project config options object. Throws an error on failure.
       *
       * @param request - The project config options object to validate.
       */
      static validate(request) {
        if (!validator.isNonNullObject(request)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"UpdateProjectConfigRequest" must be a valid non-null object.');
        }
        const validKeys = {
          smsRegionConfig: true,
          multiFactorConfig: true,
          recaptchaConfig: true,
          passwordPolicyConfig: true,
          emailPrivacyConfig: true
        };
        for (const key in request) {
          if (!(key in validKeys)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${key}" is not a valid UpdateProjectConfigRequest parameter.`);
          }
        }
        if (typeof request.smsRegionConfig !== "undefined") {
          auth_config_1.SmsRegionsAuthConfig.validate(request.smsRegionConfig);
        }
        if (typeof request.multiFactorConfig !== "undefined") {
          auth_config_1.MultiFactorAuthConfig.validate(request.multiFactorConfig);
        }
        if (typeof request.recaptchaConfig !== "undefined") {
          auth_config_1.RecaptchaAuthConfig.validate(request.recaptchaConfig);
        }
        if (typeof request.passwordPolicyConfig !== "undefined") {
          auth_config_1.PasswordPolicyAuthConfig.validate(request.passwordPolicyConfig);
        }
        if (typeof request.emailPrivacyConfig !== "undefined") {
          auth_config_1.EmailPrivacyAuthConfig.validate(request.emailPrivacyConfig);
        }
      }
      /**
       * Build the corresponding server request for a UpdateProjectConfigRequest object.
       * @param configOptions - The properties to convert to a server request.
       * @returns  The equivalent server request.
       *
       * @internal
       */
      static buildServerRequest(configOptions) {
        _ProjectConfig.validate(configOptions);
        const request = {};
        if (typeof configOptions.smsRegionConfig !== "undefined") {
          request.smsRegionConfig = configOptions.smsRegionConfig;
        }
        if (typeof configOptions.multiFactorConfig !== "undefined") {
          request.mfa = auth_config_1.MultiFactorAuthConfig.buildServerRequest(configOptions.multiFactorConfig);
        }
        if (typeof configOptions.recaptchaConfig !== "undefined") {
          request.recaptchaConfig = configOptions.recaptchaConfig;
        }
        if (typeof configOptions.passwordPolicyConfig !== "undefined") {
          request.passwordPolicyConfig = auth_config_1.PasswordPolicyAuthConfig.buildServerRequest(configOptions.passwordPolicyConfig);
        }
        if (typeof configOptions.emailPrivacyConfig !== "undefined") {
          request.emailPrivacyConfig = configOptions.emailPrivacyConfig;
        }
        return request;
      }
      /**
       * The reCAPTCHA configuration.
       */
      get recaptchaConfig() {
        return this.recaptchaConfig_;
      }
      /**
       * The Project Config object constructor.
       *
       * @param response - The server side response used to initialize the Project Config object.
       * @constructor
       * @internal
       */
      constructor(response) {
        if (typeof response.smsRegionConfig !== "undefined") {
          this.smsRegionConfig = response.smsRegionConfig;
        }
        if (typeof response.mfa !== "undefined") {
          this.multiFactorConfig_ = new auth_config_1.MultiFactorAuthConfig(response.mfa);
        }
        if (typeof response.recaptchaConfig !== "undefined") {
          this.recaptchaConfig_ = new auth_config_1.RecaptchaAuthConfig(response.recaptchaConfig);
        }
        if (typeof response.passwordPolicyConfig !== "undefined") {
          this.passwordPolicyConfig = new auth_config_1.PasswordPolicyAuthConfig(response.passwordPolicyConfig);
        }
        if (typeof response.emailPrivacyConfig !== "undefined") {
          this.emailPrivacyConfig = response.emailPrivacyConfig;
        }
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        var _a;
        const json = {
          smsRegionConfig: (0, deep_copy_1.deepCopy)(this.smsRegionConfig),
          multiFactorConfig: (0, deep_copy_1.deepCopy)(this.multiFactorConfig),
          recaptchaConfig: (_a = this.recaptchaConfig_) == null ? void 0 : _a.toJSON(),
          passwordPolicyConfig: (0, deep_copy_1.deepCopy)(this.passwordPolicyConfig),
          emailPrivacyConfig: (0, deep_copy_1.deepCopy)(this.emailPrivacyConfig)
        };
        if (typeof json.smsRegionConfig === "undefined") {
          delete json.smsRegionConfig;
        }
        if (typeof json.multiFactorConfig === "undefined") {
          delete json.multiFactorConfig;
        }
        if (typeof json.recaptchaConfig === "undefined") {
          delete json.recaptchaConfig;
        }
        if (typeof json.passwordPolicyConfig === "undefined") {
          delete json.passwordPolicyConfig;
        }
        if (typeof json.emailPrivacyConfig === "undefined") {
          delete json.emailPrivacyConfig;
        }
        return json;
      }
    };
    exports.ProjectConfig = ProjectConfig2;
  }
});

// node_modules/firebase-admin/lib/auth/auth-api-request.js
var require_auth_api_request = __commonJS({
  "node_modules/firebase-admin/lib/auth/auth-api-request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.useEmulator = exports.TenantAwareAuthRequestHandler = exports.AuthRequestHandler = exports.AbstractAuthRequestHandler = exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = exports.FIREBASE_AUTH_DELETE_ACCOUNT = exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = exports.FIREBASE_AUTH_UPLOAD_ACCOUNT = exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = exports.EMAIL_ACTION_REQUEST_TYPES = exports.RESERVED_CLAIMS = void 0;
    var validator = require_validator();
    var deep_copy_1 = require_deep_copy();
    var error_1 = require_error();
    var api_request_1 = require_api_request();
    var utils = require_utils();
    var user_import_builder_1 = require_user_import_builder();
    var action_code_settings_builder_1 = require_action_code_settings_builder();
    var tenant_1 = require_tenant();
    var identifier_1 = require_identifier();
    var auth_config_1 = require_auth_config();
    var project_config_1 = require_project_config();
    var FIREBASE_AUTH_HEADER = {
      "X-Client-Version": `Node/Admin/${utils.getSdkVersion()}`
    };
    var FIREBASE_AUTH_TIMEOUT = 25e3;
    exports.RESERVED_CLAIMS = [
      "acr",
      "amr",
      "at_hash",
      "aud",
      "auth_time",
      "azp",
      "cnf",
      "c_hash",
      "exp",
      "iat",
      "iss",
      "jti",
      "nbf",
      "nonce",
      "sub",
      "firebase"
    ];
    exports.EMAIL_ACTION_REQUEST_TYPES = [
      "PASSWORD_RESET",
      "VERIFY_EMAIL",
      "EMAIL_SIGNIN",
      "VERIFY_AND_CHANGE_EMAIL"
    ];
    var MAX_CLAIMS_PAYLOAD_SIZE = 1e3;
    var MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE = 1e3;
    var MAX_UPLOAD_ACCOUNT_BATCH_SIZE = 1e3;
    var MAX_GET_ACCOUNTS_BATCH_SIZE = 100;
    var MAX_DELETE_ACCOUNTS_BATCH_SIZE = 1e3;
    var MIN_SESSION_COOKIE_DURATION_SECS = 5 * 60;
    var MAX_SESSION_COOKIE_DURATION_SECS = 14 * 24 * 60 * 60;
    var MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE = 100;
    var FIREBASE_AUTH_BASE_URL_FORMAT = "https://identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}";
    var FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT = "http://{host}/identitytoolkit.googleapis.com/{version}/projects/{projectId}{api}";
    var FIREBASE_AUTH_TENANT_URL_FORMAT = FIREBASE_AUTH_BASE_URL_FORMAT.replace("projects/{projectId}", "projects/{projectId}/tenants/{tenantId}");
    var FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT = FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT.replace("projects/{projectId}", "projects/{projectId}/tenants/{tenantId}");
    var MAX_LIST_TENANT_PAGE_SIZE = 1e3;
    var WriteOperationType;
    (function(WriteOperationType2) {
      WriteOperationType2["Create"] = "create";
      WriteOperationType2["Update"] = "update";
      WriteOperationType2["Upload"] = "upload";
    })(WriteOperationType || (WriteOperationType = {}));
    var AuthResourceUrlBuilder = class {
      /**
       * The resource URL builder constructor.
       *
       * @param projectId - The resource project ID.
       * @param version - The endpoint API version.
       * @constructor
       */
      constructor(app, version = "v1") {
        this.app = app;
        this.version = version;
        if (useEmulator()) {
          this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_BASE_URL_FORMAT, {
            host: emulatorHost()
          });
        } else {
          this.urlFormat = FIREBASE_AUTH_BASE_URL_FORMAT;
        }
      }
      /**
       * Returns the resource URL corresponding to the provided parameters.
       *
       * @param api - The backend API name.
       * @param params - The optional additional parameters to substitute in the
       *     URL path.
       * @returns The corresponding resource URL.
       */
      getUrl(api, params) {
        return this.getProjectId().then((projectId) => {
          const baseParams = {
            version: this.version,
            projectId,
            api: api || ""
          };
          const baseUrl = utils.formatString(this.urlFormat, baseParams);
          return utils.formatString(baseUrl, params || {});
        });
      }
      getProjectId() {
        if (this.projectId) {
          return Promise.resolve(this.projectId);
        }
        return utils.findProjectId(this.app).then((projectId) => {
          if (!validator.isNonEmptyString(projectId)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, "Failed to determine project ID for Auth. Initialize the SDK with service account credentials or set project ID as an app option. Alternatively set the GOOGLE_CLOUD_PROJECT environment variable.");
          }
          this.projectId = projectId;
          return projectId;
        });
      }
    };
    var TenantAwareAuthResourceUrlBuilder = class extends AuthResourceUrlBuilder {
      /**
       * The tenant aware resource URL builder constructor.
       *
       * @param projectId - The resource project ID.
       * @param version - The endpoint API version.
       * @param tenantId - The tenant ID.
       * @constructor
       */
      constructor(app, version, tenantId) {
        super(app, version);
        this.app = app;
        this.version = version;
        this.tenantId = tenantId;
        if (useEmulator()) {
          this.urlFormat = utils.formatString(FIREBASE_AUTH_EMULATOR_TENANT_URL_FORMAT, {
            host: emulatorHost()
          });
        } else {
          this.urlFormat = FIREBASE_AUTH_TENANT_URL_FORMAT;
        }
      }
      /**
       * Returns the resource URL corresponding to the provided parameters.
       *
       * @param api - The backend API name.
       * @param params - The optional additional parameters to substitute in the
       *     URL path.
       * @returns The corresponding resource URL.
       */
      getUrl(api, params) {
        return super.getUrl(api, params).then((url) => {
          return utils.formatString(url, { tenantId: this.tenantId });
        });
      }
    };
    var AuthHttpClient = class extends api_request_1.AuthorizedHttpClient {
      getToken() {
        if (useEmulator()) {
          return Promise.resolve("owner");
        }
        return super.getToken();
      }
    };
    function validateAuthFactorInfo(request) {
      const validKeys = {
        mfaEnrollmentId: true,
        displayName: true,
        phoneInfo: true,
        enrolledAt: true
      };
      for (const key in request) {
        if (!(key in validKeys)) {
          delete request[key];
        }
      }
      const authFactorInfoIdentifier = request.mfaEnrollmentId || request.phoneInfo || JSON.stringify(request);
      if (typeof request.mfaEnrollmentId !== "undefined" && !validator.isNonEmptyString(request.mfaEnrollmentId)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, 'The second factor "uid" must be a valid non-empty string.');
      }
      if (typeof request.displayName !== "undefined" && !validator.isString(request.displayName)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The second factor "displayName" for "${authFactorInfoIdentifier}" must be a valid string.`);
      }
      if (typeof request.enrolledAt !== "undefined" && !validator.isISODateString(request.enrolledAt)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLMENT_TIME, `The second factor "enrollmentTime" for "${authFactorInfoIdentifier}" must be a valid UTC date string.`);
      }
      if (typeof request.phoneInfo !== "undefined") {
        if (!validator.isPhoneNumber(request.phoneInfo)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER, `The second factor "phoneNumber" for "${authFactorInfoIdentifier}" must be a non-empty E.164 standard compliant identifier string.`);
        }
      } else {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS, "MFAInfo object provided is invalid.");
      }
    }
    function validateProviderUserInfo(request) {
      const validKeys = {
        rawId: true,
        providerId: true,
        email: true,
        displayName: true,
        photoUrl: true
      };
      for (const key in request) {
        if (!(key in validKeys)) {
          delete request[key];
        }
      }
      if (!validator.isNonEmptyString(request.providerId)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);
      }
      if (typeof request.displayName !== "undefined" && typeof request.displayName !== "string") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME, `The provider "displayName" for "${request.providerId}" must be a valid string.`);
      }
      if (!validator.isNonEmptyString(request.rawId)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID, `The provider "uid" for "${request.providerId}" must be a valid non-empty string.`);
      }
      if (typeof request.email !== "undefined" && !validator.isEmail(request.email)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL, `The provider "email" for "${request.providerId}" must be a valid email string.`);
      }
      if (typeof request.photoUrl !== "undefined" && !validator.isURL(request.photoUrl)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL, `The provider "photoURL" for "${request.providerId}" must be a valid URL string.`);
      }
    }
    function validateCreateEditRequest(request, writeOperationType) {
      const uploadAccountRequest = writeOperationType === WriteOperationType.Upload;
      const validKeys = {
        displayName: true,
        localId: true,
        email: true,
        password: true,
        rawPassword: true,
        emailVerified: true,
        photoUrl: true,
        disabled: true,
        disableUser: true,
        deleteAttribute: true,
        deleteProvider: true,
        sanityCheck: true,
        phoneNumber: true,
        customAttributes: true,
        validSince: true,
        // Pass linkProviderUserInfo only for updates (i.e. not for uploads.)
        linkProviderUserInfo: !uploadAccountRequest,
        // Pass tenantId only for uploadAccount requests.
        tenantId: uploadAccountRequest,
        passwordHash: uploadAccountRequest,
        salt: uploadAccountRequest,
        createdAt: uploadAccountRequest,
        lastLoginAt: uploadAccountRequest,
        providerUserInfo: uploadAccountRequest,
        mfaInfo: uploadAccountRequest,
        // Only for non-uploadAccount requests.
        mfa: !uploadAccountRequest
      };
      for (const key in request) {
        if (!(key in validKeys)) {
          delete request[key];
        }
      }
      if (typeof request.tenantId !== "undefined" && !validator.isNonEmptyString(request.tenantId)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);
      }
      if (typeof request.displayName !== "undefined" && !validator.isString(request.displayName)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISPLAY_NAME);
      }
      if ((typeof request.localId !== "undefined" || uploadAccountRequest) && !validator.isUid(request.localId)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);
      }
      if (typeof request.email !== "undefined" && !validator.isEmail(request.email)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);
      }
      if (typeof request.phoneNumber !== "undefined" && !validator.isPhoneNumber(request.phoneNumber)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);
      }
      if (typeof request.password !== "undefined" && !validator.isPassword(request.password)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);
      }
      if (typeof request.rawPassword !== "undefined" && !validator.isPassword(request.rawPassword)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD);
      }
      if (typeof request.emailVerified !== "undefined" && typeof request.emailVerified !== "boolean") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL_VERIFIED);
      }
      if (typeof request.photoUrl !== "undefined" && !validator.isURL(request.photoUrl)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHOTO_URL);
      }
      if (typeof request.disabled !== "undefined" && typeof request.disabled !== "boolean") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);
      }
      if (typeof request.validSince !== "undefined" && !validator.isNumber(request.validSince)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TOKENS_VALID_AFTER_TIME);
      }
      if (typeof request.createdAt !== "undefined" && !validator.isNumber(request.createdAt)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREATION_TIME);
      }
      if (typeof request.lastLoginAt !== "undefined" && !validator.isNumber(request.lastLoginAt)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_LAST_SIGN_IN_TIME);
      }
      if (typeof request.disableUser !== "undefined" && typeof request.disableUser !== "boolean") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_DISABLED_FIELD);
      }
      if (typeof request.customAttributes !== "undefined") {
        let developerClaims;
        try {
          developerClaims = JSON.parse(request.customAttributes);
        } catch (error) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CLAIMS, error.message);
        }
        const invalidClaims = [];
        exports.RESERVED_CLAIMS.forEach((blacklistedClaim) => {
          if (Object.prototype.hasOwnProperty.call(developerClaims, blacklistedClaim)) {
            invalidClaims.push(blacklistedClaim);
          }
        });
        if (invalidClaims.length > 0) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.FORBIDDEN_CLAIM, invalidClaims.length > 1 ? `Developer claims "${invalidClaims.join('", "')}" are reserved and cannot be specified.` : `Developer claim "${invalidClaims[0]}" is reserved and cannot be specified.`);
        }
        if (request.customAttributes.length > MAX_CLAIMS_PAYLOAD_SIZE) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.CLAIMS_TOO_LARGE, `Developer claims payload should not exceed ${MAX_CLAIMS_PAYLOAD_SIZE} characters.`);
        }
      }
      if (typeof request.passwordHash !== "undefined" && !validator.isString(request.passwordHash)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_HASH);
      }
      if (typeof request.salt !== "undefined" && !validator.isString(request.salt)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PASSWORD_SALT);
      }
      if (typeof request.providerUserInfo !== "undefined" && !validator.isArray(request.providerUserInfo)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_DATA);
      } else if (validator.isArray(request.providerUserInfo)) {
        request.providerUserInfo.forEach((providerUserInfoEntry) => {
          validateProviderUserInfo(providerUserInfoEntry);
        });
      }
      if (typeof request.linkProviderUserInfo !== "undefined") {
        validateProviderUserInfo(request.linkProviderUserInfo);
      }
      let enrollments = null;
      if (request.mfaInfo) {
        enrollments = request.mfaInfo;
      } else if (request.mfa && request.mfa.enrollments) {
        enrollments = request.mfa.enrollments;
      }
      if (enrollments) {
        if (!validator.isArray(enrollments)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ENROLLED_FACTORS);
        }
        enrollments.forEach((authFactorInfoEntry) => {
          validateAuthFactorInfo(authFactorInfoEntry);
        });
      }
    }
    exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE = new api_request_1.ApiSettings(":createSessionCookie", "POST").setRequestValidator((request) => {
      if (!validator.isNonEmptyString(request.idToken)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN);
      }
      if (!validator.isNumber(request.validDuration) || request.validDuration < MIN_SESSION_COOKIE_DURATION_SECS || request.validDuration > MAX_SESSION_COOKIE_DURATION_SECS) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION);
      }
    }).setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.sessionCookie)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR);
      }
    });
    exports.FIREBASE_AUTH_UPLOAD_ACCOUNT = new api_request_1.ApiSettings("/accounts:batchCreate", "POST");
    exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT = new api_request_1.ApiSettings("/accounts:batchGet", "GET").setRequestValidator((request) => {
      if (typeof request.nextPageToken !== "undefined" && !validator.isNonEmptyString(request.nextPageToken)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
      }
      if (!validator.isNumber(request.maxResults) || request.maxResults <= 0 || request.maxResults > MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive integer that does not exceed ${MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE}.`);
      }
    });
    exports.FIREBASE_AUTH_GET_ACCOUNT_INFO = new api_request_1.ApiSettings("/accounts:lookup", "POST").setRequestValidator((request) => {
      if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
      }
    }).setResponseValidator((response) => {
      if (!response.users || !response.users.length) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);
      }
    });
    exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO = new api_request_1.ApiSettings("/accounts:lookup", "POST").setRequestValidator((request) => {
      if (!request.localId && !request.email && !request.phoneNumber && !request.federatedUserId) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
      }
    });
    exports.FIREBASE_AUTH_DELETE_ACCOUNT = new api_request_1.ApiSettings("/accounts:delete", "POST").setRequestValidator((request) => {
      if (!request.localId) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
      }
    });
    exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS = new api_request_1.ApiSettings("/accounts:batchDelete", "POST").setRequestValidator((request) => {
      if (!request.localIds) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifiers");
      }
      if (typeof request.force === "undefined" || request.force !== true) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing force=true field");
      }
    }).setResponseValidator((response) => {
      const errors = response.errors || [];
      errors.forEach((batchDeleteErrorInfo) => {
        if (typeof batchDeleteErrorInfo.index === "undefined") {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.index field");
        }
        if (!batchDeleteErrorInfo.localId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server BatchDeleteAccountResponse is missing an errors.localId field");
        }
      });
    });
    exports.FIREBASE_AUTH_SET_ACCOUNT_INFO = new api_request_1.ApiSettings("/accounts:update", "POST").setRequestValidator((request) => {
      if (typeof request.localId === "undefined") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Server request is missing user identifier");
      }
      if (typeof request.tenantId !== "undefined") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"tenantId" is an invalid "UpdateRequest" property.');
      }
      validateCreateEditRequest(request, WriteOperationType.Update);
    }).setResponseValidator((response) => {
      if (!response.localId) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_NOT_FOUND);
      }
    });
    exports.FIREBASE_AUTH_SIGN_UP_NEW_USER = new api_request_1.ApiSettings("/accounts", "POST").setRequestValidator((request) => {
      if (typeof request.customAttributes !== "undefined") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"customAttributes" cannot be set when creating a new user.');
      }
      if (typeof request.validSince !== "undefined") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"validSince" cannot be set when creating a new user.');
      }
      if (typeof request.tenantId !== "undefined") {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"tenantId" is an invalid "CreateRequest" property.');
      }
      validateCreateEditRequest(request, WriteOperationType.Create);
    }).setResponseValidator((response) => {
      if (!response.localId) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new user");
      }
    });
    var FIREBASE_AUTH_GET_OOB_CODE = new api_request_1.ApiSettings("/accounts:sendOobCode", "POST").setRequestValidator((request) => {
      if (!validator.isEmail(request.email)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);
      }
      if (typeof request.newEmail !== "undefined" && !validator.isEmail(request.newEmail)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_NEW_EMAIL);
      }
      if (exports.EMAIL_ACTION_REQUEST_TYPES.indexOf(request.requestType) === -1) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `"${request.requestType}" is not a supported email action request type.`);
      }
    }).setResponseValidator((response) => {
      if (!response.oobLink) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create the email action link");
      }
    });
    var GET_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings("/oauthIdpConfigs/{providerId}", "GET").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get OIDC configuration");
      }
    });
    var DELETE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings("/oauthIdpConfigs/{providerId}", "DELETE");
    var CREATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings("/oauthIdpConfigs?oauthIdpConfigId={providerId}", "POST").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new OIDC configuration");
      }
    });
    var UPDATE_OAUTH_IDP_CONFIG = new api_request_1.ApiSettings("/oauthIdpConfigs/{providerId}?updateMask={updateMask}", "PATCH").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update OIDC configuration");
      }
    });
    var LIST_OAUTH_IDP_CONFIGS = new api_request_1.ApiSettings("/oauthIdpConfigs", "GET").setRequestValidator((request) => {
      if (typeof request.pageToken !== "undefined" && !validator.isNonEmptyString(request.pageToken)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
      }
      if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive integer that does not exceed ${MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE}.`);
      }
    });
    var GET_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings("/inboundSamlConfigs/{providerId}", "GET").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get SAML configuration");
      }
    });
    var DELETE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings("/inboundSamlConfigs/{providerId}", "DELETE");
    var CREATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings("/inboundSamlConfigs?inboundSamlConfigId={providerId}", "POST").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new SAML configuration");
      }
    });
    var UPDATE_INBOUND_SAML_CONFIG = new api_request_1.ApiSettings("/inboundSamlConfigs/{providerId}?updateMask={updateMask}", "PATCH").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update SAML configuration");
      }
    });
    var LIST_INBOUND_SAML_CONFIGS = new api_request_1.ApiSettings("/inboundSamlConfigs", "GET").setRequestValidator((request) => {
      if (typeof request.pageToken !== "undefined" && !validator.isNonEmptyString(request.pageToken)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
      }
      if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive integer that does not exceed ${MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE}.`);
      }
    });
    var AbstractAuthRequestHandler = class _AbstractAuthRequestHandler {
      /**
       * @param response - The response to check for errors.
       * @returns The error code if present; null otherwise.
       */
      static getErrorCode(response) {
        return validator.isNonNullObject(response) && response.error && response.error.message || null;
      }
      static addUidToRequest(id, request) {
        if (!validator.isUid(id.uid)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);
        }
        request.localId ? request.localId.push(id.uid) : request.localId = [id.uid];
        return request;
      }
      static addEmailToRequest(id, request) {
        if (!validator.isEmail(id.email)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL);
        }
        request.email ? request.email.push(id.email) : request.email = [id.email];
        return request;
      }
      static addPhoneToRequest(id, request) {
        if (!validator.isPhoneNumber(id.phoneNumber)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER);
        }
        request.phoneNumber ? request.phoneNumber.push(id.phoneNumber) : request.phoneNumber = [id.phoneNumber];
        return request;
      }
      static addProviderToRequest(id, request) {
        if (!validator.isNonEmptyString(id.providerId)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);
        }
        if (!validator.isNonEmptyString(id.providerUid)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_UID);
        }
        const federatedUserId = {
          providerId: id.providerId,
          rawId: id.providerUid
        };
        request.federatedUserId ? request.federatedUserId.push(federatedUserId) : request.federatedUserId = [federatedUserId];
        return request;
      }
      /**
       * @param app - The app used to fetch access tokens to sign API requests.
       * @constructor
       */
      constructor(app) {
        this.app = app;
        if (typeof app !== "object" || app === null || !("options" in app)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "First argument passed to admin.auth() must be a valid Firebase app instance.");
        }
        this.httpClient = new AuthHttpClient(app);
      }
      /**
       * Creates a new Firebase session cookie with the specified duration that can be used for
       * session management (set as a server side session cookie with custom cookie policy).
       * The session cookie JWT will have the same payload claims as the provided ID token.
       *
       * @param idToken - The Firebase ID token to exchange for a session cookie.
       * @param expiresIn - The session cookie duration in milliseconds.
       *
       * @returns A promise that resolves on success with the created session cookie.
       */
      createSessionCookie(idToken, expiresIn) {
        const request = {
          idToken,
          // Convert to seconds.
          validDuration: expiresIn / 1e3
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_CREATE_SESSION_COOKIE, request).then((response) => response.sessionCookie);
      }
      /**
       * Looks up a user by uid.
       *
       * @param uid - The uid of the user to lookup.
       * @returns A promise that resolves with the user information.
       */
      getAccountInfoByUid(uid) {
        if (!validator.isUid(uid)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
        }
        const request = {
          localId: [uid]
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);
      }
      /**
       * Looks up a user by email.
       *
       * @param email - The email of the user to lookup.
       * @returns A promise that resolves with the user information.
       */
      getAccountInfoByEmail(email) {
        if (!validator.isEmail(email)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_EMAIL));
        }
        const request = {
          email: [email]
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);
      }
      /**
       * Looks up a user by phone number.
       *
       * @param phoneNumber - The phone number of the user to lookup.
       * @returns A promise that resolves with the user information.
       */
      getAccountInfoByPhoneNumber(phoneNumber) {
        if (!validator.isPhoneNumber(phoneNumber)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PHONE_NUMBER));
        }
        const request = {
          phoneNumber: [phoneNumber]
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);
      }
      getAccountInfoByFederatedUid(providerId, rawId) {
        if (!validator.isNonEmptyString(providerId) || !validator.isNonEmptyString(rawId)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID);
        }
        const request = {
          federatedUserId: [{
            providerId,
            rawId
          }]
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNT_INFO, request);
      }
      /**
       * Looks up multiple users by their identifiers (uid, email, etc).
       *
       * @param identifiers - The identifiers indicating the users
       *     to be looked up. Must have <= 100 entries.
       * @param A - promise that resolves with the set of successfully
       *     looked up users. Possibly empty if no users were looked up.
       */
      getAccountInfoByIdentifiers(identifiers) {
        if (identifiers.length === 0) {
          return Promise.resolve({ users: [] });
        } else if (identifiers.length > MAX_GET_ACCOUNTS_BATCH_SIZE) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, "`identifiers` parameter must have <= " + MAX_GET_ACCOUNTS_BATCH_SIZE + " entries.");
        }
        let request = {};
        for (const id of identifiers) {
          if ((0, identifier_1.isUidIdentifier)(id)) {
            request = _AbstractAuthRequestHandler.addUidToRequest(id, request);
          } else if ((0, identifier_1.isEmailIdentifier)(id)) {
            request = _AbstractAuthRequestHandler.addEmailToRequest(id, request);
          } else if ((0, identifier_1.isPhoneIdentifier)(id)) {
            request = _AbstractAuthRequestHandler.addPhoneToRequest(id, request);
          } else if ((0, identifier_1.isProviderIdentifier)(id)) {
            request = _AbstractAuthRequestHandler.addProviderToRequest(id, request);
          } else {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Unrecognized identifier: " + id);
          }
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_GET_ACCOUNTS_INFO, request);
      }
      /**
       * Exports the users (single batch only) with a size of maxResults and starting from
       * the offset as specified by pageToken.
       *
       * @param maxResults - The page size, 1000 if undefined. This is also the maximum
       *     allowed limit.
       * @param pageToken - The next page token. If not specified, returns users starting
       *     without any offset. Users are returned in the order they were created from oldest to
       *     newest, relative to the page token offset.
       * @returns A promise that resolves with the current batch of downloaded
       *     users and the next page token if available. For the last page, an empty list of users
       *     and no page token are returned.
       */
      downloadAccount(maxResults = MAX_DOWNLOAD_ACCOUNT_PAGE_SIZE, pageToken) {
        const request = {
          maxResults,
          nextPageToken: pageToken
        };
        if (typeof request.nextPageToken === "undefined") {
          delete request.nextPageToken;
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DOWNLOAD_ACCOUNT, request).then((response) => {
          if (!response.users) {
            response.users = [];
          }
          return response;
        });
      }
      /**
       * Imports the list of users provided to Firebase Auth. This is useful when
       * migrating from an external authentication system without having to use the Firebase CLI SDK.
       * At most, 1000 users are allowed to be imported one at a time.
       * When importing a list of password users, UserImportOptions are required to be specified.
       *
       * @param users - The list of user records to import to Firebase Auth.
       * @param options - The user import options, required when the users provided
       *     include password credentials.
       * @returns A promise that resolves when the operation completes
       *     with the result of the import. This includes the number of successful imports, the number
       *     of failed uploads and their corresponding errors.
       */
      uploadAccount(users, options) {
        const userImportBuilder = new user_import_builder_1.UserImportBuilder(users, options, (userRequest) => {
          validateCreateEditRequest(userRequest, WriteOperationType.Upload);
        });
        const request = userImportBuilder.buildRequest();
        if (validator.isArray(users) && users.length > MAX_UPLOAD_ACCOUNT_BATCH_SIZE) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, `A maximum of ${MAX_UPLOAD_ACCOUNT_BATCH_SIZE} users can be imported at once.`);
        }
        if (!request.users || request.users.length === 0) {
          return Promise.resolve(userImportBuilder.buildResponse([]));
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_UPLOAD_ACCOUNT, request).then((response) => {
          const failedUploads = response.error || [];
          return userImportBuilder.buildResponse(failedUploads);
        });
      }
      /**
       * Deletes an account identified by a uid.
       *
       * @param uid - The uid of the user to delete.
       * @returns A promise that resolves when the user is deleted.
       */
      deleteAccount(uid) {
        if (!validator.isUid(uid)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
        }
        const request = {
          localId: uid
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_DELETE_ACCOUNT, request);
      }
      deleteAccounts(uids, force) {
        if (uids.length === 0) {
          return Promise.resolve({});
        } else if (uids.length > MAX_DELETE_ACCOUNTS_BATCH_SIZE) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MAXIMUM_USER_COUNT_EXCEEDED, "`uids` parameter must have <= " + MAX_DELETE_ACCOUNTS_BATCH_SIZE + " entries.");
        }
        const request = {
          localIds: [],
          force
        };
        uids.forEach((uid) => {
          if (!validator.isUid(uid)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID);
          }
          request.localIds.push(uid);
        });
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_BATCH_DELETE_ACCOUNTS, request);
      }
      /**
       * Sets additional developer claims on an existing user identified by provided UID.
       *
       * @param uid - The user to edit.
       * @param customUserClaims - The developer claims to set.
       * @returns A promise that resolves when the operation completes
       *     with the user id that was edited.
       */
      setCustomUserClaims(uid, customUserClaims) {
        if (!validator.isUid(uid)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
        } else if (!validator.isObject(customUserClaims)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "CustomUserClaims argument must be an object or null."));
        }
        if (customUserClaims === null) {
          customUserClaims = {};
        }
        const request = {
          localId: uid,
          customAttributes: JSON.stringify(customUserClaims)
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then((response) => {
          return response.localId;
        });
      }
      /**
       * Edits an existing user.
       *
       * @param uid - The user to edit.
       * @param properties - The properties to set on the user.
       * @returns A promise that resolves when the operation completes
       *     with the user id that was edited.
       */
      updateExistingAccount(uid, properties) {
        if (!validator.isUid(uid)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
        } else if (!validator.isNonNullObject(properties)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Properties argument must be a non-null object."));
        } else if (validator.isNonNullObject(properties.providerToLink)) {
          if (!validator.isNonEmptyString(properties.providerToLink.providerId)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "providerToLink.providerId of properties argument must be a non-empty string.");
          }
          if (!validator.isNonEmptyString(properties.providerToLink.uid)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "providerToLink.uid of properties argument must be a non-empty string.");
          }
        } else if (typeof properties.providersToUnlink !== "undefined") {
          if (!validator.isArray(properties.providersToUnlink)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "providersToUnlink of properties argument must be an array of strings.");
          }
          properties.providersToUnlink.forEach((providerId) => {
            if (!validator.isNonEmptyString(providerId)) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "providersToUnlink of properties argument must be an array of strings.");
            }
          });
        }
        const request = (0, deep_copy_1.deepCopy)(properties);
        request.localId = uid;
        const deletableParams = {
          displayName: "DISPLAY_NAME",
          photoURL: "PHOTO_URL"
        };
        request.deleteAttribute = [];
        for (const key in deletableParams) {
          if (request[key] === null) {
            request.deleteAttribute.push(deletableParams[key]);
            delete request[key];
          }
        }
        if (request.deleteAttribute.length === 0) {
          delete request.deleteAttribute;
        }
        if (request.phoneNumber === null) {
          request.deleteProvider ? request.deleteProvider.push("phone") : request.deleteProvider = ["phone"];
          delete request.phoneNumber;
        }
        if (typeof request.providerToLink !== "undefined") {
          request.linkProviderUserInfo = (0, deep_copy_1.deepCopy)(request.providerToLink);
          delete request.providerToLink;
          request.linkProviderUserInfo.rawId = request.linkProviderUserInfo.uid;
          delete request.linkProviderUserInfo.uid;
        }
        if (typeof request.providersToUnlink !== "undefined") {
          if (!validator.isArray(request.deleteProvider)) {
            request.deleteProvider = [];
          }
          request.deleteProvider = request.deleteProvider.concat(request.providersToUnlink);
          delete request.providersToUnlink;
        }
        if (typeof request.photoURL !== "undefined") {
          request.photoUrl = request.photoURL;
          delete request.photoURL;
        }
        if (typeof request.disabled !== "undefined") {
          request.disableUser = request.disabled;
          delete request.disabled;
        }
        if (validator.isNonNullObject(request.multiFactor)) {
          if (request.multiFactor.enrolledFactors === null) {
            request.mfa = {};
          } else if (validator.isArray(request.multiFactor.enrolledFactors)) {
            request.mfa = {
              enrollments: []
            };
            try {
              request.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {
                request.mfa.enrollments.push((0, user_import_builder_1.convertMultiFactorInfoToServerFormat)(multiFactorInfo));
              });
            } catch (e) {
              return Promise.reject(e);
            }
            if (request.mfa.enrollments.length === 0) {
              delete request.mfa.enrollments;
            }
          }
          delete request.multiFactor;
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then((response) => {
          return response.localId;
        });
      }
      /**
       * Revokes all refresh tokens for the specified user identified by the uid provided.
       * In addition to revoking all refresh tokens for a user, all ID tokens issued
       * before revocation will also be revoked on the Auth backend. Any request with an
       * ID token generated before revocation will be rejected with a token expired error.
       * Note that due to the fact that the timestamp is stored in seconds, any tokens minted in
       * the same second as the revocation will still be valid. If there is a chance that a token
       * was minted in the last second, delay for 1 second before revoking.
       *
       * @param uid - The user whose tokens are to be revoked.
       * @returns A promise that resolves when the operation completes
       *     successfully with the user id of the corresponding user.
       */
      revokeRefreshTokens(uid) {
        if (!validator.isUid(uid)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_UID));
        }
        const request = {
          localId: uid,
          // validSince is in UTC seconds.
          validSince: Math.floor((/* @__PURE__ */ new Date()).getTime() / 1e3)
        };
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SET_ACCOUNT_INFO, request).then((response) => {
          return response.localId;
        });
      }
      /**
       * Create a new user with the properties supplied.
       *
       * @param properties - The properties to set on the user.
       * @returns A promise that resolves when the operation completes
       *     with the user id that was created.
       */
      createNewAccount(properties) {
        if (!validator.isNonNullObject(properties)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Properties argument must be a non-null object."));
        }
        const request = (0, deep_copy_1.deepCopy)(properties);
        if (typeof request.photoURL !== "undefined") {
          request.photoUrl = request.photoURL;
          delete request.photoURL;
        }
        if (typeof request.uid !== "undefined") {
          request.localId = request.uid;
          delete request.uid;
        }
        if (validator.isNonNullObject(request.multiFactor)) {
          if (validator.isNonEmptyArray(request.multiFactor.enrolledFactors)) {
            const mfaInfo = [];
            try {
              request.multiFactor.enrolledFactors.forEach((multiFactorInfo) => {
                if ("enrollmentTime" in multiFactorInfo) {
                  throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"enrollmentTime" is not supported when adding second factors via "createUser()"');
                } else if ("uid" in multiFactorInfo) {
                  throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"uid" is not supported when adding second factors via "createUser()"');
                }
                mfaInfo.push((0, user_import_builder_1.convertMultiFactorInfoToServerFormat)(multiFactorInfo));
              });
            } catch (e) {
              return Promise.reject(e);
            }
            request.mfaInfo = mfaInfo;
          }
          delete request.multiFactor;
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), exports.FIREBASE_AUTH_SIGN_UP_NEW_USER, request).then((response) => {
          return response.localId;
        });
      }
      /**
       * Generates the out of band email action link for the email specified using the action code settings provided.
       * Returns a promise that resolves with the generated link.
       *
       * @param requestType - The request type. This could be either used for password reset,
       *     email verification, email link sign-in.
       * @param email - The email of the user the link is being sent to.
       * @param actionCodeSettings - The optional action code setings which defines whether
       *     the link is to be handled by a mobile app and the additional state information to be passed in the
       *     deep link, etc. Required when requestType === 'EMAIL_SIGNIN'
       * @param newEmail - The email address the account is being updated to.
       *     Required only for VERIFY_AND_CHANGE_EMAIL requests.
       * @returns A promise that resolves with the email action link.
       */
      getEmailActionLink(requestType, email, actionCodeSettings, newEmail) {
        let request = {
          requestType,
          email,
          returnOobLink: true,
          ...typeof newEmail !== "undefined" && { newEmail }
        };
        if (typeof actionCodeSettings === "undefined" && requestType === "EMAIL_SIGNIN") {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`actionCodeSettings` is required when `requestType` === 'EMAIL_SIGNIN'"));
        }
        if (typeof actionCodeSettings !== "undefined" || requestType === "EMAIL_SIGNIN") {
          try {
            const builder = new action_code_settings_builder_1.ActionCodeSettingsBuilder(actionCodeSettings);
            request = (0, deep_copy_1.deepExtend)(request, builder.buildRequest());
          } catch (e) {
            return Promise.reject(e);
          }
        }
        if (requestType === "VERIFY_AND_CHANGE_EMAIL" && typeof newEmail === "undefined") {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`newEmail` is required when `requestType` === 'VERIFY_AND_CHANGE_EMAIL'"));
        }
        return this.invokeRequestHandler(this.getAuthUrlBuilder(), FIREBASE_AUTH_GET_OOB_CODE, request).then((response) => {
          return response.oobLink;
        });
      }
      /**
       * Looks up an OIDC provider configuration by provider ID.
       *
       * @param providerId - The provider identifier of the configuration to lookup.
       * @returns A promise that resolves with the provider configuration information.
       */
      getOAuthIdpConfig(providerId) {
        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_OAUTH_IDP_CONFIG, {}, { providerId });
      }
      /**
       * Lists the OIDC configurations (single batch only) with a size of maxResults and starting from
       * the offset as specified by pageToken.
       *
       * @param maxResults - The page size, 100 if undefined. This is also the maximum
       *     allowed limit.
       * @param pageToken - The next page token. If not specified, returns OIDC configurations
       *     without any offset. Configurations are returned in the order they were created from oldest to
       *     newest, relative to the page token offset.
       * @returns A promise that resolves with the current batch of downloaded
       *     OIDC configurations and the next page token if available. For the last page, an empty list of provider
       *     configuration and no page token are returned.
       */
      listOAuthIdpConfigs(maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE, pageToken) {
        const request = {
          pageSize: maxResults
        };
        if (typeof pageToken !== "undefined") {
          request.pageToken = pageToken;
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_OAUTH_IDP_CONFIGS, request).then((response) => {
          if (!response.oauthIdpConfigs) {
            response.oauthIdpConfigs = [];
            delete response.nextPageToken;
          }
          return response;
        });
      }
      /**
       * Deletes an OIDC configuration identified by a providerId.
       *
       * @param providerId - The identifier of the OIDC configuration to delete.
       * @returns A promise that resolves when the OIDC provider is deleted.
       */
      deleteOAuthIdpConfig(providerId) {
        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_OAUTH_IDP_CONFIG, {}, { providerId }).then(() => {
        });
      }
      /**
       * Creates a new OIDC provider configuration with the properties provided.
       *
       * @param options - The properties to set on the new OIDC provider configuration to be created.
       * @returns A promise that resolves with the newly created OIDC
       *     configuration.
       */
      createOAuthIdpConfig(options) {
        let request;
        try {
          request = auth_config_1.OIDCConfig.buildServerRequest(options) || {};
        } catch (e) {
          return Promise.reject(e);
        }
        const providerId = options.providerId;
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_OAUTH_IDP_CONFIG, request, { providerId }).then((response) => {
          if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new OIDC provider configuration");
          }
          return response;
        });
      }
      /**
       * Updates an existing OIDC provider configuration with the properties provided.
       *
       * @param providerId - The provider identifier of the OIDC configuration to update.
       * @param options - The properties to update on the existing configuration.
       * @returns A promise that resolves with the modified provider
       *     configuration.
       */
      updateOAuthIdpConfig(providerId, options) {
        if (!auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        let request;
        try {
          request = auth_config_1.OIDCConfig.buildServerRequest(options, true) || {};
        } catch (e) {
          return Promise.reject(e);
        }
        const updateMask = utils.generateUpdateMask(request);
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_OAUTH_IDP_CONFIG, request, { providerId, updateMask: updateMask.join(",") }).then((response) => {
          if (!auth_config_1.OIDCConfig.getProviderIdFromResourceName(response.name)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update OIDC provider configuration");
          }
          return response;
        });
      }
      /**
       * Looks up an SAML provider configuration by provider ID.
       *
       * @param providerId - The provider identifier of the configuration to lookup.
       * @returns A promise that resolves with the provider configuration information.
       */
      getInboundSamlConfig(providerId) {
        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), GET_INBOUND_SAML_CONFIG, {}, { providerId });
      }
      /**
       * Lists the SAML configurations (single batch only) with a size of maxResults and starting from
       * the offset as specified by pageToken.
       *
       * @param maxResults - The page size, 100 if undefined. This is also the maximum
       *     allowed limit.
       * @param pageToken - The next page token. If not specified, returns SAML configurations starting
       *     without any offset. Configurations are returned in the order they were created from oldest to
       *     newest, relative to the page token offset.
       * @returns A promise that resolves with the current batch of downloaded
       *     SAML configurations and the next page token if available. For the last page, an empty list of provider
       *     configuration and no page token are returned.
       */
      listInboundSamlConfigs(maxResults = MAX_LIST_PROVIDER_CONFIGURATION_PAGE_SIZE, pageToken) {
        const request = {
          pageSize: maxResults
        };
        if (typeof pageToken !== "undefined") {
          request.pageToken = pageToken;
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), LIST_INBOUND_SAML_CONFIGS, request).then((response) => {
          if (!response.inboundSamlConfigs) {
            response.inboundSamlConfigs = [];
            delete response.nextPageToken;
          }
          return response;
        });
      }
      /**
       * Deletes a SAML configuration identified by a providerId.
       *
       * @param providerId - The identifier of the SAML configuration to delete.
       * @returns A promise that resolves when the SAML provider is deleted.
       */
      deleteInboundSamlConfig(providerId) {
        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), DELETE_INBOUND_SAML_CONFIG, {}, { providerId }).then(() => {
        });
      }
      /**
       * Creates a new SAML provider configuration with the properties provided.
       *
       * @param options - The properties to set on the new SAML provider configuration to be created.
       * @returns A promise that resolves with the newly created SAML
       *     configuration.
       */
      createInboundSamlConfig(options) {
        let request;
        try {
          request = auth_config_1.SAMLConfig.buildServerRequest(options) || {};
        } catch (e) {
          return Promise.reject(e);
        }
        const providerId = options.providerId;
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), CREATE_INBOUND_SAML_CONFIG, request, { providerId }).then((response) => {
          if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new SAML provider configuration");
          }
          return response;
        });
      }
      /**
       * Updates an existing SAML provider configuration with the properties provided.
       *
       * @param providerId - The provider identifier of the SAML configuration to update.
       * @param options - The properties to update on the existing configuration.
       * @returns A promise that resolves with the modified provider
       *     configuration.
       */
      updateInboundSamlConfig(providerId, options) {
        if (!auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
        }
        let request;
        try {
          request = auth_config_1.SAMLConfig.buildServerRequest(options, true) || {};
        } catch (e) {
          return Promise.reject(e);
        }
        const updateMask = utils.generateUpdateMask(request);
        return this.invokeRequestHandler(this.getProjectConfigUrlBuilder(), UPDATE_INBOUND_SAML_CONFIG, request, { providerId, updateMask: updateMask.join(",") }).then((response) => {
          if (!auth_config_1.SAMLConfig.getProviderIdFromResourceName(response.name)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update SAML provider configuration");
          }
          return response;
        });
      }
      /**
       * Invokes the request handler based on the API settings object passed.
       *
       * @param urlBuilder - The URL builder for Auth endpoints.
       * @param apiSettings - The API endpoint settings to apply to request and response.
       * @param requestData - The request data.
       * @param additionalResourceParams - Additional resource related params if needed.
       * @returns A promise that resolves with the response.
       */
      invokeRequestHandler(urlBuilder, apiSettings, requestData, additionalResourceParams) {
        return urlBuilder.getUrl(apiSettings.getEndpoint(), additionalResourceParams).then((url) => {
          if (requestData) {
            const requestValidator = apiSettings.getRequestValidator();
            requestValidator(requestData);
          }
          const req = {
            method: apiSettings.getHttpMethod(),
            url,
            headers: FIREBASE_AUTH_HEADER,
            data: requestData,
            timeout: FIREBASE_AUTH_TIMEOUT
          };
          return this.httpClient.send(req);
        }).then((response) => {
          const responseValidator = apiSettings.getResponseValidator();
          responseValidator(response.data);
          return response.data;
        }).catch((err) => {
          if (err instanceof api_request_1.HttpError) {
            const error = err.response.data;
            const errorCode = _AbstractAuthRequestHandler.getErrorCode(error);
            if (!errorCode) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "Error returned from server: " + error + ". Additionally, an internal error occurred while attempting to extract the errorcode from the error.");
            }
            throw error_1.FirebaseAuthError.fromServerError(
              errorCode,
              /* message */
              void 0,
              error
            );
          }
          throw err;
        });
      }
      /**
       * @returns The current Auth user management resource URL builder.
       */
      getAuthUrlBuilder() {
        if (!this.authUrlBuilder) {
          this.authUrlBuilder = this.newAuthUrlBuilder();
        }
        return this.authUrlBuilder;
      }
      /**
       * @returns The current project config resource URL builder.
       */
      getProjectConfigUrlBuilder() {
        if (!this.projectConfigUrlBuilder) {
          this.projectConfigUrlBuilder = this.newProjectConfigUrlBuilder();
        }
        return this.projectConfigUrlBuilder;
      }
    };
    exports.AbstractAuthRequestHandler = AbstractAuthRequestHandler;
    var GET_PROJECT_CONFIG = new api_request_1.ApiSettings("/config", "GET").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get project config");
      }
    });
    var UPDATE_PROJECT_CONFIG = new api_request_1.ApiSettings("/config?updateMask={updateMask}", "PATCH").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update project config");
      }
    });
    var GET_TENANT = new api_request_1.ApiSettings("/tenants/{tenantId}", "GET").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to get tenant");
      }
    });
    var DELETE_TENANT = new api_request_1.ApiSettings("/tenants/{tenantId}", "DELETE");
    var UPDATE_TENANT = new api_request_1.ApiSettings("/tenants/{tenantId}?updateMask={updateMask}", "PATCH").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to update tenant");
      }
    });
    var LIST_TENANTS = new api_request_1.ApiSettings("/tenants", "GET").setRequestValidator((request) => {
      if (typeof request.pageToken !== "undefined" && !validator.isNonEmptyString(request.pageToken)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PAGE_TOKEN);
      }
      if (!validator.isNumber(request.pageSize) || request.pageSize <= 0 || request.pageSize > MAX_LIST_TENANT_PAGE_SIZE) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Required "maxResults" must be a positive non-zero number that does not exceed the allowed ${MAX_LIST_TENANT_PAGE_SIZE}.`);
      }
    });
    var CREATE_TENANT = new api_request_1.ApiSettings("/tenants", "POST").setResponseValidator((response) => {
      if (!validator.isNonEmptyString(response.name) || !tenant_1.Tenant.getTenantIdFromResourceName(response.name)) {
        throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Unable to create new tenant");
      }
    });
    var AuthRequestHandler = class extends AbstractAuthRequestHandler {
      /**
       * The FirebaseAuthRequestHandler constructor used to initialize an instance using a FirebaseApp.
       *
       * @param app - The app used to fetch access tokens to sign API requests.
       * @constructor.
       */
      constructor(app) {
        super(app);
        this.authResourceUrlBuilder = new AuthResourceUrlBuilder(app, "v2");
      }
      /**
       * @returns A new Auth user management resource URL builder instance.
       */
      newAuthUrlBuilder() {
        return new AuthResourceUrlBuilder(this.app, "v1");
      }
      /**
       * @returns A new project config resource URL builder instance.
       */
      newProjectConfigUrlBuilder() {
        return new AuthResourceUrlBuilder(this.app, "v2");
      }
      /**
       * Get the current project's config
       * @returns A promise that resolves with the project config information.
       */
      getProjectConfig() {
        return this.invokeRequestHandler(this.authResourceUrlBuilder, GET_PROJECT_CONFIG, {}, {}).then((response) => {
          return response;
        });
      }
      /**
       * Update the current project's config.
       * @returns A promise that resolves with the project config information.
       */
      updateProjectConfig(options) {
        try {
          const request = project_config_1.ProjectConfig.buildServerRequest(options);
          const updateMask = utils.generateUpdateMask(request);
          return this.invokeRequestHandler(this.authResourceUrlBuilder, UPDATE_PROJECT_CONFIG, request, { updateMask: updateMask.join(",") }).then((response) => {
            return response;
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }
      /**
       * Looks up a tenant by tenant ID.
       *
       * @param tenantId - The tenant identifier of the tenant to lookup.
       * @returns A promise that resolves with the tenant information.
       */
      getTenant(tenantId) {
        if (!validator.isNonEmptyString(tenantId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));
        }
        return this.invokeRequestHandler(this.authResourceUrlBuilder, GET_TENANT, {}, { tenantId }).then((response) => {
          return response;
        });
      }
      /**
       * Exports the tenants (single batch only) with a size of maxResults and starting from
       * the offset as specified by pageToken.
       *
       * @param maxResults - The page size, 1000 if undefined. This is also the maximum
       *     allowed limit.
       * @param pageToken - The next page token. If not specified, returns tenants starting
       *     without any offset. Tenants are returned in the order they were created from oldest to
       *     newest, relative to the page token offset.
       * @returns A promise that resolves with the current batch of downloaded
       *     tenants and the next page token if available. For the last page, an empty list of tenants
       *     and no page token are returned.
       */
      listTenants(maxResults = MAX_LIST_TENANT_PAGE_SIZE, pageToken) {
        const request = {
          pageSize: maxResults,
          pageToken
        };
        if (typeof request.pageToken === "undefined") {
          delete request.pageToken;
        }
        return this.invokeRequestHandler(this.authResourceUrlBuilder, LIST_TENANTS, request).then((response) => {
          if (!response.tenants) {
            response.tenants = [];
            delete response.nextPageToken;
          }
          return response;
        });
      }
      /**
       * Deletes a tenant identified by a tenantId.
       *
       * @param tenantId - The identifier of the tenant to delete.
       * @returns A promise that resolves when the tenant is deleted.
       */
      deleteTenant(tenantId) {
        if (!validator.isNonEmptyString(tenantId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));
        }
        return this.invokeRequestHandler(this.authResourceUrlBuilder, DELETE_TENANT, void 0, { tenantId }).then(() => {
        });
      }
      /**
       * Creates a new tenant with the properties provided.
       *
       * @param tenantOptions - The properties to set on the new tenant to be created.
       * @returns A promise that resolves with the newly created tenant object.
       */
      createTenant(tenantOptions) {
        try {
          const request = tenant_1.Tenant.buildServerRequest(tenantOptions, true);
          return this.invokeRequestHandler(this.authResourceUrlBuilder, CREATE_TENANT, request).then((response) => {
            return response;
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }
      /**
       * Updates an existing tenant with the properties provided.
       *
       * @param tenantId - The tenant identifier of the tenant to update.
       * @param tenantOptions - The properties to update on the existing tenant.
       * @returns A promise that resolves with the modified tenant object.
       */
      updateTenant(tenantId, tenantOptions) {
        if (!validator.isNonEmptyString(tenantId)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID));
        }
        try {
          const request = tenant_1.Tenant.buildServerRequest(tenantOptions, false);
          const updateMask = utils.generateUpdateMask(request, ["testPhoneNumbers"]);
          return this.invokeRequestHandler(this.authResourceUrlBuilder, UPDATE_TENANT, request, { tenantId, updateMask: updateMask.join(",") }).then((response) => {
            return response;
          });
        } catch (e) {
          return Promise.reject(e);
        }
      }
    };
    exports.AuthRequestHandler = AuthRequestHandler;
    var TenantAwareAuthRequestHandler = class extends AbstractAuthRequestHandler {
      /**
       * The FirebaseTenantRequestHandler constructor used to initialize an instance using a
       * FirebaseApp and a tenant ID.
       *
       * @param app - The app used to fetch access tokens to sign API requests.
       * @param tenantId - The request handler's tenant ID.
       * @constructor
       */
      constructor(app, tenantId) {
        super(app);
        this.tenantId = tenantId;
      }
      /**
       * @returns A new Auth user management resource URL builder instance.
       */
      newAuthUrlBuilder() {
        return new TenantAwareAuthResourceUrlBuilder(this.app, "v1", this.tenantId);
      }
      /**
       * @returns A new project config resource URL builder instance.
       */
      newProjectConfigUrlBuilder() {
        return new TenantAwareAuthResourceUrlBuilder(this.app, "v2", this.tenantId);
      }
      /**
       * Imports the list of users provided to Firebase Auth. This is useful when
       * migrating from an external authentication system without having to use the Firebase CLI SDK.
       * At most, 1000 users are allowed to be imported one at a time.
       * When importing a list of password users, UserImportOptions are required to be specified.
       *
       * Overrides the superclass methods by adding an additional check to match tenant IDs of
       * imported user records if present.
       *
       * @param users - The list of user records to import to Firebase Auth.
       * @param options - The user import options, required when the users provided
       *     include password credentials.
       * @returns A promise that resolves when the operation completes
       *     with the result of the import. This includes the number of successful imports, the number
       *     of failed uploads and their corresponding errors.
       */
      uploadAccount(users, options) {
        users.forEach((user, index) => {
          if (validator.isNonEmptyString(user.tenantId) && user.tenantId !== this.tenantId) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID, `UserRecord of index "${index}" has mismatching tenant ID "${user.tenantId}"`);
          }
        });
        return super.uploadAccount(users, options);
      }
    };
    exports.TenantAwareAuthRequestHandler = TenantAwareAuthRequestHandler;
    function emulatorHost() {
      return process.env.FIREBASE_AUTH_EMULATOR_HOST;
    }
    function useEmulator() {
      return !!emulatorHost();
    }
    exports.useEmulator = useEmulator;
  }
});

// node_modules/firebase-admin/lib/utils/crypto-signer.js
var require_crypto_signer = __commonJS({
  "node_modules/firebase-admin/lib/utils/crypto-signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CryptoSignerErrorCode = exports.CryptoSignerError = exports.cryptoSignerFromApp = exports.IAMSigner = exports.ServiceAccountSigner = void 0;
    var credential_internal_1 = require_credential_internal();
    var api_request_1 = require_api_request();
    var validator = require_validator();
    var ALGORITHM_RS256 = "RS256";
    var ServiceAccountSigner = class {
      /**
       * Creates a new CryptoSigner instance from the given service account credential.
       *
       * @param credential - A service account credential.
       */
      constructor(credential) {
        this.credential = credential;
        this.algorithm = ALGORITHM_RS256;
        if (!credential) {
          throw new CryptoSignerError({
            code: CryptoSignerErrorCode.INVALID_CREDENTIAL,
            message: "INTERNAL ASSERT: Must provide a service account credential to initialize ServiceAccountSigner."
          });
        }
      }
      /**
       * @inheritDoc
       */
      sign(buffer) {
        const crypto2 = require_crypto();
        const sign2 = crypto2.createSign("RSA-SHA256");
        sign2.update(buffer);
        return Promise.resolve(sign2.sign(this.credential.privateKey));
      }
      /**
       * @inheritDoc
       */
      getAccountId() {
        return Promise.resolve(this.credential.clientEmail);
      }
    };
    exports.ServiceAccountSigner = ServiceAccountSigner;
    var IAMSigner = class {
      constructor(httpClient, serviceAccountId) {
        this.algorithm = ALGORITHM_RS256;
        if (!httpClient) {
          throw new CryptoSignerError({
            code: CryptoSignerErrorCode.INVALID_ARGUMENT,
            message: "INTERNAL ASSERT: Must provide a HTTP client to initialize IAMSigner."
          });
        }
        if (typeof serviceAccountId !== "undefined" && !validator.isNonEmptyString(serviceAccountId)) {
          throw new CryptoSignerError({
            code: CryptoSignerErrorCode.INVALID_ARGUMENT,
            message: "INTERNAL ASSERT: Service account ID must be undefined or a non-empty string."
          });
        }
        this.httpClient = httpClient;
        this.serviceAccountId = serviceAccountId;
      }
      /**
       * @inheritDoc
       */
      sign(buffer) {
        return this.getAccountId().then((serviceAccount) => {
          const request = {
            method: "POST",
            url: `https://iamcredentials.googleapis.com/v1/projects/-/serviceAccounts/${serviceAccount}:signBlob`,
            data: { payload: buffer.toString("base64") }
          };
          return this.httpClient.send(request);
        }).then((response) => {
          return Buffer.from(response.data.signedBlob, "base64");
        }).catch((err) => {
          if (err instanceof api_request_1.HttpError) {
            throw new CryptoSignerError({
              code: CryptoSignerErrorCode.SERVER_ERROR,
              message: err.message,
              cause: err
            });
          }
          throw err;
        });
      }
      /**
       * @inheritDoc
       */
      getAccountId() {
        if (validator.isNonEmptyString(this.serviceAccountId)) {
          return Promise.resolve(this.serviceAccountId);
        }
        const request = {
          method: "GET",
          url: "http://metadata/computeMetadata/v1/instance/service-accounts/default/email",
          headers: {
            "Metadata-Flavor": "Google"
          }
        };
        const client = new api_request_1.HttpClient();
        return client.send(request).then((response) => {
          if (!response.text) {
            throw new CryptoSignerError({
              code: CryptoSignerErrorCode.INTERNAL_ERROR,
              message: "HTTP Response missing payload"
            });
          }
          this.serviceAccountId = response.text;
          return response.text;
        }).catch((err) => {
          throw new CryptoSignerError({
            code: CryptoSignerErrorCode.INVALID_CREDENTIAL,
            message: `Failed to determine service account. Make sure to initialize the SDK with a service account credential. Alternatively specify a service account with iam.serviceAccounts.signBlob permission. Original error: ${err}`
          });
        });
      }
    };
    exports.IAMSigner = IAMSigner;
    function cryptoSignerFromApp(app) {
      const credential = app.options.credential;
      if (credential instanceof credential_internal_1.ServiceAccountCredential) {
        return new ServiceAccountSigner(credential);
      }
      return new IAMSigner(new api_request_1.AuthorizedHttpClient(app), app.options.serviceAccountId);
    }
    exports.cryptoSignerFromApp = cryptoSignerFromApp;
    var CryptoSignerError = class _CryptoSignerError extends Error {
      constructor(errorInfo) {
        super(errorInfo.message);
        this.errorInfo = errorInfo;
        this.__proto__ = _CryptoSignerError.prototype;
      }
      /** @returns The error code. */
      get code() {
        return this.errorInfo.code;
      }
      /** @returns The error message. */
      get message() {
        return this.errorInfo.message;
      }
      /** @returns The error data. */
      get cause() {
        return this.errorInfo.cause;
      }
    };
    exports.CryptoSignerError = CryptoSignerError;
    var CryptoSignerErrorCode = class {
    };
    exports.CryptoSignerErrorCode = CryptoSignerErrorCode;
    CryptoSignerErrorCode.INVALID_ARGUMENT = "invalid-argument";
    CryptoSignerErrorCode.INTERNAL_ERROR = "internal-error";
    CryptoSignerErrorCode.INVALID_CREDENTIAL = "invalid-credential";
    CryptoSignerErrorCode.SERVER_ERROR = "server-error";
  }
});

// node_modules/firebase-admin/lib/auth/token-generator.js
var require_token_generator = __commonJS({
  "node_modules/firebase-admin/lib/auth/token-generator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.handleCryptoSignerError = exports.FirebaseTokenGenerator = exports.EmulatedSigner = exports.BLACKLISTED_CLAIMS = void 0;
    var error_1 = require_error();
    var crypto_signer_1 = require_crypto_signer();
    var validator = require_validator();
    var utils_1 = require_utils();
    var ALGORITHM_NONE = "none";
    var ONE_HOUR_IN_SECONDS = 60 * 60;
    exports.BLACKLISTED_CLAIMS = [
      "acr",
      "amr",
      "at_hash",
      "aud",
      "auth_time",
      "azp",
      "cnf",
      "c_hash",
      "exp",
      "iat",
      "iss",
      "jti",
      "nbf",
      "nonce"
    ];
    var FIREBASE_AUDIENCE = "https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit";
    var EmulatedSigner = class {
      constructor() {
        this.algorithm = ALGORITHM_NONE;
      }
      /**
       * @inheritDoc
       */
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      sign(buffer) {
        return Promise.resolve(Buffer.from(""));
      }
      /**
       * @inheritDoc
       */
      getAccountId() {
        return Promise.resolve("firebase-auth-emulator@example.com");
      }
    };
    exports.EmulatedSigner = EmulatedSigner;
    var FirebaseTokenGenerator = class {
      /**
       * @param tenantId - The tenant ID to use for the generated Firebase Auth
       *     Custom token. If absent, then no tenant ID claim will be set in the
       *     resulting JWT.
       */
      constructor(signer, tenantId) {
        this.tenantId = tenantId;
        if (!validator.isNonNullObject(signer)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, "INTERNAL ASSERT: Must provide a CryptoSigner to use FirebaseTokenGenerator.");
        }
        if (typeof this.tenantId !== "undefined" && !validator.isNonEmptyString(this.tenantId)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`tenantId` argument must be a non-empty string.");
        }
        this.signer = signer;
      }
      /**
       * Creates a new Firebase Auth Custom token.
       *
       * @param uid - The user ID to use for the generated Firebase Auth Custom token.
       * @param developerClaims - Optional developer claims to include in the generated Firebase
       *     Auth Custom token.
       * @returns A Promise fulfilled with a Firebase Auth Custom token signed with a
       *     service account key and containing the provided payload.
       */
      createCustomToken(uid, developerClaims) {
        let errorMessage;
        if (!validator.isNonEmptyString(uid)) {
          errorMessage = "`uid` argument must be a non-empty string uid.";
        } else if (uid.length > 128) {
          errorMessage = "`uid` argument must a uid with less than or equal to 128 characters.";
        } else if (!this.isDeveloperClaimsValid_(developerClaims)) {
          errorMessage = "`developerClaims` argument must be a valid, non-null object containing the developer claims.";
        }
        if (errorMessage) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
        }
        const claims = {};
        if (typeof developerClaims !== "undefined") {
          for (const key in developerClaims) {
            if (Object.prototype.hasOwnProperty.call(developerClaims, key)) {
              if (exports.BLACKLISTED_CLAIMS.indexOf(key) !== -1) {
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `Developer claim "${key}" is reserved and cannot be specified.`);
              }
              claims[key] = developerClaims[key];
            }
          }
        }
        return this.signer.getAccountId().then((account) => {
          const header = {
            alg: this.signer.algorithm,
            typ: "JWT"
          };
          const iat = Math.floor(Date.now() / 1e3);
          const body = {
            aud: FIREBASE_AUDIENCE,
            iat,
            exp: iat + ONE_HOUR_IN_SECONDS,
            iss: account,
            sub: account,
            uid
          };
          if (this.tenantId) {
            body.tenant_id = this.tenantId;
          }
          if (Object.keys(claims).length > 0) {
            body.claims = claims;
          }
          const token = `${this.encodeSegment(header)}.${this.encodeSegment(body)}`;
          const signPromise = this.signer.sign(Buffer.from(token));
          return Promise.all([token, signPromise]);
        }).then(([token, signature]) => {
          return `${token}.${this.encodeSegment(signature)}`;
        }).catch((err) => {
          throw handleCryptoSignerError(err);
        });
      }
      encodeSegment(segment) {
        const buffer = segment instanceof Buffer ? segment : Buffer.from(JSON.stringify(segment));
        return (0, utils_1.toWebSafeBase64)(buffer).replace(/=+$/, "");
      }
      /**
       * Returns whether or not the provided developer claims are valid.
       *
       * @param developerClaims - Optional developer claims to validate.
       * @returns True if the provided claims are valid; otherwise, false.
       */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      isDeveloperClaimsValid_(developerClaims) {
        if (typeof developerClaims === "undefined") {
          return true;
        }
        return validator.isNonNullObject(developerClaims);
      }
    };
    exports.FirebaseTokenGenerator = FirebaseTokenGenerator;
    function handleCryptoSignerError(err) {
      if (!(err instanceof crypto_signer_1.CryptoSignerError)) {
        return err;
      }
      if (err.code === crypto_signer_1.CryptoSignerErrorCode.SERVER_ERROR && validator.isNonNullObject(err.cause)) {
        const httpError = err.cause;
        const errorResponse = httpError.response.data;
        if (validator.isNonNullObject(errorResponse) && errorResponse.error) {
          const errorCode = errorResponse.error.status;
          const description = "Please refer to https://firebase.google.com/docs/auth/admin/create-custom-tokens for more details on how to use and troubleshoot this feature.";
          const errorMsg = `${errorResponse.error.message}; ${description}`;
          return error_1.FirebaseAuthError.fromServerError(errorCode, errorMsg, errorResponse);
        }
        return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "Error returned from server: " + errorResponse + ". Additionally, an internal error occurred while attempting to extract the errorcode from the error.");
      }
      return new error_1.FirebaseAuthError(mapToAuthClientErrorCode(err.code), err.message);
    }
    exports.handleCryptoSignerError = handleCryptoSignerError;
    function mapToAuthClientErrorCode(code) {
      switch (code) {
        case crypto_signer_1.CryptoSignerErrorCode.INVALID_CREDENTIAL:
          return error_1.AuthClientErrorCode.INVALID_CREDENTIAL;
        case crypto_signer_1.CryptoSignerErrorCode.INVALID_ARGUMENT:
          return error_1.AuthClientErrorCode.INVALID_ARGUMENT;
        default:
          return error_1.AuthClientErrorCode.INTERNAL_ERROR;
      }
    }
  }
});

// node_modules/debug/src/common.js
var require_common = __commonJS({
  "node_modules/debug/src/common.js"(exports, module) {
    function setup(env) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env).forEach((key) => {
        createDebug[key] = env[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug(...args) {
          if (!debug.enabled) {
            return;
          }
          const self2 = debug;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        debug.namespace = namespace;
        debug.useColors = createDebug.useColors();
        debug.color = createDebug.selectColor(namespace);
        debug.extend = extend;
        debug.destroy = createDebug.destroy;
        Object.defineProperty(debug, "enabled", {
          enumerable: true,
          configurable: false,
          get: () => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          },
          set: (v) => {
            enableOverride = v;
          }
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug);
        }
        return debug;
      }
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      function coerce(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    module.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/debug/src/browser.js"(exports, module) {
    exports.formatArgs = formatArgs;
    exports.save = save;
    exports.load = load;
    exports.useColors = useColors;
    exports.storage = localstorage();
    exports.destroy = (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    exports.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports.storage.setItem("debug", namespaces);
        } else {
          exports.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    function load() {
      let r;
      try {
        r = exports.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    module.exports = require_common()(exports);
    var { formatters } = module.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/webcrypto.js
var webcrypto_default, isCryptoKey;
var init_webcrypto = __esm({
  "node_modules/jose/dist/browser/runtime/webcrypto.js"() {
    webcrypto_default = crypto;
    isCryptoKey = (key) => key instanceof CryptoKey;
  }
});

// node_modules/jose/dist/browser/runtime/digest.js
var digest, digest_default;
var init_digest = __esm({
  "node_modules/jose/dist/browser/runtime/digest.js"() {
    init_webcrypto();
    digest = async (algorithm, data) => {
      const subtleDigest = `SHA-${algorithm.slice(-3)}`;
      return new Uint8Array(await webcrypto_default.subtle.digest(subtleDigest, data));
    };
    digest_default = digest;
  }
});

// node_modules/jose/dist/browser/lib/buffer_utils.js
function concat(...buffers) {
  const size = buffers.reduce((acc, { length }) => acc + length, 0);
  const buf = new Uint8Array(size);
  let i = 0;
  buffers.forEach((buffer) => {
    buf.set(buffer, i);
    i += buffer.length;
  });
  return buf;
}
function p2s(alg, p2sInput) {
  return concat(encoder.encode(alg), new Uint8Array([0]), p2sInput);
}
function writeUInt32BE(buf, value, offset) {
  if (value < 0 || value >= MAX_INT32) {
    throw new RangeError(`value must be >= 0 and <= ${MAX_INT32 - 1}. Received ${value}`);
  }
  buf.set([value >>> 24, value >>> 16, value >>> 8, value & 255], offset);
}
function uint64be(value) {
  const high = Math.floor(value / MAX_INT32);
  const low = value % MAX_INT32;
  const buf = new Uint8Array(8);
  writeUInt32BE(buf, high, 0);
  writeUInt32BE(buf, low, 4);
  return buf;
}
function uint32be(value) {
  const buf = new Uint8Array(4);
  writeUInt32BE(buf, value);
  return buf;
}
function lengthAndInput(input) {
  return concat(uint32be(input.length), input);
}
async function concatKdf(secret, bits, value) {
  const iterations = Math.ceil((bits >> 3) / 32);
  const res = new Uint8Array(iterations * 32);
  for (let iter = 0; iter < iterations; iter++) {
    const buf = new Uint8Array(4 + secret.length + value.length);
    buf.set(uint32be(iter + 1));
    buf.set(secret, 4);
    buf.set(value, 4 + secret.length);
    res.set(await digest_default("sha256", buf), iter * 32);
  }
  return res.slice(0, bits >> 3);
}
var encoder, decoder, MAX_INT32;
var init_buffer_utils = __esm({
  "node_modules/jose/dist/browser/lib/buffer_utils.js"() {
    init_digest();
    encoder = new TextEncoder();
    decoder = new TextDecoder();
    MAX_INT32 = 2 ** 32;
  }
});

// node_modules/jose/dist/browser/runtime/base64url.js
var encodeBase64, encode, decodeBase64, decode;
var init_base64url = __esm({
  "node_modules/jose/dist/browser/runtime/base64url.js"() {
    init_buffer_utils();
    encodeBase64 = (input) => {
      let unencoded = input;
      if (typeof unencoded === "string") {
        unencoded = encoder.encode(unencoded);
      }
      const CHUNK_SIZE = 32768;
      const arr = [];
      for (let i = 0; i < unencoded.length; i += CHUNK_SIZE) {
        arr.push(String.fromCharCode.apply(null, unencoded.subarray(i, i + CHUNK_SIZE)));
      }
      return btoa(arr.join(""));
    };
    encode = (input) => {
      return encodeBase64(input).replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    };
    decodeBase64 = (encoded) => {
      const binary = atob(encoded);
      const bytes = new Uint8Array(binary.length);
      for (let i = 0; i < binary.length; i++) {
        bytes[i] = binary.charCodeAt(i);
      }
      return bytes;
    };
    decode = (input) => {
      let encoded = input;
      if (encoded instanceof Uint8Array) {
        encoded = decoder.decode(encoded);
      }
      encoded = encoded.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
      try {
        return decodeBase64(encoded);
      } catch (_a) {
        throw new TypeError("The input to be decoded is not correctly encoded.");
      }
    };
  }
});

// node_modules/jose/dist/browser/util/errors.js
var errors_exports = {};
__export(errors_exports, {
  JOSEAlgNotAllowed: () => JOSEAlgNotAllowed,
  JOSEError: () => JOSEError,
  JOSENotSupported: () => JOSENotSupported,
  JWEDecryptionFailed: () => JWEDecryptionFailed,
  JWEInvalid: () => JWEInvalid,
  JWKInvalid: () => JWKInvalid,
  JWKSInvalid: () => JWKSInvalid,
  JWKSMultipleMatchingKeys: () => JWKSMultipleMatchingKeys,
  JWKSNoMatchingKey: () => JWKSNoMatchingKey,
  JWKSTimeout: () => JWKSTimeout,
  JWSInvalid: () => JWSInvalid,
  JWSSignatureVerificationFailed: () => JWSSignatureVerificationFailed,
  JWTClaimValidationFailed: () => JWTClaimValidationFailed,
  JWTExpired: () => JWTExpired,
  JWTInvalid: () => JWTInvalid
});
var JOSEError, JWTClaimValidationFailed, JWTExpired, JOSEAlgNotAllowed, JOSENotSupported, JWEDecryptionFailed, JWEInvalid, JWSInvalid, JWTInvalid, JWKInvalid, JWKSInvalid, JWKSNoMatchingKey, JWKSMultipleMatchingKeys, JWKSTimeout, JWSSignatureVerificationFailed;
var init_errors = __esm({
  "node_modules/jose/dist/browser/util/errors.js"() {
    JOSEError = class extends Error {
      static get code() {
        return "ERR_JOSE_GENERIC";
      }
      constructor(message2) {
        var _a;
        super(message2);
        this.code = "ERR_JOSE_GENERIC";
        this.name = this.constructor.name;
        (_a = Error.captureStackTrace) === null || _a === void 0 ? void 0 : _a.call(Error, this, this.constructor);
      }
    };
    JWTClaimValidationFailed = class extends JOSEError {
      static get code() {
        return "ERR_JWT_CLAIM_VALIDATION_FAILED";
      }
      constructor(message2, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JWTExpired = class extends JOSEError {
      static get code() {
        return "ERR_JWT_EXPIRED";
      }
      constructor(message2, claim = "unspecified", reason = "unspecified") {
        super(message2);
        this.code = "ERR_JWT_EXPIRED";
        this.claim = claim;
        this.reason = reason;
      }
    };
    JOSEAlgNotAllowed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
      }
      static get code() {
        return "ERR_JOSE_ALG_NOT_ALLOWED";
      }
    };
    JOSENotSupported = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JOSE_NOT_SUPPORTED";
      }
      static get code() {
        return "ERR_JOSE_NOT_SUPPORTED";
      }
    };
    JWEDecryptionFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_DECRYPTION_FAILED";
        this.message = "decryption operation failed";
      }
      static get code() {
        return "ERR_JWE_DECRYPTION_FAILED";
      }
    };
    JWEInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWE_INVALID";
      }
      static get code() {
        return "ERR_JWE_INVALID";
      }
    };
    JWSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_INVALID";
      }
      static get code() {
        return "ERR_JWS_INVALID";
      }
    };
    JWTInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWT_INVALID";
      }
      static get code() {
        return "ERR_JWT_INVALID";
      }
    };
    JWKInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWK_INVALID";
      }
      static get code() {
        return "ERR_JWK_INVALID";
      }
    };
    JWKSInvalid = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_INVALID";
      }
      static get code() {
        return "ERR_JWKS_INVALID";
      }
    };
    JWKSNoMatchingKey = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_NO_MATCHING_KEY";
        this.message = "no applicable key found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_NO_MATCHING_KEY";
      }
    };
    JWKSMultipleMatchingKeys = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
        this.message = "multiple matching keys found in the JSON Web Key Set";
      }
      static get code() {
        return "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
      }
    };
    JWKSTimeout = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWKS_TIMEOUT";
        this.message = "request timed out";
      }
      static get code() {
        return "ERR_JWKS_TIMEOUT";
      }
    };
    JWSSignatureVerificationFailed = class extends JOSEError {
      constructor() {
        super(...arguments);
        this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
        this.message = "signature verification failed";
      }
      static get code() {
        return "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/random.js
var random_default;
var init_random = __esm({
  "node_modules/jose/dist/browser/runtime/random.js"() {
    init_webcrypto();
    random_default = webcrypto_default.getRandomValues.bind(webcrypto_default);
  }
});

// node_modules/jose/dist/browser/lib/iv.js
function bitLength(alg) {
  switch (alg) {
    case "A128GCM":
    case "A128GCMKW":
    case "A192GCM":
    case "A192GCMKW":
    case "A256GCM":
    case "A256GCMKW":
      return 96;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      return 128;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var iv_default;
var init_iv = __esm({
  "node_modules/jose/dist/browser/lib/iv.js"() {
    init_errors();
    init_random();
    iv_default = (alg) => random_default(new Uint8Array(bitLength(alg) >> 3));
  }
});

// node_modules/jose/dist/browser/lib/check_iv_length.js
var checkIvLength, check_iv_length_default;
var init_check_iv_length = __esm({
  "node_modules/jose/dist/browser/lib/check_iv_length.js"() {
    init_errors();
    init_iv();
    checkIvLength = (enc, iv) => {
      if (iv.length << 3 !== bitLength(enc)) {
        throw new JWEInvalid("Invalid Initialization Vector length");
      }
    };
    check_iv_length_default = checkIvLength;
  }
});

// node_modules/jose/dist/browser/runtime/check_cek_length.js
var checkCekLength, check_cek_length_default;
var init_check_cek_length = __esm({
  "node_modules/jose/dist/browser/runtime/check_cek_length.js"() {
    init_errors();
    checkCekLength = (cek, expected) => {
      const actual = cek.byteLength << 3;
      if (actual !== expected) {
        throw new JWEInvalid(`Invalid Content Encryption Key length. Expected ${expected} bits, got ${actual} bits`);
      }
    };
    check_cek_length_default = checkCekLength;
  }
});

// node_modules/jose/dist/browser/runtime/timing_safe_equal.js
var timingSafeEqual, timing_safe_equal_default;
var init_timing_safe_equal = __esm({
  "node_modules/jose/dist/browser/runtime/timing_safe_equal.js"() {
    timingSafeEqual = (a, b) => {
      if (!(a instanceof Uint8Array)) {
        throw new TypeError("First argument must be a buffer");
      }
      if (!(b instanceof Uint8Array)) {
        throw new TypeError("Second argument must be a buffer");
      }
      if (a.length !== b.length) {
        throw new TypeError("Input buffers must have the same length");
      }
      const len = a.length;
      let out = 0;
      let i = -1;
      while (++i < len) {
        out |= a[i] ^ b[i];
      }
      return out === 0;
    };
    timing_safe_equal_default = timingSafeEqual;
  }
});

// node_modules/jose/dist/browser/lib/crypto_key.js
function unusable(name, prop = "algorithm.name") {
  return new TypeError(`CryptoKey does not support this operation, its ${prop} must be ${name}`);
}
function isAlgorithm(algorithm, name) {
  return algorithm.name === name;
}
function getHashLength(hash) {
  return parseInt(hash.name.slice(4), 10);
}
function getNamedCurve(alg) {
  switch (alg) {
    case "ES256":
      return "P-256";
    case "ES384":
      return "P-384";
    case "ES512":
      return "P-521";
    default:
      throw new Error("unreachable");
  }
}
function checkUsage(key, usages) {
  if (usages.length && !usages.some((expected) => key.usages.includes(expected))) {
    let msg = "CryptoKey does not support this operation, its usages must include ";
    if (usages.length > 2) {
      const last = usages.pop();
      msg += `one of ${usages.join(", ")}, or ${last}.`;
    } else if (usages.length === 2) {
      msg += `one of ${usages[0]} or ${usages[1]}.`;
    } else {
      msg += `${usages[0]}.`;
    }
    throw new TypeError(msg);
  }
}
function checkSigCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512": {
      if (!isAlgorithm(key.algorithm, "HMAC"))
        throw unusable("HMAC");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "RS256":
    case "RS384":
    case "RS512": {
      if (!isAlgorithm(key.algorithm, "RSASSA-PKCS1-v1_5"))
        throw unusable("RSASSA-PKCS1-v1_5");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "PS256":
    case "PS384":
    case "PS512": {
      if (!isAlgorithm(key.algorithm, "RSA-PSS"))
        throw unusable("RSA-PSS");
      const expected = parseInt(alg.slice(2), 10);
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    case "EdDSA": {
      if (key.algorithm.name !== "Ed25519" && key.algorithm.name !== "Ed448") {
        throw unusable("Ed25519 or Ed448");
      }
      break;
    }
    case "ES256":
    case "ES384":
    case "ES512": {
      if (!isAlgorithm(key.algorithm, "ECDSA"))
        throw unusable("ECDSA");
      const expected = getNamedCurve(alg);
      const actual = key.algorithm.namedCurve;
      if (actual !== expected)
        throw unusable(expected, "algorithm.namedCurve");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
function checkEncCryptoKey(key, alg, ...usages) {
  switch (alg) {
    case "A128GCM":
    case "A192GCM":
    case "A256GCM": {
      if (!isAlgorithm(key.algorithm, "AES-GCM"))
        throw unusable("AES-GCM");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (!isAlgorithm(key.algorithm, "AES-KW"))
        throw unusable("AES-KW");
      const expected = parseInt(alg.slice(1, 4), 10);
      const actual = key.algorithm.length;
      if (actual !== expected)
        throw unusable(expected, "algorithm.length");
      break;
    }
    case "ECDH": {
      switch (key.algorithm.name) {
        case "ECDH":
        case "X25519":
        case "X448":
          break;
        default:
          throw unusable("ECDH, X25519, or X448");
      }
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW":
      if (!isAlgorithm(key.algorithm, "PBKDF2"))
        throw unusable("PBKDF2");
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (!isAlgorithm(key.algorithm, "RSA-OAEP"))
        throw unusable("RSA-OAEP");
      const expected = parseInt(alg.slice(9), 10) || 1;
      const actual = getHashLength(key.algorithm.hash);
      if (actual !== expected)
        throw unusable(`SHA-${expected}`, "algorithm.hash");
      break;
    }
    default:
      throw new TypeError("CryptoKey does not support this operation");
  }
  checkUsage(key, usages);
}
var init_crypto_key = __esm({
  "node_modules/jose/dist/browser/lib/crypto_key.js"() {
  }
});

// node_modules/jose/dist/browser/lib/invalid_key_input.js
function message(msg, actual, ...types2) {
  if (types2.length > 2) {
    const last = types2.pop();
    msg += `one of type ${types2.join(", ")}, or ${last}.`;
  } else if (types2.length === 2) {
    msg += `one of type ${types2[0]} or ${types2[1]}.`;
  } else {
    msg += `of type ${types2[0]}.`;
  }
  if (actual == null) {
    msg += ` Received ${actual}`;
  } else if (typeof actual === "function" && actual.name) {
    msg += ` Received function ${actual.name}`;
  } else if (typeof actual === "object" && actual != null) {
    if (actual.constructor && actual.constructor.name) {
      msg += ` Received an instance of ${actual.constructor.name}`;
    }
  }
  return msg;
}
function withAlg(alg, actual, ...types2) {
  return message(`Key for the ${alg} algorithm must be `, actual, ...types2);
}
var invalid_key_input_default;
var init_invalid_key_input = __esm({
  "node_modules/jose/dist/browser/lib/invalid_key_input.js"() {
    invalid_key_input_default = (actual, ...types2) => {
      return message("Key must be ", actual, ...types2);
    };
  }
});

// node_modules/jose/dist/browser/runtime/is_key_like.js
var is_key_like_default, types;
var init_is_key_like = __esm({
  "node_modules/jose/dist/browser/runtime/is_key_like.js"() {
    init_webcrypto();
    is_key_like_default = (key) => {
      return isCryptoKey(key);
    };
    types = ["CryptoKey"];
  }
});

// node_modules/jose/dist/browser/runtime/decrypt.js
async function cbcDecrypt(enc, cek, ciphertext, iv, tag, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["decrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const expectedTag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  let macCheckPassed;
  try {
    macCheckPassed = timing_safe_equal_default(tag, expectedTag);
  } catch (_a) {
  }
  if (!macCheckPassed) {
    throw new JWEDecryptionFailed();
  }
  let plaintext;
  try {
    plaintext = new Uint8Array(await webcrypto_default.subtle.decrypt({ iv, name: "AES-CBC" }, encKey, ciphertext));
  } catch (_b) {
  }
  if (!plaintext) {
    throw new JWEDecryptionFailed();
  }
  return plaintext;
}
async function gcmDecrypt(enc, cek, ciphertext, iv, tag, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["decrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "decrypt");
    encKey = cek;
  }
  try {
    return new Uint8Array(await webcrypto_default.subtle.decrypt({
      additionalData: aad,
      iv,
      name: "AES-GCM",
      tagLength: 128
    }, encKey, concat(ciphertext, tag)));
  } catch (_a) {
    throw new JWEDecryptionFailed();
  }
}
var decrypt, decrypt_default;
var init_decrypt = __esm({
  "node_modules/jose/dist/browser/runtime/decrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_timing_safe_equal();
    init_errors();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    decrypt = async (enc, cek, ciphertext, iv, tag, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcDecrypt(enc, cek, ciphertext, iv, tag, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmDecrypt(enc, cek, ciphertext, iv, tag, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    decrypt_default = decrypt;
  }
});

// node_modules/jose/dist/browser/runtime/zlib.js
var inflate, deflate;
var init_zlib = __esm({
  "node_modules/jose/dist/browser/runtime/zlib.js"() {
    init_errors();
    inflate = async () => {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `inflateRaw` decrypt option to provide Inflate Raw implementation.');
    };
    deflate = async () => {
      throw new JOSENotSupported('JWE "zip" (Compression Algorithm) Header Parameter is not supported by your javascript runtime. You need to use the `deflateRaw` encrypt option to provide Deflate Raw implementation.');
    };
  }
});

// node_modules/jose/dist/browser/lib/is_disjoint.js
var isDisjoint, is_disjoint_default;
var init_is_disjoint = __esm({
  "node_modules/jose/dist/browser/lib/is_disjoint.js"() {
    isDisjoint = (...headers) => {
      const sources = headers.filter(Boolean);
      if (sources.length === 0 || sources.length === 1) {
        return true;
      }
      let acc;
      for (const header of sources) {
        const parameters = Object.keys(header);
        if (!acc || acc.size === 0) {
          acc = new Set(parameters);
          continue;
        }
        for (const parameter of parameters) {
          if (acc.has(parameter)) {
            return false;
          }
          acc.add(parameter);
        }
      }
      return true;
    };
    is_disjoint_default = isDisjoint;
  }
});

// node_modules/jose/dist/browser/lib/is_object.js
function isObjectLike(value) {
  return typeof value === "object" && value !== null;
}
function isObject(input) {
  if (!isObjectLike(input) || Object.prototype.toString.call(input) !== "[object Object]") {
    return false;
  }
  if (Object.getPrototypeOf(input) === null) {
    return true;
  }
  let proto = input;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(input) === proto;
}
var init_is_object = __esm({
  "node_modules/jose/dist/browser/lib/is_object.js"() {
  }
});

// node_modules/jose/dist/browser/runtime/bogus.js
var bogusWebCrypto, bogus_default;
var init_bogus = __esm({
  "node_modules/jose/dist/browser/runtime/bogus.js"() {
    bogusWebCrypto = [
      { hash: "SHA-256", name: "HMAC" },
      true,
      ["sign"]
    ];
    bogus_default = bogusWebCrypto;
  }
});

// node_modules/jose/dist/browser/runtime/aeskw.js
function checkKeySize(key, alg) {
  if (key.algorithm.length !== parseInt(alg.slice(1, 4), 10)) {
    throw new TypeError(`Invalid key size for alg: ${alg}`);
  }
}
function getCryptoKey(key, alg, usage) {
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "AES-KW", true, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
var wrap, unwrap;
var init_aeskw = __esm({
  "node_modules/jose/dist/browser/runtime/aeskw.js"() {
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    wrap = async (alg, key, cek) => {
      const cryptoKey = await getCryptoKey(key, alg, "wrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, cryptoKey, "AES-KW"));
    };
    unwrap = async (alg, key, encryptedKey) => {
      const cryptoKey = await getCryptoKey(key, alg, "unwrapKey");
      checkKeySize(cryptoKey, alg);
      const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, cryptoKey, "AES-KW", ...bogus_default);
      return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
    };
  }
});

// node_modules/jose/dist/browser/runtime/ecdhes.js
async function deriveKey(publicKey, privateKey, algorithm, keyLength, apu = new Uint8Array(0), apv = new Uint8Array(0)) {
  if (!isCryptoKey(publicKey)) {
    throw new TypeError(invalid_key_input_default(publicKey, ...types));
  }
  checkEncCryptoKey(publicKey, "ECDH");
  if (!isCryptoKey(privateKey)) {
    throw new TypeError(invalid_key_input_default(privateKey, ...types));
  }
  checkEncCryptoKey(privateKey, "ECDH", "deriveBits");
  const value = concat(lengthAndInput(encoder.encode(algorithm)), lengthAndInput(apu), lengthAndInput(apv), uint32be(keyLength));
  let length;
  if (publicKey.algorithm.name === "X25519") {
    length = 256;
  } else if (publicKey.algorithm.name === "X448") {
    length = 448;
  } else {
    length = Math.ceil(parseInt(publicKey.algorithm.namedCurve.substr(-3), 10) / 8) << 3;
  }
  const sharedSecret = new Uint8Array(await webcrypto_default.subtle.deriveBits({
    name: publicKey.algorithm.name,
    public: publicKey
  }, privateKey, length));
  return concatKdf(sharedSecret, keyLength, value);
}
async function generateEpk(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return webcrypto_default.subtle.generateKey(key.algorithm, true, ["deriveBits"]);
}
function ecdhAllowed(key) {
  if (!isCryptoKey(key)) {
    throw new TypeError(invalid_key_input_default(key, ...types));
  }
  return ["P-256", "P-384", "P-521"].includes(key.algorithm.namedCurve) || key.algorithm.name === "X25519" || key.algorithm.name === "X448";
}
var init_ecdhes = __esm({
  "node_modules/jose/dist/browser/runtime/ecdhes.js"() {
    init_buffer_utils();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/lib/check_p2s.js
function checkP2s(p2s2) {
  if (!(p2s2 instanceof Uint8Array) || p2s2.length < 8) {
    throw new JWEInvalid("PBES2 Salt Input must be 8 or more octets");
  }
}
var init_check_p2s = __esm({
  "node_modules/jose/dist/browser/lib/check_p2s.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/pbes2kw.js
function getCryptoKey2(key, alg) {
  if (key instanceof Uint8Array) {
    return webcrypto_default.subtle.importKey("raw", key, "PBKDF2", false, ["deriveBits"]);
  }
  if (isCryptoKey(key)) {
    checkEncCryptoKey(key, alg, "deriveBits", "deriveKey");
    return key;
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
async function deriveKey2(p2s2, alg, p2c, key) {
  checkP2s(p2s2);
  const salt = p2s(alg, p2s2);
  const keylen = parseInt(alg.slice(13, 16), 10);
  const subtleAlg = {
    hash: `SHA-${alg.slice(8, 11)}`,
    iterations: p2c,
    name: "PBKDF2",
    salt
  };
  const wrapAlg = {
    length: keylen,
    name: "AES-KW"
  };
  const cryptoKey = await getCryptoKey2(key, alg);
  if (cryptoKey.usages.includes("deriveBits")) {
    return new Uint8Array(await webcrypto_default.subtle.deriveBits(subtleAlg, cryptoKey, keylen));
  }
  if (cryptoKey.usages.includes("deriveKey")) {
    return webcrypto_default.subtle.deriveKey(subtleAlg, cryptoKey, wrapAlg, false, ["wrapKey", "unwrapKey"]);
  }
  throw new TypeError('PBKDF2 key "usages" must include "deriveBits" or "deriveKey"');
}
var encrypt, decrypt2;
var init_pbes2kw = __esm({
  "node_modules/jose/dist/browser/runtime/pbes2kw.js"() {
    init_random();
    init_buffer_utils();
    init_base64url();
    init_aeskw();
    init_check_p2s();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
    encrypt = async (alg, key, cek, p2c = 2048, p2s2 = random_default(new Uint8Array(16))) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      const encryptedKey = await wrap(alg.slice(-6), derived, cek);
      return { encryptedKey, p2c, p2s: encode(p2s2) };
    };
    decrypt2 = async (alg, key, encryptedKey, p2c, p2s2) => {
      const derived = await deriveKey2(p2s2, alg, p2c, key);
      return unwrap(alg.slice(-6), derived, encryptedKey);
    };
  }
});

// node_modules/jose/dist/browser/runtime/subtle_rsaes.js
function subtleRsaEs(alg) {
  switch (alg) {
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      return "RSA-OAEP";
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_rsaes = __esm({
  "node_modules/jose/dist/browser/runtime/subtle_rsaes.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/check_key_length.js
var check_key_length_default;
var init_check_key_length = __esm({
  "node_modules/jose/dist/browser/runtime/check_key_length.js"() {
    check_key_length_default = (alg, key) => {
      if (alg.startsWith("RS") || alg.startsWith("PS")) {
        const { modulusLength } = key.algorithm;
        if (typeof modulusLength !== "number" || modulusLength < 2048) {
          throw new TypeError(`${alg} requires key modulusLength to be 2048 bits or larger`);
        }
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/rsaes.js
var encrypt2, decrypt3;
var init_rsaes = __esm({
  "node_modules/jose/dist/browser/runtime/rsaes.js"() {
    init_subtle_rsaes();
    init_bogus();
    init_webcrypto();
    init_crypto_key();
    init_check_key_length();
    init_invalid_key_input();
    init_is_key_like();
    encrypt2 = async (alg, key, cek) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      checkEncCryptoKey(key, alg, "encrypt", "wrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("encrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.encrypt(subtleRsaEs(alg), key, cek));
      }
      if (key.usages.includes("wrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.importKey("raw", cek, ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.wrapKey("raw", cryptoKeyCek, key, subtleRsaEs(alg)));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "encrypt" or "wrapKey" for this operation');
    };
    decrypt3 = async (alg, key, encryptedKey) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      checkEncCryptoKey(key, alg, "decrypt", "unwrapKey");
      check_key_length_default(alg, key);
      if (key.usages.includes("decrypt")) {
        return new Uint8Array(await webcrypto_default.subtle.decrypt(subtleRsaEs(alg), key, encryptedKey));
      }
      if (key.usages.includes("unwrapKey")) {
        const cryptoKeyCek = await webcrypto_default.subtle.unwrapKey("raw", encryptedKey, key, subtleRsaEs(alg), ...bogus_default);
        return new Uint8Array(await webcrypto_default.subtle.exportKey("raw", cryptoKeyCek));
      }
      throw new TypeError('RSA-OAEP key "usages" must include "decrypt" or "unwrapKey" for this operation');
    };
  }
});

// node_modules/jose/dist/browser/lib/cek.js
function bitLength2(alg) {
  switch (alg) {
    case "A128GCM":
      return 128;
    case "A192GCM":
      return 192;
    case "A256GCM":
    case "A128CBC-HS256":
      return 256;
    case "A192CBC-HS384":
      return 384;
    case "A256CBC-HS512":
      return 512;
    default:
      throw new JOSENotSupported(`Unsupported JWE Algorithm: ${alg}`);
  }
}
var cek_default;
var init_cek = __esm({
  "node_modules/jose/dist/browser/lib/cek.js"() {
    init_errors();
    init_random();
    cek_default = (alg) => random_default(new Uint8Array(bitLength2(alg) >> 3));
  }
});

// node_modules/jose/dist/browser/lib/format_pem.js
var format_pem_default;
var init_format_pem = __esm({
  "node_modules/jose/dist/browser/lib/format_pem.js"() {
    format_pem_default = (b64, descriptor) => {
      const newlined = (b64.match(/.{1,64}/g) || []).join("\n");
      return `-----BEGIN ${descriptor}-----
${newlined}
-----END ${descriptor}-----`;
    };
  }
});

// node_modules/jose/dist/browser/runtime/asn1.js
function getElement(seq) {
  let result = [];
  let next = 0;
  while (next < seq.length) {
    let nextPart = parseElement(seq.subarray(next));
    result.push(nextPart);
    next += nextPart.byteLength;
  }
  return result;
}
function parseElement(bytes) {
  let position = 0;
  let tag = bytes[0] & 31;
  position++;
  if (tag === 31) {
    tag = 0;
    while (bytes[position] >= 128) {
      tag = tag * 128 + bytes[position] - 128;
      position++;
    }
    tag = tag * 128 + bytes[position] - 128;
    position++;
  }
  let length = 0;
  if (bytes[position] < 128) {
    length = bytes[position];
    position++;
  } else if (length === 128) {
    length = 0;
    while (bytes[position + length] !== 0 || bytes[position + length + 1] !== 0) {
      if (length > bytes.byteLength) {
        throw new TypeError("invalid indefinite form length");
      }
      length++;
    }
    const byteLength2 = position + length + 2;
    return {
      byteLength: byteLength2,
      contents: bytes.subarray(position, position + length),
      raw: bytes.subarray(0, byteLength2)
    };
  } else {
    let numberOfDigits = bytes[position] & 127;
    position++;
    length = 0;
    for (let i = 0; i < numberOfDigits; i++) {
      length = length * 256 + bytes[position];
      position++;
    }
  }
  const byteLength = position + length;
  return {
    byteLength,
    contents: bytes.subarray(position, byteLength),
    raw: bytes.subarray(0, byteLength)
  };
}
function spkiFromX509(buf) {
  const tbsCertificate = getElement(getElement(parseElement(buf).contents)[0].contents);
  return encodeBase64(tbsCertificate[tbsCertificate[0].raw[0] === 160 ? 6 : 5].raw);
}
function getSPKI(x509) {
  const pem = x509.replace(/(?:-----(?:BEGIN|END) CERTIFICATE-----|\s)/g, "");
  const raw = decodeBase64(pem);
  return format_pem_default(spkiFromX509(raw), "PUBLIC KEY");
}
var genericExport, toSPKI, toPKCS8, findOid, getNamedCurve2, genericImport, fromPKCS8, fromSPKI, fromX509;
var init_asn1 = __esm({
  "node_modules/jose/dist/browser/runtime/asn1.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_format_pem();
    init_errors();
    init_is_key_like();
    genericExport = async (keyType, keyFormat, key) => {
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types));
      }
      if (!key.extractable) {
        throw new TypeError("CryptoKey is not extractable");
      }
      if (key.type !== keyType) {
        throw new TypeError(`key is not a ${keyType} key`);
      }
      return format_pem_default(encodeBase64(new Uint8Array(await webcrypto_default.subtle.exportKey(keyFormat, key))), `${keyType.toUpperCase()} KEY`);
    };
    toSPKI = (key) => {
      return genericExport("public", "spki", key);
    };
    toPKCS8 = (key) => {
      return genericExport("private", "pkcs8", key);
    };
    findOid = (keyData, oid, from = 0) => {
      if (from === 0) {
        oid.unshift(oid.length);
        oid.unshift(6);
      }
      let i = keyData.indexOf(oid[0], from);
      if (i === -1)
        return false;
      const sub = keyData.subarray(i, i + oid.length);
      if (sub.length !== oid.length)
        return false;
      return sub.every((value, index) => value === oid[index]) || findOid(keyData, oid, i + 1);
    };
    getNamedCurve2 = (keyData) => {
      switch (true) {
        case findOid(keyData, [42, 134, 72, 206, 61, 3, 1, 7]):
          return "P-256";
        case findOid(keyData, [43, 129, 4, 0, 34]):
          return "P-384";
        case findOid(keyData, [43, 129, 4, 0, 35]):
          return "P-521";
        case findOid(keyData, [43, 101, 110]):
          return "X25519";
        case findOid(keyData, [43, 101, 111]):
          return "X448";
        case findOid(keyData, [43, 101, 112]):
          return "Ed25519";
        case findOid(keyData, [43, 101, 113]):
          return "Ed448";
        default:
          throw new JOSENotSupported("Invalid or unsupported EC Key Curve or OKP Key Sub Type");
      }
    };
    genericImport = async (replace, keyFormat, pem, alg, options) => {
      var _a;
      let algorithm;
      let keyUsages;
      const keyData = new Uint8Array(atob(pem.replace(replace, "")).split("").map((c) => c.charCodeAt(0)));
      const isPublic = keyFormat === "spki";
      switch (alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${alg.slice(-3)}` };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`
          };
          keyUsages = isPublic ? ["encrypt", "wrapKey"] : ["decrypt", "unwrapKey"];
          break;
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW": {
          const namedCurve = getNamedCurve2(keyData);
          algorithm = namedCurve.startsWith("P-") ? { name: "ECDH", namedCurve } : { name: namedCurve };
          keyUsages = isPublic ? [] : ["deriveBits"];
          break;
        }
        case "EdDSA":
          algorithm = { name: getNamedCurve2(keyData) };
          keyUsages = isPublic ? ["verify"] : ["sign"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported "alg" (Algorithm) value');
      }
      return webcrypto_default.subtle.importKey(keyFormat, keyData, algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
    };
    fromPKCS8 = (pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PRIVATE KEY-----|\s)/g, "pkcs8", pem, alg, options);
    };
    fromSPKI = (pem, alg, options) => {
      return genericImport(/(?:-----(?:BEGIN|END) PUBLIC KEY-----|\s)/g, "spki", pem, alg, options);
    };
    fromX509 = (pem, alg, options) => {
      let spki;
      try {
        spki = getSPKI(pem);
      } catch (cause) {
        throw new TypeError("Failed to parse the X.509 certificate", { cause });
      }
      return fromSPKI(spki, alg, options);
    };
  }
});

// node_modules/jose/dist/browser/runtime/jwk_to_key.js
function subtleMapping(jwk) {
  let algorithm;
  let keyUsages;
  switch (jwk.kty) {
    case "oct": {
      switch (jwk.alg) {
        case "HS256":
        case "HS384":
        case "HS512":
          algorithm = { name: "HMAC", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = ["sign", "verify"];
          break;
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          throw new JOSENotSupported(`${jwk.alg} keys cannot be imported as CryptoKey instances`);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
        case "A128GCMKW":
        case "A192GCMKW":
        case "A256GCMKW":
          algorithm = { name: "AES-GCM" };
          keyUsages = ["encrypt", "decrypt"];
          break;
        case "A128KW":
        case "A192KW":
        case "A256KW":
          algorithm = { name: "AES-KW" };
          keyUsages = ["wrapKey", "unwrapKey"];
          break;
        case "PBES2-HS256+A128KW":
        case "PBES2-HS384+A192KW":
        case "PBES2-HS512+A256KW":
          algorithm = { name: "PBKDF2" };
          keyUsages = ["deriveBits"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "RSA": {
      switch (jwk.alg) {
        case "PS256":
        case "PS384":
        case "PS512":
          algorithm = { name: "RSA-PSS", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RS256":
        case "RS384":
        case "RS512":
          algorithm = { name: "RSASSA-PKCS1-v1_5", hash: `SHA-${jwk.alg.slice(-3)}` };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "RSA-OAEP":
        case "RSA-OAEP-256":
        case "RSA-OAEP-384":
        case "RSA-OAEP-512":
          algorithm = {
            name: "RSA-OAEP",
            hash: `SHA-${parseInt(jwk.alg.slice(-3), 10) || 1}`
          };
          keyUsages = jwk.d ? ["decrypt", "unwrapKey"] : ["encrypt", "wrapKey"];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "EC": {
      switch (jwk.alg) {
        case "ES256":
          algorithm = { name: "ECDSA", namedCurve: "P-256" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES384":
          algorithm = { name: "ECDSA", namedCurve: "P-384" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ES512":
          algorithm = { name: "ECDSA", namedCurve: "P-521" };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: "ECDH", namedCurve: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    case "OKP": {
      switch (jwk.alg) {
        case "EdDSA":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["sign"] : ["verify"];
          break;
        case "ECDH-ES":
        case "ECDH-ES+A128KW":
        case "ECDH-ES+A192KW":
        case "ECDH-ES+A256KW":
          algorithm = { name: jwk.crv };
          keyUsages = jwk.d ? ["deriveBits"] : [];
          break;
        default:
          throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "kty" (Key Type) Parameter value');
  }
  return { algorithm, keyUsages };
}
var parse, jwk_to_key_default;
var init_jwk_to_key = __esm({
  "node_modules/jose/dist/browser/runtime/jwk_to_key.js"() {
    init_webcrypto();
    init_errors();
    init_base64url();
    parse = async (jwk) => {
      var _a, _b;
      if (!jwk.alg) {
        throw new TypeError('"alg" argument is required when "jwk.alg" is not present');
      }
      const { algorithm, keyUsages } = subtleMapping(jwk);
      const rest = [
        algorithm,
        (_a = jwk.ext) !== null && _a !== void 0 ? _a : false,
        (_b = jwk.key_ops) !== null && _b !== void 0 ? _b : keyUsages
      ];
      if (algorithm.name === "PBKDF2") {
        return webcrypto_default.subtle.importKey("raw", decode(jwk.k), ...rest);
      }
      const keyData = { ...jwk };
      delete keyData.alg;
      delete keyData.use;
      return webcrypto_default.subtle.importKey("jwk", keyData, ...rest);
    };
    jwk_to_key_default = parse;
  }
});

// node_modules/jose/dist/browser/key/import.js
async function importSPKI(spki, alg, options) {
  if (typeof spki !== "string" || spki.indexOf("-----BEGIN PUBLIC KEY-----") !== 0) {
    throw new TypeError('"spki" must be SPKI formatted string');
  }
  return fromSPKI(spki, alg, options);
}
async function importX509(x509, alg, options) {
  if (typeof x509 !== "string" || x509.indexOf("-----BEGIN CERTIFICATE-----") !== 0) {
    throw new TypeError('"x509" must be X.509 formatted string');
  }
  return fromX509(x509, alg, options);
}
async function importPKCS8(pkcs8, alg, options) {
  if (typeof pkcs8 !== "string" || pkcs8.indexOf("-----BEGIN PRIVATE KEY-----") !== 0) {
    throw new TypeError('"pkcs8" must be PKCS#8 formatted string');
  }
  return fromPKCS8(pkcs8, alg, options);
}
async function importJWK(jwk, alg, octAsKeyObject) {
  var _a;
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  alg || (alg = jwk.alg);
  switch (jwk.kty) {
    case "oct":
      if (typeof jwk.k !== "string" || !jwk.k) {
        throw new TypeError('missing "k" (Key Value) Parameter value');
      }
      octAsKeyObject !== null && octAsKeyObject !== void 0 ? octAsKeyObject : octAsKeyObject = jwk.ext !== true;
      if (octAsKeyObject) {
        return jwk_to_key_default({ ...jwk, alg, ext: (_a = jwk.ext) !== null && _a !== void 0 ? _a : false });
      }
      return decode(jwk.k);
    case "RSA":
      if (jwk.oth !== void 0) {
        throw new JOSENotSupported('RSA JWK "oth" (Other Primes Info) Parameter value is not supported');
      }
    case "EC":
    case "OKP":
      return jwk_to_key_default({ ...jwk, alg });
    default:
      throw new JOSENotSupported('Unsupported "kty" (Key Type) Parameter value');
  }
}
var init_import = __esm({
  "node_modules/jose/dist/browser/key/import.js"() {
    init_base64url();
    init_asn1();
    init_jwk_to_key();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/lib/check_key_type.js
var symmetricTypeCheck, asymmetricTypeCheck, checkKeyType, check_key_type_default;
var init_check_key_type = __esm({
  "node_modules/jose/dist/browser/lib/check_key_type.js"() {
    init_invalid_key_input();
    init_is_key_like();
    symmetricTypeCheck = (alg, key) => {
      if (key instanceof Uint8Array)
        return;
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types, "Uint8Array"));
      }
      if (key.type !== "secret") {
        throw new TypeError(`${types.join(" or ")} instances for symmetric algorithms must be of type "secret"`);
      }
    };
    asymmetricTypeCheck = (alg, key, usage) => {
      if (!is_key_like_default(key)) {
        throw new TypeError(withAlg(alg, key, ...types));
      }
      if (key.type === "secret") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithms must not be of type "secret"`);
      }
      if (usage === "sign" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm signing must be of type "private"`);
      }
      if (usage === "decrypt" && key.type === "public") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm decryption must be of type "private"`);
      }
      if (key.algorithm && usage === "verify" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm verifying must be of type "public"`);
      }
      if (key.algorithm && usage === "encrypt" && key.type === "private") {
        throw new TypeError(`${types.join(" or ")} instances for asymmetric algorithm encryption must be of type "public"`);
      }
    };
    checkKeyType = (alg, key, usage) => {
      const symmetric = alg.startsWith("HS") || alg === "dir" || alg.startsWith("PBES2") || /^A\d{3}(?:GCM)?KW$/.test(alg);
      if (symmetric) {
        symmetricTypeCheck(alg, key);
      } else {
        asymmetricTypeCheck(alg, key, usage);
      }
    };
    check_key_type_default = checkKeyType;
  }
});

// node_modules/jose/dist/browser/runtime/encrypt.js
async function cbcEncrypt(enc, plaintext, cek, iv, aad) {
  if (!(cek instanceof Uint8Array)) {
    throw new TypeError(invalid_key_input_default(cek, "Uint8Array"));
  }
  const keySize = parseInt(enc.slice(1, 4), 10);
  const encKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(keySize >> 3), "AES-CBC", false, ["encrypt"]);
  const macKey = await webcrypto_default.subtle.importKey("raw", cek.subarray(0, keySize >> 3), {
    hash: `SHA-${keySize << 1}`,
    name: "HMAC"
  }, false, ["sign"]);
  const ciphertext = new Uint8Array(await webcrypto_default.subtle.encrypt({
    iv,
    name: "AES-CBC"
  }, encKey, plaintext));
  const macData = concat(aad, iv, ciphertext, uint64be(aad.length << 3));
  const tag = new Uint8Array((await webcrypto_default.subtle.sign("HMAC", macKey, macData)).slice(0, keySize >> 3));
  return { ciphertext, tag };
}
async function gcmEncrypt(enc, plaintext, cek, iv, aad) {
  let encKey;
  if (cek instanceof Uint8Array) {
    encKey = await webcrypto_default.subtle.importKey("raw", cek, "AES-GCM", false, ["encrypt"]);
  } else {
    checkEncCryptoKey(cek, enc, "encrypt");
    encKey = cek;
  }
  const encrypted = new Uint8Array(await webcrypto_default.subtle.encrypt({
    additionalData: aad,
    iv,
    name: "AES-GCM",
    tagLength: 128
  }, encKey, plaintext));
  const tag = encrypted.slice(-16);
  const ciphertext = encrypted.slice(0, -16);
  return { ciphertext, tag };
}
var encrypt3, encrypt_default;
var init_encrypt = __esm({
  "node_modules/jose/dist/browser/runtime/encrypt.js"() {
    init_buffer_utils();
    init_check_iv_length();
    init_check_cek_length();
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_errors();
    init_is_key_like();
    encrypt3 = async (enc, plaintext, cek, iv, aad) => {
      if (!isCryptoKey(cek) && !(cek instanceof Uint8Array)) {
        throw new TypeError(invalid_key_input_default(cek, ...types, "Uint8Array"));
      }
      check_iv_length_default(enc, iv);
      switch (enc) {
        case "A128CBC-HS256":
        case "A192CBC-HS384":
        case "A256CBC-HS512":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(-3), 10));
          return cbcEncrypt(enc, plaintext, cek, iv, aad);
        case "A128GCM":
        case "A192GCM":
        case "A256GCM":
          if (cek instanceof Uint8Array)
            check_cek_length_default(cek, parseInt(enc.slice(1, 4), 10));
          return gcmEncrypt(enc, plaintext, cek, iv, aad);
        default:
          throw new JOSENotSupported("Unsupported JWE Content Encryption Algorithm");
      }
    };
    encrypt_default = encrypt3;
  }
});

// node_modules/jose/dist/browser/lib/aesgcmkw.js
async function wrap2(alg, key, cek, iv) {
  const jweAlgorithm = alg.slice(0, 7);
  iv || (iv = iv_default(jweAlgorithm));
  const { ciphertext: encryptedKey, tag } = await encrypt_default(jweAlgorithm, cek, key, iv, new Uint8Array(0));
  return { encryptedKey, iv: encode(iv), tag: encode(tag) };
}
async function unwrap2(alg, key, encryptedKey, iv, tag) {
  const jweAlgorithm = alg.slice(0, 7);
  return decrypt_default(jweAlgorithm, key, encryptedKey, iv, tag, new Uint8Array(0));
}
var init_aesgcmkw = __esm({
  "node_modules/jose/dist/browser/lib/aesgcmkw.js"() {
    init_encrypt();
    init_decrypt();
    init_iv();
    init_base64url();
  }
});

// node_modules/jose/dist/browser/lib/decrypt_key_management.js
async function decryptKeyManagement(alg, key, encryptedKey, joseHeader, options) {
  check_key_type_default(alg, key, "decrypt");
  switch (alg) {
    case "dir": {
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
      return key;
    }
    case "ECDH-ES":
      if (encryptedKey !== void 0)
        throw new JWEInvalid("Encountered unexpected JWE Encrypted Key");
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!isObject(joseHeader.epk))
        throw new JWEInvalid(`JOSE Header "epk" (Ephemeral Public Key) missing or invalid`);
      if (!ecdhAllowed(key))
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      const epk = await importJWK(joseHeader.epk, alg);
      let partyUInfo;
      let partyVInfo;
      if (joseHeader.apu !== void 0) {
        if (typeof joseHeader.apu !== "string")
          throw new JWEInvalid(`JOSE Header "apu" (Agreement PartyUInfo) invalid`);
        try {
          partyUInfo = decode(joseHeader.apu);
        } catch (_a) {
          throw new JWEInvalid("Failed to base64url decode the apu");
        }
      }
      if (joseHeader.apv !== void 0) {
        if (typeof joseHeader.apv !== "string")
          throw new JWEInvalid(`JOSE Header "apv" (Agreement PartyVInfo) invalid`);
        try {
          partyVInfo = decode(joseHeader.apv);
        } catch (_b) {
          throw new JWEInvalid("Failed to base64url decode the apv");
        }
      }
      const sharedSecret = await deriveKey(epk, key, alg === "ECDH-ES" ? joseHeader.enc : alg, alg === "ECDH-ES" ? bitLength2(joseHeader.enc) : parseInt(alg.slice(-5, -2), 10), partyUInfo, partyVInfo);
      if (alg === "ECDH-ES")
        return sharedSecret;
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg.slice(-6), sharedSecret, encryptedKey);
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return decrypt3(alg, key, encryptedKey);
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.p2c !== "number")
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) missing or invalid`);
      const p2cLimit = (options === null || options === void 0 ? void 0 : options.maxPBES2Count) || 1e4;
      if (joseHeader.p2c > p2cLimit)
        throw new JWEInvalid(`JOSE Header "p2c" (PBES2 Count) out is of acceptable bounds`);
      if (typeof joseHeader.p2s !== "string")
        throw new JWEInvalid(`JOSE Header "p2s" (PBES2 Salt) missing or invalid`);
      let p2s2;
      try {
        p2s2 = decode(joseHeader.p2s);
      } catch (_c) {
        throw new JWEInvalid("Failed to base64url decode the p2s");
      }
      return decrypt2(alg, key, encryptedKey, joseHeader.p2c, p2s2);
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      return unwrap(alg, key, encryptedKey);
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      if (encryptedKey === void 0)
        throw new JWEInvalid("JWE Encrypted Key missing");
      if (typeof joseHeader.iv !== "string")
        throw new JWEInvalid(`JOSE Header "iv" (Initialization Vector) missing or invalid`);
      if (typeof joseHeader.tag !== "string")
        throw new JWEInvalid(`JOSE Header "tag" (Authentication Tag) missing or invalid`);
      let iv;
      try {
        iv = decode(joseHeader.iv);
      } catch (_d) {
        throw new JWEInvalid("Failed to base64url decode the iv");
      }
      let tag;
      try {
        tag = decode(joseHeader.tag);
      } catch (_e) {
        throw new JWEInvalid("Failed to base64url decode the tag");
      }
      return unwrap2(alg, key, encryptedKey, iv, tag);
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
}
var decrypt_key_management_default;
var init_decrypt_key_management = __esm({
  "node_modules/jose/dist/browser/lib/decrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_errors();
    init_cek();
    init_import();
    init_check_key_type();
    init_is_object();
    init_aesgcmkw();
    decrypt_key_management_default = decryptKeyManagement;
  }
});

// node_modules/jose/dist/browser/lib/validate_crit.js
function validateCrit(Err, recognizedDefault, recognizedOption, protectedHeader, joseHeader) {
  if (joseHeader.crit !== void 0 && protectedHeader.crit === void 0) {
    throw new Err('"crit" (Critical) Header Parameter MUST be integrity protected');
  }
  if (!protectedHeader || protectedHeader.crit === void 0) {
    return /* @__PURE__ */ new Set();
  }
  if (!Array.isArray(protectedHeader.crit) || protectedHeader.crit.length === 0 || protectedHeader.crit.some((input) => typeof input !== "string" || input.length === 0)) {
    throw new Err('"crit" (Critical) Header Parameter MUST be an array of non-empty strings when present');
  }
  let recognized;
  if (recognizedOption !== void 0) {
    recognized = new Map([...Object.entries(recognizedOption), ...recognizedDefault.entries()]);
  } else {
    recognized = recognizedDefault;
  }
  for (const parameter of protectedHeader.crit) {
    if (!recognized.has(parameter)) {
      throw new JOSENotSupported(`Extension Header Parameter "${parameter}" is not recognized`);
    }
    if (joseHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" is missing`);
    } else if (recognized.get(parameter) && protectedHeader[parameter] === void 0) {
      throw new Err(`Extension Header Parameter "${parameter}" MUST be integrity protected`);
    }
  }
  return new Set(protectedHeader.crit);
}
var validate_crit_default;
var init_validate_crit = __esm({
  "node_modules/jose/dist/browser/lib/validate_crit.js"() {
    init_errors();
    validate_crit_default = validateCrit;
  }
});

// node_modules/jose/dist/browser/lib/validate_algorithms.js
var validateAlgorithms, validate_algorithms_default;
var init_validate_algorithms = __esm({
  "node_modules/jose/dist/browser/lib/validate_algorithms.js"() {
    validateAlgorithms = (option, algorithms) => {
      if (algorithms !== void 0 && (!Array.isArray(algorithms) || algorithms.some((s) => typeof s !== "string"))) {
        throw new TypeError(`"${option}" option must be an array of strings`);
      }
      if (!algorithms) {
        return void 0;
      }
      return new Set(algorithms);
    };
    validate_algorithms_default = validateAlgorithms;
  }
});

// node_modules/jose/dist/browser/jwe/flattened/decrypt.js
async function flattenedDecrypt(jwe, key, options) {
  var _a;
  if (!isObject(jwe)) {
    throw new JWEInvalid("Flattened JWE must be an object");
  }
  if (jwe.protected === void 0 && jwe.header === void 0 && jwe.unprotected === void 0) {
    throw new JWEInvalid("JOSE Header missing");
  }
  if (typeof jwe.iv !== "string") {
    throw new JWEInvalid("JWE Initialization Vector missing or incorrect type");
  }
  if (typeof jwe.ciphertext !== "string") {
    throw new JWEInvalid("JWE Ciphertext missing or incorrect type");
  }
  if (typeof jwe.tag !== "string") {
    throw new JWEInvalid("JWE Authentication Tag missing or incorrect type");
  }
  if (jwe.protected !== void 0 && typeof jwe.protected !== "string") {
    throw new JWEInvalid("JWE Protected Header incorrect type");
  }
  if (jwe.encrypted_key !== void 0 && typeof jwe.encrypted_key !== "string") {
    throw new JWEInvalid("JWE Encrypted Key incorrect type");
  }
  if (jwe.aad !== void 0 && typeof jwe.aad !== "string") {
    throw new JWEInvalid("JWE AAD incorrect type");
  }
  if (jwe.header !== void 0 && !isObject(jwe.header)) {
    throw new JWEInvalid("JWE Shared Unprotected Header incorrect type");
  }
  if (jwe.unprotected !== void 0 && !isObject(jwe.unprotected)) {
    throw new JWEInvalid("JWE Per-Recipient Unprotected Header incorrect type");
  }
  let parsedProt;
  if (jwe.protected) {
    try {
      const protectedHeader2 = decode(jwe.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader2));
    } catch (_b) {
      throw new JWEInvalid("JWE Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jwe.header, jwe.unprotected)) {
    throw new JWEInvalid("JWE Protected, JWE Unprotected Header, and JWE Per-Recipient Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jwe.header,
    ...jwe.unprotected
  };
  validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  if (joseHeader.zip !== void 0) {
    if (!parsedProt || !parsedProt.zip) {
      throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
    }
    if (joseHeader.zip !== "DEF") {
      throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
    }
  }
  const { alg, enc } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWEInvalid("missing JWE Algorithm (alg) in JWE Header");
  }
  if (typeof enc !== "string" || !enc) {
    throw new JWEInvalid("missing JWE Encryption Algorithm (enc) in JWE Header");
  }
  const keyManagementAlgorithms = options && validate_algorithms_default("keyManagementAlgorithms", options.keyManagementAlgorithms);
  const contentEncryptionAlgorithms = options && validate_algorithms_default("contentEncryptionAlgorithms", options.contentEncryptionAlgorithms);
  if (keyManagementAlgorithms && !keyManagementAlgorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (contentEncryptionAlgorithms && !contentEncryptionAlgorithms.has(enc)) {
    throw new JOSEAlgNotAllowed('"enc" (Encryption Algorithm) Header Parameter not allowed');
  }
  let encryptedKey;
  if (jwe.encrypted_key !== void 0) {
    try {
      encryptedKey = decode(jwe.encrypted_key);
    } catch (_c) {
      throw new JWEInvalid("Failed to base64url decode the encrypted_key");
    }
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jwe);
    resolvedKey = true;
  }
  let cek;
  try {
    cek = await decrypt_key_management_default(alg, key, encryptedKey, joseHeader, options);
  } catch (err) {
    if (err instanceof TypeError || err instanceof JWEInvalid || err instanceof JOSENotSupported) {
      throw err;
    }
    cek = cek_default(enc);
  }
  let iv;
  let tag;
  try {
    iv = decode(jwe.iv);
  } catch (_d) {
    throw new JWEInvalid("Failed to base64url decode the iv");
  }
  try {
    tag = decode(jwe.tag);
  } catch (_e) {
    throw new JWEInvalid("Failed to base64url decode the tag");
  }
  const protectedHeader = encoder.encode((_a = jwe.protected) !== null && _a !== void 0 ? _a : "");
  let additionalData;
  if (jwe.aad !== void 0) {
    additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(jwe.aad));
  } else {
    additionalData = protectedHeader;
  }
  let ciphertext;
  try {
    ciphertext = decode(jwe.ciphertext);
  } catch (_f) {
    throw new JWEInvalid("Failed to base64url decode the ciphertext");
  }
  let plaintext = await decrypt_default(enc, cek, ciphertext, iv, tag, additionalData);
  if (joseHeader.zip === "DEF") {
    plaintext = await ((options === null || options === void 0 ? void 0 : options.inflateRaw) || inflate)(plaintext);
  }
  const result = { plaintext };
  if (jwe.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jwe.aad !== void 0) {
    try {
      result.additionalAuthenticatedData = decode(jwe.aad);
    } catch (_g) {
      throw new JWEInvalid("Failed to base64url decode the aad");
    }
  }
  if (jwe.unprotected !== void 0) {
    result.sharedUnprotectedHeader = jwe.unprotected;
  }
  if (jwe.header !== void 0) {
    result.unprotectedHeader = jwe.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_decrypt2 = __esm({
  "node_modules/jose/dist/browser/jwe/flattened/decrypt.js"() {
    init_base64url();
    init_decrypt();
    init_zlib();
    init_errors();
    init_is_disjoint();
    init_is_object();
    init_decrypt_key_management();
    init_buffer_utils();
    init_cek();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// node_modules/jose/dist/browser/jwe/compact/decrypt.js
async function compactDecrypt(jwe, key, options) {
  if (jwe instanceof Uint8Array) {
    jwe = decoder.decode(jwe);
  }
  if (typeof jwe !== "string") {
    throw new JWEInvalid("Compact JWE must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: encryptedKey, 2: iv, 3: ciphertext, 4: tag, length } = jwe.split(".");
  if (length !== 5) {
    throw new JWEInvalid("Invalid Compact JWE");
  }
  const decrypted = await flattenedDecrypt({
    ciphertext,
    iv: iv || void 0,
    protected: protectedHeader || void 0,
    tag: tag || void 0,
    encrypted_key: encryptedKey || void 0
  }, key, options);
  const result = { plaintext: decrypted.plaintext, protectedHeader: decrypted.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt3 = __esm({
  "node_modules/jose/dist/browser/jwe/compact/decrypt.js"() {
    init_decrypt2();
    init_errors();
    init_buffer_utils();
  }
});

// node_modules/jose/dist/browser/jwe/general/decrypt.js
async function generalDecrypt(jwe, key, options) {
  if (!isObject(jwe)) {
    throw new JWEInvalid("General JWE must be an object");
  }
  if (!Array.isArray(jwe.recipients) || !jwe.recipients.every(isObject)) {
    throw new JWEInvalid("JWE Recipients missing or incorrect type");
  }
  if (!jwe.recipients.length) {
    throw new JWEInvalid("JWE Recipients has no members");
  }
  for (const recipient of jwe.recipients) {
    try {
      return await flattenedDecrypt({
        aad: jwe.aad,
        ciphertext: jwe.ciphertext,
        encrypted_key: recipient.encrypted_key,
        header: recipient.header,
        iv: jwe.iv,
        protected: jwe.protected,
        tag: jwe.tag,
        unprotected: jwe.unprotected
      }, key, options);
    } catch (_a) {
    }
  }
  throw new JWEDecryptionFailed();
}
var init_decrypt4 = __esm({
  "node_modules/jose/dist/browser/jwe/general/decrypt.js"() {
    init_decrypt2();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/runtime/key_to_jwk.js
var keyToJWK, key_to_jwk_default;
var init_key_to_jwk = __esm({
  "node_modules/jose/dist/browser/runtime/key_to_jwk.js"() {
    init_webcrypto();
    init_invalid_key_input();
    init_base64url();
    init_is_key_like();
    keyToJWK = async (key) => {
      if (key instanceof Uint8Array) {
        return {
          kty: "oct",
          k: encode(key)
        };
      }
      if (!isCryptoKey(key)) {
        throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
      }
      if (!key.extractable) {
        throw new TypeError("non-extractable CryptoKey cannot be exported as a JWK");
      }
      const { ext, key_ops, alg, use, ...jwk } = await webcrypto_default.subtle.exportKey("jwk", key);
      return jwk;
    };
    key_to_jwk_default = keyToJWK;
  }
});

// node_modules/jose/dist/browser/key/export.js
async function exportSPKI(key) {
  return toSPKI(key);
}
async function exportPKCS8(key) {
  return toPKCS8(key);
}
async function exportJWK(key) {
  return key_to_jwk_default(key);
}
var init_export = __esm({
  "node_modules/jose/dist/browser/key/export.js"() {
    init_asn1();
    init_asn1();
    init_key_to_jwk();
  }
});

// node_modules/jose/dist/browser/lib/encrypt_key_management.js
async function encryptKeyManagement(alg, enc, key, providedCek, providedParameters = {}) {
  let encryptedKey;
  let parameters;
  let cek;
  check_key_type_default(alg, key, "encrypt");
  switch (alg) {
    case "dir": {
      cek = key;
      break;
    }
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      if (!ecdhAllowed(key)) {
        throw new JOSENotSupported("ECDH with the provided key is not allowed or not supported by your javascript runtime");
      }
      const { apu, apv } = providedParameters;
      let { epk: ephemeralKey } = providedParameters;
      ephemeralKey || (ephemeralKey = (await generateEpk(key)).privateKey);
      const { x, y, crv, kty } = await exportJWK(ephemeralKey);
      const sharedSecret = await deriveKey(key, ephemeralKey, alg === "ECDH-ES" ? enc : alg, alg === "ECDH-ES" ? bitLength2(enc) : parseInt(alg.slice(-5, -2), 10), apu, apv);
      parameters = { epk: { x, crv, kty } };
      if (kty === "EC")
        parameters.epk.y = y;
      if (apu)
        parameters.apu = encode(apu);
      if (apv)
        parameters.apv = encode(apv);
      if (alg === "ECDH-ES") {
        cek = sharedSecret;
        break;
      }
      cek = providedCek || cek_default(enc);
      const kwAlg = alg.slice(-6);
      encryptedKey = await wrap(kwAlg, sharedSecret, cek);
      break;
    }
    case "RSA1_5":
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await encrypt2(alg, key, cek);
      break;
    }
    case "PBES2-HS256+A128KW":
    case "PBES2-HS384+A192KW":
    case "PBES2-HS512+A256KW": {
      cek = providedCek || cek_default(enc);
      const { p2c, p2s: p2s2 } = providedParameters;
      ({ encryptedKey, ...parameters } = await encrypt(alg, key, cek, p2c, p2s2));
      break;
    }
    case "A128KW":
    case "A192KW":
    case "A256KW": {
      cek = providedCek || cek_default(enc);
      encryptedKey = await wrap(alg, key, cek);
      break;
    }
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW": {
      cek = providedCek || cek_default(enc);
      const { iv } = providedParameters;
      ({ encryptedKey, ...parameters } = await wrap2(alg, key, cek, iv));
      break;
    }
    default: {
      throw new JOSENotSupported('Invalid or unsupported "alg" (JWE Algorithm) header value');
    }
  }
  return { cek, encryptedKey, parameters };
}
var encrypt_key_management_default;
var init_encrypt_key_management = __esm({
  "node_modules/jose/dist/browser/lib/encrypt_key_management.js"() {
    init_aeskw();
    init_ecdhes();
    init_pbes2kw();
    init_rsaes();
    init_base64url();
    init_cek();
    init_errors();
    init_export();
    init_check_key_type();
    init_aesgcmkw();
    encrypt_key_management_default = encryptKeyManagement;
  }
});

// node_modules/jose/dist/browser/jwe/flattened/encrypt.js
var unprotected, FlattenedEncrypt;
var init_encrypt2 = __esm({
  "node_modules/jose/dist/browser/jwe/flattened/encrypt.js"() {
    init_base64url();
    init_encrypt();
    init_zlib();
    init_iv();
    init_encrypt_key_management();
    init_errors();
    init_is_disjoint();
    init_buffer_utils();
    init_validate_crit();
    unprotected = Symbol();
    FlattenedEncrypt = class {
      constructor(plaintext) {
        if (!(plaintext instanceof Uint8Array)) {
          throw new TypeError("plaintext must be an instance of Uint8Array");
        }
        this._plaintext = plaintext;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._sharedUnprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._sharedUnprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      async encrypt(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader && !this._sharedUnprotectedHeader) {
          throw new JWEInvalid("either setProtectedHeader, setUnprotectedHeader, or sharedUnprotectedHeader must be called before #encrypt()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, this._sharedUnprotectedHeader)) {
          throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader,
          ...this._sharedUnprotectedHeader
        };
        validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        if (joseHeader.zip !== void 0) {
          if (!this._protectedHeader || !this._protectedHeader.zip) {
            throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
          }
          if (joseHeader.zip !== "DEF") {
            throw new JOSENotSupported('Unsupported JWE "zip" (Compression Algorithm) Header Parameter value');
          }
        }
        const { alg, enc } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
        }
        if (typeof enc !== "string" || !enc) {
          throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
        }
        let encryptedKey;
        if (alg === "dir") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Encryption");
          }
        } else if (alg === "ECDH-ES") {
          if (this._cek) {
            throw new TypeError("setContentEncryptionKey cannot be called when using Direct Key Agreement");
          }
        }
        let cek;
        {
          let parameters;
          ({ cek, encryptedKey, parameters } = await encrypt_key_management_default(alg, enc, key, this._cek, this._keyManagementParameters));
          if (parameters) {
            if (options && unprotected in options) {
              if (!this._unprotectedHeader) {
                this.setUnprotectedHeader(parameters);
              } else {
                this._unprotectedHeader = { ...this._unprotectedHeader, ...parameters };
              }
            } else {
              if (!this._protectedHeader) {
                this.setProtectedHeader(parameters);
              } else {
                this._protectedHeader = { ...this._protectedHeader, ...parameters };
              }
            }
          }
        }
        this._iv || (this._iv = iv_default(enc));
        let additionalData;
        let protectedHeader;
        let aadMember;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        if (this._aad) {
          aadMember = encode(this._aad);
          additionalData = concat(protectedHeader, encoder.encode("."), encoder.encode(aadMember));
        } else {
          additionalData = protectedHeader;
        }
        let ciphertext;
        let tag;
        if (joseHeader.zip === "DEF") {
          const deflated = await ((options === null || options === void 0 ? void 0 : options.deflateRaw) || deflate)(this._plaintext);
          ({ ciphertext, tag } = await encrypt_default(enc, deflated, cek, this._iv, additionalData));
        } else {
          ;
          ({ ciphertext, tag } = await encrypt_default(enc, this._plaintext, cek, this._iv, additionalData));
        }
        const jwe = {
          ciphertext: encode(ciphertext),
          iv: encode(this._iv),
          tag: encode(tag)
        };
        if (encryptedKey) {
          jwe.encrypted_key = encode(encryptedKey);
        }
        if (aadMember) {
          jwe.aad = aadMember;
        }
        if (this._protectedHeader) {
          jwe.protected = decoder.decode(protectedHeader);
        }
        if (this._sharedUnprotectedHeader) {
          jwe.unprotected = this._sharedUnprotectedHeader;
        }
        if (this._unprotectedHeader) {
          jwe.header = this._unprotectedHeader;
        }
        return jwe;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwe/general/encrypt.js
var IndividualRecipient, GeneralEncrypt;
var init_encrypt3 = __esm({
  "node_modules/jose/dist/browser/jwe/general/encrypt.js"() {
    init_encrypt2();
    init_errors();
    init_cek();
    init_is_disjoint();
    init_encrypt_key_management();
    init_base64url();
    init_validate_crit();
    IndividualRecipient = class {
      constructor(enc, key, options) {
        this.parent = enc;
        this.key = key;
        this.options = options;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addRecipient(...args) {
        return this.parent.addRecipient(...args);
      }
      encrypt(...args) {
        return this.parent.encrypt(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralEncrypt = class {
      constructor(plaintext) {
        this._recipients = [];
        this._plaintext = plaintext;
      }
      addRecipient(key, options) {
        const recipient = new IndividualRecipient(this, key, { crit: options === null || options === void 0 ? void 0 : options.crit });
        this._recipients.push(recipient);
        return recipient;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setSharedUnprotectedHeader(sharedUnprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setSharedUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = sharedUnprotectedHeader;
        return this;
      }
      setAdditionalAuthenticatedData(aad) {
        this._aad = aad;
        return this;
      }
      async encrypt(options) {
        var _a, _b, _c;
        if (!this._recipients.length) {
          throw new JWEInvalid("at least one recipient must be added");
        }
        options = { deflateRaw: options === null || options === void 0 ? void 0 : options.deflateRaw };
        if (this._recipients.length === 1) {
          const [recipient] = this._recipients;
          const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).encrypt(recipient.key, { ...recipient.options, ...options });
          let jwe2 = {
            ciphertext: flattened.ciphertext,
            iv: flattened.iv,
            recipients: [{}],
            tag: flattened.tag
          };
          if (flattened.aad)
            jwe2.aad = flattened.aad;
          if (flattened.protected)
            jwe2.protected = flattened.protected;
          if (flattened.unprotected)
            jwe2.unprotected = flattened.unprotected;
          if (flattened.encrypted_key)
            jwe2.recipients[0].encrypted_key = flattened.encrypted_key;
          if (flattened.header)
            jwe2.recipients[0].header = flattened.header;
          return jwe2;
        }
        let enc;
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader, recipient.unprotectedHeader)) {
            throw new JWEInvalid("JWE Protected, JWE Shared Unprotected and JWE Per-Recipient Header Parameter names must be disjoint");
          }
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const { alg } = joseHeader;
          if (typeof alg !== "string" || !alg) {
            throw new JWEInvalid('JWE "alg" (Algorithm) Header Parameter missing or invalid');
          }
          if (alg === "dir" || alg === "ECDH-ES") {
            throw new JWEInvalid('"dir" and "ECDH-ES" alg may only be used with a single recipient');
          }
          if (typeof joseHeader.enc !== "string" || !joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter missing or invalid');
          }
          if (!enc) {
            enc = joseHeader.enc;
          } else if (enc !== joseHeader.enc) {
            throw new JWEInvalid('JWE "enc" (Encryption Algorithm) Header Parameter must be the same for all recipients');
          }
          validate_crit_default(JWEInvalid, /* @__PURE__ */ new Map(), recipient.options.crit, this._protectedHeader, joseHeader);
          if (joseHeader.zip !== void 0) {
            if (!this._protectedHeader || !this._protectedHeader.zip) {
              throw new JWEInvalid('JWE "zip" (Compression Algorithm) Header MUST be integrity protected');
            }
          }
        }
        const cek = cek_default(enc);
        let jwe = {
          ciphertext: "",
          iv: "",
          recipients: [],
          tag: ""
        };
        for (let i = 0; i < this._recipients.length; i++) {
          const recipient = this._recipients[i];
          const target = {};
          jwe.recipients.push(target);
          const joseHeader = {
            ...this._protectedHeader,
            ...this._unprotectedHeader,
            ...recipient.unprotectedHeader
          };
          const p2c = joseHeader.alg.startsWith("PBES2") ? 2048 + i : void 0;
          if (i === 0) {
            const flattened = await new FlattenedEncrypt(this._plaintext).setAdditionalAuthenticatedData(this._aad).setContentEncryptionKey(cek).setProtectedHeader(this._protectedHeader).setSharedUnprotectedHeader(this._unprotectedHeader).setUnprotectedHeader(recipient.unprotectedHeader).setKeyManagementParameters({ p2c }).encrypt(recipient.key, {
              ...recipient.options,
              ...options,
              [unprotected]: true
            });
            jwe.ciphertext = flattened.ciphertext;
            jwe.iv = flattened.iv;
            jwe.tag = flattened.tag;
            if (flattened.aad)
              jwe.aad = flattened.aad;
            if (flattened.protected)
              jwe.protected = flattened.protected;
            if (flattened.unprotected)
              jwe.unprotected = flattened.unprotected;
            target.encrypted_key = flattened.encrypted_key;
            if (flattened.header)
              target.header = flattened.header;
            continue;
          }
          const { encryptedKey, parameters } = await encrypt_key_management_default(((_a = recipient.unprotectedHeader) === null || _a === void 0 ? void 0 : _a.alg) || ((_b = this._protectedHeader) === null || _b === void 0 ? void 0 : _b.alg) || ((_c = this._unprotectedHeader) === null || _c === void 0 ? void 0 : _c.alg), enc, recipient.key, cek, { p2c });
          target.encrypted_key = encode(encryptedKey);
          if (recipient.unprotectedHeader || parameters)
            target.header = { ...recipient.unprotectedHeader, ...parameters };
        }
        return jwe;
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/subtle_dsa.js
function subtleDsa(alg, algorithm) {
  const hash = `SHA-${alg.slice(-3)}`;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      return { hash, name: "HMAC" };
    case "PS256":
    case "PS384":
    case "PS512":
      return { hash, name: "RSA-PSS", saltLength: alg.slice(-3) >> 3 };
    case "RS256":
    case "RS384":
    case "RS512":
      return { hash, name: "RSASSA-PKCS1-v1_5" };
    case "ES256":
    case "ES384":
    case "ES512":
      return { hash, name: "ECDSA", namedCurve: algorithm.namedCurve };
    case "EdDSA":
      return { name: algorithm.name };
    default:
      throw new JOSENotSupported(`alg ${alg} is not supported either by JOSE or your javascript runtime`);
  }
}
var init_subtle_dsa = __esm({
  "node_modules/jose/dist/browser/runtime/subtle_dsa.js"() {
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/get_sign_verify_key.js
function getCryptoKey3(alg, key, usage) {
  if (isCryptoKey(key)) {
    checkSigCryptoKey(key, alg, usage);
    return key;
  }
  if (key instanceof Uint8Array) {
    if (!alg.startsWith("HS")) {
      throw new TypeError(invalid_key_input_default(key, ...types));
    }
    return webcrypto_default.subtle.importKey("raw", key, { hash: `SHA-${alg.slice(-3)}`, name: "HMAC" }, false, [usage]);
  }
  throw new TypeError(invalid_key_input_default(key, ...types, "Uint8Array"));
}
var init_get_sign_verify_key = __esm({
  "node_modules/jose/dist/browser/runtime/get_sign_verify_key.js"() {
    init_webcrypto();
    init_crypto_key();
    init_invalid_key_input();
    init_is_key_like();
  }
});

// node_modules/jose/dist/browser/runtime/verify.js
var verify, verify_default;
var init_verify = __esm({
  "node_modules/jose/dist/browser/runtime/verify.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    verify = async (alg, key, signature, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "verify");
      check_key_length_default(alg, cryptoKey);
      const algorithm = subtleDsa(alg, cryptoKey.algorithm);
      try {
        return await webcrypto_default.subtle.verify(algorithm, cryptoKey, signature, data);
      } catch (_a) {
        return false;
      }
    };
    verify_default = verify;
  }
});

// node_modules/jose/dist/browser/jws/flattened/verify.js
async function flattenedVerify(jws, key, options) {
  var _a;
  if (!isObject(jws)) {
    throw new JWSInvalid("Flattened JWS must be an object");
  }
  if (jws.protected === void 0 && jws.header === void 0) {
    throw new JWSInvalid('Flattened JWS must have either of the "protected" or "header" members');
  }
  if (jws.protected !== void 0 && typeof jws.protected !== "string") {
    throw new JWSInvalid("JWS Protected Header incorrect type");
  }
  if (jws.payload === void 0) {
    throw new JWSInvalid("JWS Payload missing");
  }
  if (typeof jws.signature !== "string") {
    throw new JWSInvalid("JWS Signature missing or incorrect type");
  }
  if (jws.header !== void 0 && !isObject(jws.header)) {
    throw new JWSInvalid("JWS Unprotected Header incorrect type");
  }
  let parsedProt = {};
  if (jws.protected) {
    try {
      const protectedHeader = decode(jws.protected);
      parsedProt = JSON.parse(decoder.decode(protectedHeader));
    } catch (_b) {
      throw new JWSInvalid("JWS Protected Header is invalid");
    }
  }
  if (!is_disjoint_default(parsedProt, jws.header)) {
    throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
  }
  const joseHeader = {
    ...parsedProt,
    ...jws.header
  };
  const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, parsedProt, joseHeader);
  let b64 = true;
  if (extensions.has("b64")) {
    b64 = parsedProt.b64;
    if (typeof b64 !== "boolean") {
      throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
    }
  }
  const { alg } = joseHeader;
  if (typeof alg !== "string" || !alg) {
    throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
  }
  const algorithms = options && validate_algorithms_default("algorithms", options.algorithms);
  if (algorithms && !algorithms.has(alg)) {
    throw new JOSEAlgNotAllowed('"alg" (Algorithm) Header Parameter not allowed');
  }
  if (b64) {
    if (typeof jws.payload !== "string") {
      throw new JWSInvalid("JWS Payload must be a string");
    }
  } else if (typeof jws.payload !== "string" && !(jws.payload instanceof Uint8Array)) {
    throw new JWSInvalid("JWS Payload must be a string or an Uint8Array instance");
  }
  let resolvedKey = false;
  if (typeof key === "function") {
    key = await key(parsedProt, jws);
    resolvedKey = true;
  }
  check_key_type_default(alg, key, "verify");
  const data = concat(encoder.encode((_a = jws.protected) !== null && _a !== void 0 ? _a : ""), encoder.encode("."), typeof jws.payload === "string" ? encoder.encode(jws.payload) : jws.payload);
  let signature;
  try {
    signature = decode(jws.signature);
  } catch (_c) {
    throw new JWSInvalid("Failed to base64url decode the signature");
  }
  const verified = await verify_default(alg, key, signature, data);
  if (!verified) {
    throw new JWSSignatureVerificationFailed();
  }
  let payload;
  if (b64) {
    try {
      payload = decode(jws.payload);
    } catch (_d) {
      throw new JWSInvalid("Failed to base64url decode the payload");
    }
  } else if (typeof jws.payload === "string") {
    payload = encoder.encode(jws.payload);
  } else {
    payload = jws.payload;
  }
  const result = { payload };
  if (jws.protected !== void 0) {
    result.protectedHeader = parsedProt;
  }
  if (jws.header !== void 0) {
    result.unprotectedHeader = jws.header;
  }
  if (resolvedKey) {
    return { ...result, key };
  }
  return result;
}
var init_verify2 = __esm({
  "node_modules/jose/dist/browser/jws/flattened/verify.js"() {
    init_base64url();
    init_verify();
    init_errors();
    init_buffer_utils();
    init_is_disjoint();
    init_is_object();
    init_check_key_type();
    init_validate_crit();
    init_validate_algorithms();
  }
});

// node_modules/jose/dist/browser/jws/compact/verify.js
async function compactVerify(jws, key, options) {
  if (jws instanceof Uint8Array) {
    jws = decoder.decode(jws);
  }
  if (typeof jws !== "string") {
    throw new JWSInvalid("Compact JWS must be a string or Uint8Array");
  }
  const { 0: protectedHeader, 1: payload, 2: signature, length } = jws.split(".");
  if (length !== 3) {
    throw new JWSInvalid("Invalid Compact JWS");
  }
  const verified = await flattenedVerify({ payload, protected: protectedHeader, signature }, key, options);
  const result = { payload: verified.payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify3 = __esm({
  "node_modules/jose/dist/browser/jws/compact/verify.js"() {
    init_verify2();
    init_errors();
    init_buffer_utils();
  }
});

// node_modules/jose/dist/browser/jws/general/verify.js
async function generalVerify(jws, key, options) {
  if (!isObject(jws)) {
    throw new JWSInvalid("General JWS must be an object");
  }
  if (!Array.isArray(jws.signatures) || !jws.signatures.every(isObject)) {
    throw new JWSInvalid("JWS Signatures missing or incorrect type");
  }
  for (const signature of jws.signatures) {
    try {
      return await flattenedVerify({
        header: signature.header,
        payload: jws.payload,
        protected: signature.protected,
        signature: signature.signature
      }, key, options);
    } catch (_a) {
    }
  }
  throw new JWSSignatureVerificationFailed();
}
var init_verify4 = __esm({
  "node_modules/jose/dist/browser/jws/general/verify.js"() {
    init_verify2();
    init_errors();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/lib/epoch.js
var epoch_default;
var init_epoch = __esm({
  "node_modules/jose/dist/browser/lib/epoch.js"() {
    epoch_default = (date) => Math.floor(date.getTime() / 1e3);
  }
});

// node_modules/jose/dist/browser/lib/secs.js
var minute, hour, day, week, year, REGEX, secs_default;
var init_secs = __esm({
  "node_modules/jose/dist/browser/lib/secs.js"() {
    minute = 60;
    hour = minute * 60;
    day = hour * 24;
    week = day * 7;
    year = day * 365.25;
    REGEX = /^(\d+|\d+\.\d+) ?(seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)$/i;
    secs_default = (str) => {
      const matched = REGEX.exec(str);
      if (!matched) {
        throw new TypeError("Invalid time period format");
      }
      const value = parseFloat(matched[1]);
      const unit = matched[2].toLowerCase();
      switch (unit) {
        case "sec":
        case "secs":
        case "second":
        case "seconds":
        case "s":
          return Math.round(value);
        case "minute":
        case "minutes":
        case "min":
        case "mins":
        case "m":
          return Math.round(value * minute);
        case "hour":
        case "hours":
        case "hr":
        case "hrs":
        case "h":
          return Math.round(value * hour);
        case "day":
        case "days":
        case "d":
          return Math.round(value * day);
        case "week":
        case "weeks":
        case "w":
          return Math.round(value * week);
        default:
          return Math.round(value * year);
      }
    };
  }
});

// node_modules/jose/dist/browser/lib/jwt_claims_set.js
var normalizeTyp, checkAudiencePresence, jwt_claims_set_default;
var init_jwt_claims_set = __esm({
  "node_modules/jose/dist/browser/lib/jwt_claims_set.js"() {
    init_errors();
    init_buffer_utils();
    init_epoch();
    init_secs();
    init_is_object();
    normalizeTyp = (value) => value.toLowerCase().replace(/^application\//, "");
    checkAudiencePresence = (audPayload, audOption) => {
      if (typeof audPayload === "string") {
        return audOption.includes(audPayload);
      }
      if (Array.isArray(audPayload)) {
        return audOption.some(Set.prototype.has.bind(new Set(audPayload)));
      }
      return false;
    };
    jwt_claims_set_default = (protectedHeader, encodedPayload, options = {}) => {
      const { typ } = options;
      if (typ && (typeof protectedHeader.typ !== "string" || normalizeTyp(protectedHeader.typ) !== normalizeTyp(typ))) {
        throw new JWTClaimValidationFailed('unexpected "typ" JWT header value', "typ", "check_failed");
      }
      let payload;
      try {
        payload = JSON.parse(decoder.decode(encodedPayload));
      } catch (_a) {
      }
      if (!isObject(payload)) {
        throw new JWTInvalid("JWT Claims Set must be a top-level JSON object");
      }
      const { requiredClaims = [], issuer, subject, audience, maxTokenAge } = options;
      if (maxTokenAge !== void 0)
        requiredClaims.push("iat");
      if (audience !== void 0)
        requiredClaims.push("aud");
      if (subject !== void 0)
        requiredClaims.push("sub");
      if (issuer !== void 0)
        requiredClaims.push("iss");
      for (const claim of new Set(requiredClaims.reverse())) {
        if (!(claim in payload)) {
          throw new JWTClaimValidationFailed(`missing required "${claim}" claim`, claim, "missing");
        }
      }
      if (issuer && !(Array.isArray(issuer) ? issuer : [issuer]).includes(payload.iss)) {
        throw new JWTClaimValidationFailed('unexpected "iss" claim value', "iss", "check_failed");
      }
      if (subject && payload.sub !== subject) {
        throw new JWTClaimValidationFailed('unexpected "sub" claim value', "sub", "check_failed");
      }
      if (audience && !checkAudiencePresence(payload.aud, typeof audience === "string" ? [audience] : audience)) {
        throw new JWTClaimValidationFailed('unexpected "aud" claim value', "aud", "check_failed");
      }
      let tolerance;
      switch (typeof options.clockTolerance) {
        case "string":
          tolerance = secs_default(options.clockTolerance);
          break;
        case "number":
          tolerance = options.clockTolerance;
          break;
        case "undefined":
          tolerance = 0;
          break;
        default:
          throw new TypeError("Invalid clockTolerance option type");
      }
      const { currentDate } = options;
      const now = epoch_default(currentDate || /* @__PURE__ */ new Date());
      if ((payload.iat !== void 0 || maxTokenAge) && typeof payload.iat !== "number") {
        throw new JWTClaimValidationFailed('"iat" claim must be a number', "iat", "invalid");
      }
      if (payload.nbf !== void 0) {
        if (typeof payload.nbf !== "number") {
          throw new JWTClaimValidationFailed('"nbf" claim must be a number', "nbf", "invalid");
        }
        if (payload.nbf > now + tolerance) {
          throw new JWTClaimValidationFailed('"nbf" claim timestamp check failed', "nbf", "check_failed");
        }
      }
      if (payload.exp !== void 0) {
        if (typeof payload.exp !== "number") {
          throw new JWTClaimValidationFailed('"exp" claim must be a number', "exp", "invalid");
        }
        if (payload.exp <= now - tolerance) {
          throw new JWTExpired('"exp" claim timestamp check failed', "exp", "check_failed");
        }
      }
      if (maxTokenAge) {
        const age = now - payload.iat;
        const max = typeof maxTokenAge === "number" ? maxTokenAge : secs_default(maxTokenAge);
        if (age - tolerance > max) {
          throw new JWTExpired('"iat" claim timestamp check failed (too far in the past)', "iat", "check_failed");
        }
        if (age < 0 - tolerance) {
          throw new JWTClaimValidationFailed('"iat" claim timestamp check failed (it should be in the past)', "iat", "check_failed");
        }
      }
      return payload;
    };
  }
});

// node_modules/jose/dist/browser/jwt/verify.js
async function jwtVerify(jwt, key, options) {
  var _a;
  const verified = await compactVerify(jwt, key, options);
  if (((_a = verified.protectedHeader.crit) === null || _a === void 0 ? void 0 : _a.includes("b64")) && verified.protectedHeader.b64 === false) {
    throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
  }
  const payload = jwt_claims_set_default(verified.protectedHeader, verified.payload, options);
  const result = { payload, protectedHeader: verified.protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: verified.key };
  }
  return result;
}
var init_verify5 = __esm({
  "node_modules/jose/dist/browser/jwt/verify.js"() {
    init_verify3();
    init_jwt_claims_set();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwt/decrypt.js
async function jwtDecrypt(jwt, key, options) {
  const decrypted = await compactDecrypt(jwt, key, options);
  const payload = jwt_claims_set_default(decrypted.protectedHeader, decrypted.plaintext, options);
  const { protectedHeader } = decrypted;
  if (protectedHeader.iss !== void 0 && protectedHeader.iss !== payload.iss) {
    throw new JWTClaimValidationFailed('replicated "iss" claim header parameter mismatch', "iss", "mismatch");
  }
  if (protectedHeader.sub !== void 0 && protectedHeader.sub !== payload.sub) {
    throw new JWTClaimValidationFailed('replicated "sub" claim header parameter mismatch', "sub", "mismatch");
  }
  if (protectedHeader.aud !== void 0 && JSON.stringify(protectedHeader.aud) !== JSON.stringify(payload.aud)) {
    throw new JWTClaimValidationFailed('replicated "aud" claim header parameter mismatch', "aud", "mismatch");
  }
  const result = { payload, protectedHeader };
  if (typeof key === "function") {
    return { ...result, key: decrypted.key };
  }
  return result;
}
var init_decrypt5 = __esm({
  "node_modules/jose/dist/browser/jwt/decrypt.js"() {
    init_decrypt3();
    init_jwt_claims_set();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwe/compact/encrypt.js
var CompactEncrypt;
var init_encrypt4 = __esm({
  "node_modules/jose/dist/browser/jwe/compact/encrypt.js"() {
    init_encrypt2();
    CompactEncrypt = class {
      constructor(plaintext) {
        this._flattened = new FlattenedEncrypt(plaintext);
      }
      setContentEncryptionKey(cek) {
        this._flattened.setContentEncryptionKey(cek);
        return this;
      }
      setInitializationVector(iv) {
        this._flattened.setInitializationVector(iv);
        return this;
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      setKeyManagementParameters(parameters) {
        this._flattened.setKeyManagementParameters(parameters);
        return this;
      }
      async encrypt(key, options) {
        const jwe = await this._flattened.encrypt(key, options);
        return [jwe.protected, jwe.encrypted_key, jwe.iv, jwe.ciphertext, jwe.tag].join(".");
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/sign.js
var sign, sign_default;
var init_sign = __esm({
  "node_modules/jose/dist/browser/runtime/sign.js"() {
    init_subtle_dsa();
    init_webcrypto();
    init_check_key_length();
    init_get_sign_verify_key();
    sign = async (alg, key, data) => {
      const cryptoKey = await getCryptoKey3(alg, key, "sign");
      check_key_length_default(alg, cryptoKey);
      const signature = await webcrypto_default.subtle.sign(subtleDsa(alg, cryptoKey.algorithm), cryptoKey, data);
      return new Uint8Array(signature);
    };
    sign_default = sign;
  }
});

// node_modules/jose/dist/browser/jws/flattened/sign.js
var FlattenedSign;
var init_sign2 = __esm({
  "node_modules/jose/dist/browser/jws/flattened/sign.js"() {
    init_base64url();
    init_sign();
    init_is_disjoint();
    init_errors();
    init_buffer_utils();
    init_check_key_type();
    init_validate_crit();
    FlattenedSign = class {
      constructor(payload) {
        if (!(payload instanceof Uint8Array)) {
          throw new TypeError("payload must be an instance of Uint8Array");
        }
        this._payload = payload;
      }
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this._unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this._unprotectedHeader = unprotectedHeader;
        return this;
      }
      async sign(key, options) {
        if (!this._protectedHeader && !this._unprotectedHeader) {
          throw new JWSInvalid("either setProtectedHeader or setUnprotectedHeader must be called before #sign()");
        }
        if (!is_disjoint_default(this._protectedHeader, this._unprotectedHeader)) {
          throw new JWSInvalid("JWS Protected and JWS Unprotected Header Parameter names must be disjoint");
        }
        const joseHeader = {
          ...this._protectedHeader,
          ...this._unprotectedHeader
        };
        const extensions = validate_crit_default(JWSInvalid, /* @__PURE__ */ new Map([["b64", true]]), options === null || options === void 0 ? void 0 : options.crit, this._protectedHeader, joseHeader);
        let b64 = true;
        if (extensions.has("b64")) {
          b64 = this._protectedHeader.b64;
          if (typeof b64 !== "boolean") {
            throw new JWSInvalid('The "b64" (base64url-encode payload) Header Parameter must be a boolean');
          }
        }
        const { alg } = joseHeader;
        if (typeof alg !== "string" || !alg) {
          throw new JWSInvalid('JWS "alg" (Algorithm) Header Parameter missing or invalid');
        }
        check_key_type_default(alg, key, "sign");
        let payload = this._payload;
        if (b64) {
          payload = encoder.encode(encode(payload));
        }
        let protectedHeader;
        if (this._protectedHeader) {
          protectedHeader = encoder.encode(encode(JSON.stringify(this._protectedHeader)));
        } else {
          protectedHeader = encoder.encode("");
        }
        const data = concat(protectedHeader, encoder.encode("."), payload);
        const signature = await sign_default(alg, key, data);
        const jws = {
          signature: encode(signature),
          payload: ""
        };
        if (b64) {
          jws.payload = decoder.decode(payload);
        }
        if (this._unprotectedHeader) {
          jws.header = this._unprotectedHeader;
        }
        if (this._protectedHeader) {
          jws.protected = decoder.decode(protectedHeader);
        }
        return jws;
      }
    };
  }
});

// node_modules/jose/dist/browser/jws/compact/sign.js
var CompactSign;
var init_sign3 = __esm({
  "node_modules/jose/dist/browser/jws/compact/sign.js"() {
    init_sign2();
    CompactSign = class {
      constructor(payload) {
        this._flattened = new FlattenedSign(payload);
      }
      setProtectedHeader(protectedHeader) {
        this._flattened.setProtectedHeader(protectedHeader);
        return this;
      }
      async sign(key, options) {
        const jws = await this._flattened.sign(key, options);
        if (jws.payload === void 0) {
          throw new TypeError("use the flattened module for creating JWS with b64: false");
        }
        return `${jws.protected}.${jws.payload}.${jws.signature}`;
      }
    };
  }
});

// node_modules/jose/dist/browser/jws/general/sign.js
var IndividualSignature, GeneralSign;
var init_sign4 = __esm({
  "node_modules/jose/dist/browser/jws/general/sign.js"() {
    init_sign2();
    init_errors();
    IndividualSignature = class {
      constructor(sig, key, options) {
        this.parent = sig;
        this.key = key;
        this.options = options;
      }
      setProtectedHeader(protectedHeader) {
        if (this.protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this.protectedHeader = protectedHeader;
        return this;
      }
      setUnprotectedHeader(unprotectedHeader) {
        if (this.unprotectedHeader) {
          throw new TypeError("setUnprotectedHeader can only be called once");
        }
        this.unprotectedHeader = unprotectedHeader;
        return this;
      }
      addSignature(...args) {
        return this.parent.addSignature(...args);
      }
      sign(...args) {
        return this.parent.sign(...args);
      }
      done() {
        return this.parent;
      }
    };
    GeneralSign = class {
      constructor(payload) {
        this._signatures = [];
        this._payload = payload;
      }
      addSignature(key, options) {
        const signature = new IndividualSignature(this, key, options);
        this._signatures.push(signature);
        return signature;
      }
      async sign() {
        if (!this._signatures.length) {
          throw new JWSInvalid("at least one signature must be added");
        }
        const jws = {
          signatures: [],
          payload: ""
        };
        for (let i = 0; i < this._signatures.length; i++) {
          const signature = this._signatures[i];
          const flattened = new FlattenedSign(this._payload);
          flattened.setProtectedHeader(signature.protectedHeader);
          flattened.setUnprotectedHeader(signature.unprotectedHeader);
          const { payload, ...rest } = await flattened.sign(signature.key, signature.options);
          if (i === 0) {
            jws.payload = payload;
          } else if (jws.payload !== payload) {
            throw new JWSInvalid("inconsistent use of JWS Unencoded Payload (RFC7797)");
          }
          jws.signatures.push(rest);
        }
        return jws;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/produce.js
var ProduceJWT;
var init_produce = __esm({
  "node_modules/jose/dist/browser/jwt/produce.js"() {
    init_epoch();
    init_is_object();
    init_secs();
    ProduceJWT = class {
      constructor(payload) {
        if (!isObject(payload)) {
          throw new TypeError("JWT Claims Set MUST be an object");
        }
        this._payload = payload;
      }
      setIssuer(issuer) {
        this._payload = { ...this._payload, iss: issuer };
        return this;
      }
      setSubject(subject) {
        this._payload = { ...this._payload, sub: subject };
        return this;
      }
      setAudience(audience) {
        this._payload = { ...this._payload, aud: audience };
        return this;
      }
      setJti(jwtId) {
        this._payload = { ...this._payload, jti: jwtId };
        return this;
      }
      setNotBefore(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, nbf: input };
        } else {
          this._payload = { ...this._payload, nbf: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setExpirationTime(input) {
        if (typeof input === "number") {
          this._payload = { ...this._payload, exp: input };
        } else {
          this._payload = { ...this._payload, exp: epoch_default(/* @__PURE__ */ new Date()) + secs_default(input) };
        }
        return this;
      }
      setIssuedAt(input) {
        if (typeof input === "undefined") {
          this._payload = { ...this._payload, iat: epoch_default(/* @__PURE__ */ new Date()) };
        } else {
          this._payload = { ...this._payload, iat: input };
        }
        return this;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/sign.js
var SignJWT;
var init_sign5 = __esm({
  "node_modules/jose/dist/browser/jwt/sign.js"() {
    init_sign3();
    init_errors();
    init_buffer_utils();
    init_produce();
    SignJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        this._protectedHeader = protectedHeader;
        return this;
      }
      async sign(key, options) {
        var _a;
        const sig = new CompactSign(encoder.encode(JSON.stringify(this._payload)));
        sig.setProtectedHeader(this._protectedHeader);
        if (Array.isArray((_a = this._protectedHeader) === null || _a === void 0 ? void 0 : _a.crit) && this._protectedHeader.crit.includes("b64") && this._protectedHeader.b64 === false) {
          throw new JWTInvalid("JWTs MUST NOT use unencoded payload");
        }
        return sig.sign(key, options);
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/encrypt.js
var EncryptJWT;
var init_encrypt5 = __esm({
  "node_modules/jose/dist/browser/jwt/encrypt.js"() {
    init_encrypt4();
    init_buffer_utils();
    init_produce();
    EncryptJWT = class extends ProduceJWT {
      setProtectedHeader(protectedHeader) {
        if (this._protectedHeader) {
          throw new TypeError("setProtectedHeader can only be called once");
        }
        this._protectedHeader = protectedHeader;
        return this;
      }
      setKeyManagementParameters(parameters) {
        if (this._keyManagementParameters) {
          throw new TypeError("setKeyManagementParameters can only be called once");
        }
        this._keyManagementParameters = parameters;
        return this;
      }
      setContentEncryptionKey(cek) {
        if (this._cek) {
          throw new TypeError("setContentEncryptionKey can only be called once");
        }
        this._cek = cek;
        return this;
      }
      setInitializationVector(iv) {
        if (this._iv) {
          throw new TypeError("setInitializationVector can only be called once");
        }
        this._iv = iv;
        return this;
      }
      replicateIssuerAsHeader() {
        this._replicateIssuerAsHeader = true;
        return this;
      }
      replicateSubjectAsHeader() {
        this._replicateSubjectAsHeader = true;
        return this;
      }
      replicateAudienceAsHeader() {
        this._replicateAudienceAsHeader = true;
        return this;
      }
      async encrypt(key, options) {
        const enc = new CompactEncrypt(encoder.encode(JSON.stringify(this._payload)));
        if (this._replicateIssuerAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, iss: this._payload.iss };
        }
        if (this._replicateSubjectAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, sub: this._payload.sub };
        }
        if (this._replicateAudienceAsHeader) {
          this._protectedHeader = { ...this._protectedHeader, aud: this._payload.aud };
        }
        enc.setProtectedHeader(this._protectedHeader);
        if (this._iv) {
          enc.setInitializationVector(this._iv);
        }
        if (this._cek) {
          enc.setContentEncryptionKey(this._cek);
        }
        if (this._keyManagementParameters) {
          enc.setKeyManagementParameters(this._keyManagementParameters);
        }
        return enc.encrypt(key, options);
      }
    };
  }
});

// node_modules/jose/dist/browser/jwk/thumbprint.js
async function calculateJwkThumbprint(jwk, digestAlgorithm) {
  if (!isObject(jwk)) {
    throw new TypeError("JWK must be an object");
  }
  digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
  if (digestAlgorithm !== "sha256" && digestAlgorithm !== "sha384" && digestAlgorithm !== "sha512") {
    throw new TypeError('digestAlgorithm must one of "sha256", "sha384", or "sha512"');
  }
  let components;
  switch (jwk.kty) {
    case "EC":
      check(jwk.crv, '"crv" (Curve) Parameter');
      check(jwk.x, '"x" (X Coordinate) Parameter');
      check(jwk.y, '"y" (Y Coordinate) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x, y: jwk.y };
      break;
    case "OKP":
      check(jwk.crv, '"crv" (Subtype of Key Pair) Parameter');
      check(jwk.x, '"x" (Public Key) Parameter');
      components = { crv: jwk.crv, kty: jwk.kty, x: jwk.x };
      break;
    case "RSA":
      check(jwk.e, '"e" (Exponent) Parameter');
      check(jwk.n, '"n" (Modulus) Parameter');
      components = { e: jwk.e, kty: jwk.kty, n: jwk.n };
      break;
    case "oct":
      check(jwk.k, '"k" (Key Value) Parameter');
      components = { k: jwk.k, kty: jwk.kty };
      break;
    default:
      throw new JOSENotSupported('"kty" (Key Type) Parameter missing or unsupported');
  }
  const data = encoder.encode(JSON.stringify(components));
  return encode(await digest_default(digestAlgorithm, data));
}
async function calculateJwkThumbprintUri(jwk, digestAlgorithm) {
  digestAlgorithm !== null && digestAlgorithm !== void 0 ? digestAlgorithm : digestAlgorithm = "sha256";
  const thumbprint = await calculateJwkThumbprint(jwk, digestAlgorithm);
  return `urn:ietf:params:oauth:jwk-thumbprint:sha-${digestAlgorithm.slice(-3)}:${thumbprint}`;
}
var check;
var init_thumbprint = __esm({
  "node_modules/jose/dist/browser/jwk/thumbprint.js"() {
    init_digest();
    init_base64url();
    init_errors();
    init_buffer_utils();
    init_is_object();
    check = (value, description) => {
      if (typeof value !== "string" || !value) {
        throw new JWKInvalid(`${description} missing or invalid`);
      }
    };
  }
});

// node_modules/jose/dist/browser/jwk/embedded.js
async function EmbeddedJWK(protectedHeader, token) {
  const joseHeader = {
    ...protectedHeader,
    ...token === null || token === void 0 ? void 0 : token.header
  };
  if (!isObject(joseHeader.jwk)) {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a JSON object');
  }
  const key = await importJWK({ ...joseHeader.jwk, ext: true }, joseHeader.alg, true);
  if (key instanceof Uint8Array || key.type !== "public") {
    throw new JWSInvalid('"jwk" (JSON Web Key) Header Parameter must be a public key');
  }
  return key;
}
var init_embedded = __esm({
  "node_modules/jose/dist/browser/jwk/embedded.js"() {
    init_import();
    init_is_object();
    init_errors();
  }
});

// node_modules/jose/dist/browser/jwks/local.js
function getKtyFromAlg(alg) {
  switch (typeof alg === "string" && alg.slice(0, 2)) {
    case "RS":
    case "PS":
      return "RSA";
    case "ES":
      return "EC";
    case "Ed":
      return "OKP";
    default:
      throw new JOSENotSupported('Unsupported "alg" value for a JSON Web Key Set');
  }
}
function isJWKSLike(jwks) {
  return jwks && typeof jwks === "object" && Array.isArray(jwks.keys) && jwks.keys.every(isJWKLike);
}
function isJWKLike(key) {
  return isObject(key);
}
function clone(obj) {
  if (typeof structuredClone === "function") {
    return structuredClone(obj);
  }
  return JSON.parse(JSON.stringify(obj));
}
async function importWithAlgCache(cache, jwk, alg) {
  const cached = cache.get(jwk) || cache.set(jwk, {}).get(jwk);
  if (cached[alg] === void 0) {
    const key = await importJWK({ ...jwk, ext: true }, alg);
    if (key instanceof Uint8Array || key.type !== "public") {
      throw new JWKSInvalid("JSON Web Key Set members must be public keys");
    }
    cached[alg] = key;
  }
  return cached[alg];
}
function createLocalJWKSet(jwks) {
  const set = new LocalJWKSet(jwks);
  return async function(protectedHeader, token) {
    return set.getKey(protectedHeader, token);
  };
}
var LocalJWKSet;
var init_local = __esm({
  "node_modules/jose/dist/browser/jwks/local.js"() {
    init_import();
    init_errors();
    init_is_object();
    LocalJWKSet = class {
      constructor(jwks) {
        this._cached = /* @__PURE__ */ new WeakMap();
        if (!isJWKSLike(jwks)) {
          throw new JWKSInvalid("JSON Web Key Set malformed");
        }
        this._jwks = clone(jwks);
      }
      async getKey(protectedHeader, token) {
        const { alg, kid } = { ...protectedHeader, ...token === null || token === void 0 ? void 0 : token.header };
        const kty = getKtyFromAlg(alg);
        const candidates = this._jwks.keys.filter((jwk2) => {
          let candidate = kty === jwk2.kty;
          if (candidate && typeof kid === "string") {
            candidate = kid === jwk2.kid;
          }
          if (candidate && typeof jwk2.alg === "string") {
            candidate = alg === jwk2.alg;
          }
          if (candidate && typeof jwk2.use === "string") {
            candidate = jwk2.use === "sig";
          }
          if (candidate && Array.isArray(jwk2.key_ops)) {
            candidate = jwk2.key_ops.includes("verify");
          }
          if (candidate && alg === "EdDSA") {
            candidate = jwk2.crv === "Ed25519" || jwk2.crv === "Ed448";
          }
          if (candidate) {
            switch (alg) {
              case "ES256":
                candidate = jwk2.crv === "P-256";
                break;
              case "ES256K":
                candidate = jwk2.crv === "secp256k1";
                break;
              case "ES384":
                candidate = jwk2.crv === "P-384";
                break;
              case "ES512":
                candidate = jwk2.crv === "P-521";
                break;
            }
          }
          return candidate;
        });
        const { 0: jwk, length } = candidates;
        if (length === 0) {
          throw new JWKSNoMatchingKey();
        } else if (length !== 1) {
          const error = new JWKSMultipleMatchingKeys();
          const { _cached } = this;
          error[Symbol.asyncIterator] = async function* () {
            for (const jwk2 of candidates) {
              try {
                yield await importWithAlgCache(_cached, jwk2, alg);
              } catch (_a) {
                continue;
              }
            }
          };
          throw error;
        }
        return importWithAlgCache(this._cached, jwk, alg);
      }
    };
  }
});

// node_modules/jose/dist/browser/runtime/fetch_jwks.js
var fetchJwks, fetch_jwks_default;
var init_fetch_jwks = __esm({
  "node_modules/jose/dist/browser/runtime/fetch_jwks.js"() {
    init_errors();
    fetchJwks = async (url, timeout, options) => {
      let controller;
      let id;
      let timedOut = false;
      if (typeof AbortController === "function") {
        controller = new AbortController();
        id = setTimeout(() => {
          timedOut = true;
          controller.abort();
        }, timeout);
      }
      const response = await fetch(url.href, {
        signal: controller ? controller.signal : void 0,
        redirect: "manual",
        headers: options.headers
      }).catch((err) => {
        if (timedOut)
          throw new JWKSTimeout();
        throw err;
      });
      if (id !== void 0)
        clearTimeout(id);
      if (response.status !== 200) {
        throw new JOSEError("Expected 200 OK from the JSON Web Key Set HTTP response");
      }
      try {
        return await response.json();
      } catch (_a) {
        throw new JOSEError("Failed to parse the JSON Web Key Set HTTP response as JSON");
      }
    };
    fetch_jwks_default = fetchJwks;
  }
});

// node_modules/jose/dist/browser/jwks/remote.js
function isCloudflareWorkers() {
  return typeof WebSocketPair !== "undefined" || typeof navigator !== "undefined" && navigator.userAgent === "Cloudflare-Workers" || typeof EdgeRuntime !== "undefined" && EdgeRuntime === "vercel";
}
function createRemoteJWKSet(url, options) {
  const set = new RemoteJWKSet(url, options);
  return async function(protectedHeader, token) {
    return set.getKey(protectedHeader, token);
  };
}
var RemoteJWKSet;
var init_remote = __esm({
  "node_modules/jose/dist/browser/jwks/remote.js"() {
    init_fetch_jwks();
    init_errors();
    init_local();
    RemoteJWKSet = class extends LocalJWKSet {
      constructor(url, options) {
        super({ keys: [] });
        this._jwks = void 0;
        if (!(url instanceof URL)) {
          throw new TypeError("url must be an instance of URL");
        }
        this._url = new URL(url.href);
        this._options = { agent: options === null || options === void 0 ? void 0 : options.agent, headers: options === null || options === void 0 ? void 0 : options.headers };
        this._timeoutDuration = typeof (options === null || options === void 0 ? void 0 : options.timeoutDuration) === "number" ? options === null || options === void 0 ? void 0 : options.timeoutDuration : 5e3;
        this._cooldownDuration = typeof (options === null || options === void 0 ? void 0 : options.cooldownDuration) === "number" ? options === null || options === void 0 ? void 0 : options.cooldownDuration : 3e4;
        this._cacheMaxAge = typeof (options === null || options === void 0 ? void 0 : options.cacheMaxAge) === "number" ? options === null || options === void 0 ? void 0 : options.cacheMaxAge : 6e5;
      }
      coolingDown() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cooldownDuration : false;
      }
      fresh() {
        return typeof this._jwksTimestamp === "number" ? Date.now() < this._jwksTimestamp + this._cacheMaxAge : false;
      }
      async getKey(protectedHeader, token) {
        if (!this._jwks || !this.fresh()) {
          await this.reload();
        }
        try {
          return await super.getKey(protectedHeader, token);
        } catch (err) {
          if (err instanceof JWKSNoMatchingKey) {
            if (this.coolingDown() === false) {
              await this.reload();
              return super.getKey(protectedHeader, token);
            }
          }
          throw err;
        }
      }
      async reload() {
        if (this._pendingFetch && isCloudflareWorkers()) {
          this._pendingFetch = void 0;
        }
        this._pendingFetch || (this._pendingFetch = fetch_jwks_default(this._url, this._timeoutDuration, this._options).then((json) => {
          if (!isJWKSLike(json)) {
            throw new JWKSInvalid("JSON Web Key Set malformed");
          }
          this._jwks = { keys: json.keys };
          this._jwksTimestamp = Date.now();
          this._pendingFetch = void 0;
        }).catch((err) => {
          this._pendingFetch = void 0;
          throw err;
        }));
        await this._pendingFetch;
      }
    };
  }
});

// node_modules/jose/dist/browser/jwt/unsecured.js
var UnsecuredJWT;
var init_unsecured = __esm({
  "node_modules/jose/dist/browser/jwt/unsecured.js"() {
    init_base64url();
    init_buffer_utils();
    init_errors();
    init_jwt_claims_set();
    init_produce();
    UnsecuredJWT = class extends ProduceJWT {
      encode() {
        const header = encode(JSON.stringify({ alg: "none" }));
        const payload = encode(JSON.stringify(this._payload));
        return `${header}.${payload}.`;
      }
      static decode(jwt, options) {
        if (typeof jwt !== "string") {
          throw new JWTInvalid("Unsecured JWT must be a string");
        }
        const { 0: encodedHeader, 1: encodedPayload, 2: signature, length } = jwt.split(".");
        if (length !== 3 || signature !== "") {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        let header;
        try {
          header = JSON.parse(decoder.decode(decode(encodedHeader)));
          if (header.alg !== "none")
            throw new Error();
        } catch (_a) {
          throw new JWTInvalid("Invalid Unsecured JWT");
        }
        const payload = jwt_claims_set_default(header, decode(encodedPayload), options);
        return { payload, header };
      }
    };
  }
});

// node_modules/jose/dist/browser/util/base64url.js
var base64url_exports2 = {};
__export(base64url_exports2, {
  decode: () => decode2,
  encode: () => encode2
});
var encode2, decode2;
var init_base64url2 = __esm({
  "node_modules/jose/dist/browser/util/base64url.js"() {
    init_base64url();
    encode2 = encode;
    decode2 = decode;
  }
});

// node_modules/jose/dist/browser/util/decode_protected_header.js
function decodeProtectedHeader(token) {
  let protectedB64u;
  if (typeof token === "string") {
    const parts = token.split(".");
    if (parts.length === 3 || parts.length === 5) {
      ;
      [protectedB64u] = parts;
    }
  } else if (typeof token === "object" && token) {
    if ("protected" in token) {
      protectedB64u = token.protected;
    } else {
      throw new TypeError("Token does not contain a Protected Header");
    }
  }
  try {
    if (typeof protectedB64u !== "string" || !protectedB64u) {
      throw new Error();
    }
    const result = JSON.parse(decoder.decode(decode2(protectedB64u)));
    if (!isObject(result)) {
      throw new Error();
    }
    return result;
  } catch (_a) {
    throw new TypeError("Invalid Token or Protected Header formatting");
  }
}
var init_decode_protected_header = __esm({
  "node_modules/jose/dist/browser/util/decode_protected_header.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
  }
});

// node_modules/jose/dist/browser/util/decode_jwt.js
function decodeJwt(jwt) {
  if (typeof jwt !== "string")
    throw new JWTInvalid("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: payload, length } = jwt.split(".");
  if (length === 5)
    throw new JWTInvalid("Only JWTs using Compact JWS serialization can be decoded");
  if (length !== 3)
    throw new JWTInvalid("Invalid JWT");
  if (!payload)
    throw new JWTInvalid("JWTs must contain a payload");
  let decoded;
  try {
    decoded = decode2(payload);
  } catch (_a) {
    throw new JWTInvalid("Failed to base64url decode the payload");
  }
  let result;
  try {
    result = JSON.parse(decoder.decode(decoded));
  } catch (_b) {
    throw new JWTInvalid("Failed to parse the decoded payload as JSON");
  }
  if (!isObject(result))
    throw new JWTInvalid("Invalid JWT Claims Set");
  return result;
}
var init_decode_jwt = __esm({
  "node_modules/jose/dist/browser/util/decode_jwt.js"() {
    init_base64url2();
    init_buffer_utils();
    init_is_object();
    init_errors();
  }
});

// node_modules/jose/dist/browser/runtime/generate.js
async function generateSecret(alg, options) {
  var _a;
  let length;
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "HS256":
    case "HS384":
    case "HS512":
      length = parseInt(alg.slice(-3), 10);
      algorithm = { name: "HMAC", hash: `SHA-${length}`, length };
      keyUsages = ["sign", "verify"];
      break;
    case "A128CBC-HS256":
    case "A192CBC-HS384":
    case "A256CBC-HS512":
      length = parseInt(alg.slice(-3), 10);
      return random_default(new Uint8Array(length >> 3));
    case "A128KW":
    case "A192KW":
    case "A256KW":
      length = parseInt(alg.slice(1, 4), 10);
      algorithm = { name: "AES-KW", length };
      keyUsages = ["wrapKey", "unwrapKey"];
      break;
    case "A128GCMKW":
    case "A192GCMKW":
    case "A256GCMKW":
    case "A128GCM":
    case "A192GCM":
    case "A256GCM":
      length = parseInt(alg.slice(1, 4), 10);
      algorithm = { name: "AES-GCM", length };
      keyUsages = ["encrypt", "decrypt"];
      break;
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, (_a = options === null || options === void 0 ? void 0 : options.extractable) !== null && _a !== void 0 ? _a : false, keyUsages);
}
function getModulusLengthOption(options) {
  var _a;
  const modulusLength = (_a = options === null || options === void 0 ? void 0 : options.modulusLength) !== null && _a !== void 0 ? _a : 2048;
  if (typeof modulusLength !== "number" || modulusLength < 2048) {
    throw new JOSENotSupported("Invalid or unsupported modulusLength option provided, 2048 bits or larger keys must be used");
  }
  return modulusLength;
}
async function generateKeyPair(alg, options) {
  var _a, _b, _c;
  let algorithm;
  let keyUsages;
  switch (alg) {
    case "PS256":
    case "PS384":
    case "PS512":
      algorithm = {
        name: "RSA-PSS",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RS256":
    case "RS384":
    case "RS512":
      algorithm = {
        name: "RSASSA-PKCS1-v1_5",
        hash: `SHA-${alg.slice(-3)}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["sign", "verify"];
      break;
    case "RSA-OAEP":
    case "RSA-OAEP-256":
    case "RSA-OAEP-384":
    case "RSA-OAEP-512":
      algorithm = {
        name: "RSA-OAEP",
        hash: `SHA-${parseInt(alg.slice(-3), 10) || 1}`,
        publicExponent: new Uint8Array([1, 0, 1]),
        modulusLength: getModulusLengthOption(options)
      };
      keyUsages = ["decrypt", "unwrapKey", "encrypt", "wrapKey"];
      break;
    case "ES256":
      algorithm = { name: "ECDSA", namedCurve: "P-256" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES384":
      algorithm = { name: "ECDSA", namedCurve: "P-384" };
      keyUsages = ["sign", "verify"];
      break;
    case "ES512":
      algorithm = { name: "ECDSA", namedCurve: "P-521" };
      keyUsages = ["sign", "verify"];
      break;
    case "EdDSA":
      keyUsages = ["sign", "verify"];
      const crv = (_a = options === null || options === void 0 ? void 0 : options.crv) !== null && _a !== void 0 ? _a : "Ed25519";
      switch (crv) {
        case "Ed25519":
        case "Ed448":
          algorithm = { name: crv };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided");
      }
      break;
    case "ECDH-ES":
    case "ECDH-ES+A128KW":
    case "ECDH-ES+A192KW":
    case "ECDH-ES+A256KW": {
      keyUsages = ["deriveKey", "deriveBits"];
      const crv2 = (_b = options === null || options === void 0 ? void 0 : options.crv) !== null && _b !== void 0 ? _b : "P-256";
      switch (crv2) {
        case "P-256":
        case "P-384":
        case "P-521": {
          algorithm = { name: "ECDH", namedCurve: crv2 };
          break;
        }
        case "X25519":
        case "X448":
          algorithm = { name: crv2 };
          break;
        default:
          throw new JOSENotSupported("Invalid or unsupported crv option provided, supported values are P-256, P-384, P-521, X25519, and X448");
      }
      break;
    }
    default:
      throw new JOSENotSupported('Invalid or unsupported JWK "alg" (Algorithm) Parameter value');
  }
  return webcrypto_default.subtle.generateKey(algorithm, (_c = options === null || options === void 0 ? void 0 : options.extractable) !== null && _c !== void 0 ? _c : false, keyUsages);
}
var init_generate = __esm({
  "node_modules/jose/dist/browser/runtime/generate.js"() {
    init_webcrypto();
    init_errors();
    init_random();
  }
});

// node_modules/jose/dist/browser/key/generate_key_pair.js
async function generateKeyPair2(alg, options) {
  return generateKeyPair(alg, options);
}
var init_generate_key_pair = __esm({
  "node_modules/jose/dist/browser/key/generate_key_pair.js"() {
    init_generate();
  }
});

// node_modules/jose/dist/browser/key/generate_secret.js
async function generateSecret2(alg, options) {
  return generateSecret(alg, options);
}
var init_generate_secret = __esm({
  "node_modules/jose/dist/browser/key/generate_secret.js"() {
    init_generate();
  }
});

// node_modules/jose/dist/browser/runtime/runtime.js
var runtime_default;
var init_runtime = __esm({
  "node_modules/jose/dist/browser/runtime/runtime.js"() {
    runtime_default = "WebCryptoAPI";
  }
});

// node_modules/jose/dist/browser/util/runtime.js
var runtime_default2;
var init_runtime2 = __esm({
  "node_modules/jose/dist/browser/util/runtime.js"() {
    init_runtime();
    runtime_default2 = runtime_default;
  }
});

// node_modules/jose/dist/browser/index.js
var browser_exports = {};
__export(browser_exports, {
  CompactEncrypt: () => CompactEncrypt,
  CompactSign: () => CompactSign,
  EmbeddedJWK: () => EmbeddedJWK,
  EncryptJWT: () => EncryptJWT,
  FlattenedEncrypt: () => FlattenedEncrypt,
  FlattenedSign: () => FlattenedSign,
  GeneralEncrypt: () => GeneralEncrypt,
  GeneralSign: () => GeneralSign,
  SignJWT: () => SignJWT,
  UnsecuredJWT: () => UnsecuredJWT,
  base64url: () => base64url_exports2,
  calculateJwkThumbprint: () => calculateJwkThumbprint,
  calculateJwkThumbprintUri: () => calculateJwkThumbprintUri,
  compactDecrypt: () => compactDecrypt,
  compactVerify: () => compactVerify,
  createLocalJWKSet: () => createLocalJWKSet,
  createRemoteJWKSet: () => createRemoteJWKSet,
  cryptoRuntime: () => runtime_default2,
  decodeJwt: () => decodeJwt,
  decodeProtectedHeader: () => decodeProtectedHeader,
  errors: () => errors_exports,
  exportJWK: () => exportJWK,
  exportPKCS8: () => exportPKCS8,
  exportSPKI: () => exportSPKI,
  flattenedDecrypt: () => flattenedDecrypt,
  flattenedVerify: () => flattenedVerify,
  generalDecrypt: () => generalDecrypt,
  generalVerify: () => generalVerify,
  generateKeyPair: () => generateKeyPair2,
  generateSecret: () => generateSecret2,
  importJWK: () => importJWK,
  importPKCS8: () => importPKCS8,
  importSPKI: () => importSPKI,
  importX509: () => importX509,
  jwtDecrypt: () => jwtDecrypt,
  jwtVerify: () => jwtVerify
});
var init_browser = __esm({
  "node_modules/jose/dist/browser/index.js"() {
    init_decrypt3();
    init_decrypt2();
    init_decrypt4();
    init_encrypt3();
    init_verify3();
    init_verify2();
    init_verify4();
    init_verify5();
    init_decrypt5();
    init_encrypt4();
    init_encrypt2();
    init_sign3();
    init_sign2();
    init_sign4();
    init_sign5();
    init_encrypt5();
    init_thumbprint();
    init_embedded();
    init_local();
    init_remote();
    init_unsecured();
    init_export();
    init_import();
    init_decode_protected_header();
    init_decode_jwt();
    init_errors();
    init_generate_key_pair();
    init_generate_secret();
    init_base64url2();
    init_runtime2();
  }
});

// node_modules/jwks-rsa/src/errors/JwksError.js
var require_JwksError = __commonJS({
  "node_modules/jwks-rsa/src/errors/JwksError.js"(exports, module) {
    function JwksError(message2) {
      Error.call(this, message2);
      Error.captureStackTrace(this, this.constructor);
      this.name = "JwksError";
      this.message = message2;
    }
    JwksError.prototype = Object.create(Error.prototype);
    JwksError.prototype.constructor = JwksError;
    module.exports = JwksError;
  }
});

// node_modules/jwks-rsa/src/utils.js
var require_utils2 = __commonJS({
  "node_modules/jwks-rsa/src/utils.js"(exports, module) {
    var jose = (init_browser(), __toCommonJS(browser_exports));
    var JwksError = require_JwksError();
    function resolveAlg(jwk) {
      if (jwk.alg) {
        return jwk.alg;
      }
      if (jwk.kty === "RSA") {
        return "RS256";
      }
      if (jwk.kty === "EC") {
        switch (jwk.crv) {
          case "P-256":
            return "ES256";
          case "secp256k1":
            return "ES256K";
          case "P-384":
            return "ES384";
          case "P-521":
            return "ES512";
        }
      }
      if (jwk.kty === "OKP") {
        switch (jwk.crv) {
          case "Ed25519":
          case "Ed448":
            return "EdDSA";
        }
      }
      throw new JwksError("Unsupported JWK");
    }
    async function retrieveSigningKeys(jwks) {
      const results = [];
      jwks = jwks.filter(({ use }) => use === "sig" || use === void 0).filter(({ kty }) => kty === "RSA" || kty === "EC" || kty === "OKP");
      for (const jwk of jwks) {
        try {
          const key = await jose.importJWK(jwk, resolveAlg(jwk));
          if (key.type !== "public") {
            continue;
          }
          let getSpki;
          switch (key[Symbol.toStringTag]) {
            case "CryptoKey": {
              const spki = await jose.exportSPKI(key);
              getSpki = () => spki;
              break;
            }
            case "KeyObject":
            default:
              getSpki = () => key.export({ format: "pem", type: "spki" });
          }
          results.push({
            get publicKey() {
              return getSpki();
            },
            get rsaPublicKey() {
              return getSpki();
            },
            getPublicKey() {
              return getSpki();
            },
            ...typeof jwk.kid === "string" && jwk.kid ? { kid: jwk.kid } : void 0,
            ...typeof jwk.alg === "string" && jwk.alg ? { alg: jwk.alg } : void 0
          });
        } catch (err) {
          continue;
        }
      }
      return results;
    }
    module.exports = {
      retrieveSigningKeys
    };
  }
});

// node_modules/jwks-rsa/src/wrappers/request.js
var require_request = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/request.js"(exports, module) {
    var http = require_http();
    var https = require_https();
    var urlUtil = require_url();
    module.exports.default = (options) => {
      if (options.fetcher) {
        return options.fetcher(options.uri);
      }
      return new Promise((resolve, reject) => {
        const {
          hostname,
          path,
          port,
          protocol
        } = urlUtil.parse(options.uri);
        const requestOptions = {
          hostname,
          path,
          port,
          method: "GET",
          ...options.headers && { headers: { ...options.headers } },
          ...options.timeout && { timeout: options.timeout },
          ...options.agent && { agent: options.agent }
        };
        const httpRequestLib = protocol === "https:" ? https : http;
        const httpRequest = httpRequestLib.request(requestOptions, (res) => {
          let rawData = "";
          res.setEncoding("utf8");
          res.on("data", (chunk) => {
            rawData += chunk;
          });
          res.on("end", () => {
            if (res.statusCode < 200 || res.statusCode >= 300) {
              const errorMsg = res.body && (res.body.message || res.body) || res.statusMessage || `Http Error ${res.statusCode}`;
              reject({ errorMsg });
            } else {
              try {
                resolve(rawData && JSON.parse(rawData));
              } catch (error) {
                reject(error);
              }
            }
          });
        });
        httpRequest.on("timeout", () => httpRequest.destroy()).on("error", (e) => reject(e)).end();
      });
    };
  }
});

// node_modules/pseudomap/pseudomap.js
var require_pseudomap = __commonJS({
  "node_modules/pseudomap/pseudomap.js"(exports, module) {
    var hasOwnProperty = Object.prototype.hasOwnProperty;
    module.exports = PseudoMap;
    function PseudoMap(set2) {
      if (!(this instanceof PseudoMap))
        throw new TypeError("Constructor PseudoMap requires 'new'");
      this.clear();
      if (set2) {
        if (set2 instanceof PseudoMap || typeof Map === "function" && set2 instanceof Map)
          set2.forEach(function(value, key) {
            this.set(key, value);
          }, this);
        else if (Array.isArray(set2))
          set2.forEach(function(kv) {
            this.set(kv[0], kv[1]);
          }, this);
        else
          throw new TypeError("invalid argument");
      }
    }
    PseudoMap.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      Object.keys(this._data).forEach(function(k) {
        if (k !== "size")
          fn.call(thisp, this._data[k].value, this._data[k].key);
      }, this);
    };
    PseudoMap.prototype.has = function(k) {
      return !!find(this._data, k);
    };
    PseudoMap.prototype.get = function(k) {
      var res = find(this._data, k);
      return res && res.value;
    };
    PseudoMap.prototype.set = function(k, v) {
      set(this._data, k, v);
    };
    PseudoMap.prototype.delete = function(k) {
      var res = find(this._data, k);
      if (res) {
        delete this._data[res._index];
        this._data.size--;
      }
    };
    PseudoMap.prototype.clear = function() {
      var data = /* @__PURE__ */ Object.create(null);
      data.size = 0;
      Object.defineProperty(this, "_data", {
        value: data,
        enumerable: false,
        configurable: true,
        writable: false
      });
    };
    Object.defineProperty(PseudoMap.prototype, "size", {
      get: function() {
        return this._data.size;
      },
      set: function(n) {
      },
      enumerable: true,
      configurable: true
    });
    PseudoMap.prototype.values = PseudoMap.prototype.keys = PseudoMap.prototype.entries = function() {
      throw new Error("iterators are not implemented in this version");
    };
    function same(a, b) {
      return a === b || a !== a && b !== b;
    }
    function Entry(k, v, i) {
      this.key = k;
      this.value = v;
      this._index = i;
    }
    function find(data, k) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
        if (same(data[key].key, k))
          return data[key];
      }
    }
    function set(data, k, v) {
      for (var i = 0, s = "_" + k, key = s; hasOwnProperty.call(data, key); key = s + i++) {
        if (same(data[key].key, k)) {
          data[key].value = v;
          return;
        }
      }
      data.size++;
      data[key] = new Entry(k, v, key);
    }
  }
});

// node_modules/pseudomap/map.js
var require_map = __commonJS({
  "node_modules/pseudomap/map.js"(exports, module) {
    if (process.env.npm_package_name === "pseudomap" && process.env.npm_lifecycle_script === "test")
      process.env.TEST_PSEUDOMAP = "true";
    if (typeof Map === "function" && !process.env.TEST_PSEUDOMAP) {
      module.exports = Map;
    } else {
      module.exports = require_pseudomap();
    }
  }
});

// node_modules/lru-memoizer/node_modules/yallist/yallist.js
var require_yallist = __commonJS({
  "node_modules/lru-memoizer/node_modules/yallist/yallist.js"(exports, module) {
    module.exports = Yallist;
    Yallist.Node = Node;
    Yallist.create = Yallist;
    function Yallist(list) {
      var self2 = this;
      if (!(self2 instanceof Yallist)) {
        self2 = new Yallist();
      }
      self2.tail = null;
      self2.head = null;
      self2.length = 0;
      if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
          self2.push(item);
        });
      } else if (arguments.length > 0) {
        for (var i = 0, l = arguments.length; i < l; i++) {
          self2.push(arguments[i]);
        }
      }
      return self2;
    }
    Yallist.prototype.removeNode = function(node) {
      if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
      }
      var next = node.next;
      var prev = node.prev;
      if (next) {
        next.prev = prev;
      }
      if (prev) {
        prev.next = next;
      }
      if (node === this.head) {
        this.head = next;
      }
      if (node === this.tail) {
        this.tail = prev;
      }
      node.list.length--;
      node.next = null;
      node.prev = null;
      node.list = null;
    };
    Yallist.prototype.unshiftNode = function(node) {
      if (node === this.head) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var head = this.head;
      node.list = this;
      node.next = head;
      if (head) {
        head.prev = node;
      }
      this.head = node;
      if (!this.tail) {
        this.tail = node;
      }
      this.length++;
    };
    Yallist.prototype.pushNode = function(node) {
      if (node === this.tail) {
        return;
      }
      if (node.list) {
        node.list.removeNode(node);
      }
      var tail = this.tail;
      node.list = this;
      node.prev = tail;
      if (tail) {
        tail.next = node;
      }
      this.tail = node;
      if (!this.head) {
        this.head = node;
      }
      this.length++;
    };
    Yallist.prototype.push = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        push(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.unshift = function() {
      for (var i = 0, l = arguments.length; i < l; i++) {
        unshift(this, arguments[i]);
      }
      return this.length;
    };
    Yallist.prototype.pop = function() {
      if (!this.tail) {
        return void 0;
      }
      var res = this.tail.value;
      this.tail = this.tail.prev;
      if (this.tail) {
        this.tail.next = null;
      } else {
        this.head = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.shift = function() {
      if (!this.head) {
        return void 0;
      }
      var res = this.head.value;
      this.head = this.head.next;
      if (this.head) {
        this.head.prev = null;
      } else {
        this.tail = null;
      }
      this.length--;
      return res;
    };
    Yallist.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.head, i = 0; walker !== null; i++) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
      }
    };
    Yallist.prototype.forEachReverse = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = this.tail, i = this.length - 1; walker !== null; i--) {
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
      }
    };
    Yallist.prototype.get = function(n) {
      for (var i = 0, walker = this.head; walker !== null && i < n; i++) {
        walker = walker.next;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.getReverse = function(n) {
      for (var i = 0, walker = this.tail; walker !== null && i < n; i++) {
        walker = walker.prev;
      }
      if (i === n && walker !== null) {
        return walker.value;
      }
    };
    Yallist.prototype.map = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.head; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
      }
      return res;
    };
    Yallist.prototype.mapReverse = function(fn, thisp) {
      thisp = thisp || this;
      var res = new Yallist();
      for (var walker = this.tail; walker !== null; ) {
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
      }
      return res;
    };
    Yallist.prototype.reduce = function(fn, initial) {
      var acc;
      var walker = this.head;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = 0; walker !== null; i++) {
        acc = fn(acc, walker.value, i);
        walker = walker.next;
      }
      return acc;
    };
    Yallist.prototype.reduceReverse = function(fn, initial) {
      var acc;
      var walker = this.tail;
      if (arguments.length > 1) {
        acc = initial;
      } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
      } else {
        throw new TypeError("Reduce of empty list with no initial value");
      }
      for (var i = this.length - 1; walker !== null; i--) {
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
      }
      return acc;
    };
    Yallist.prototype.toArray = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.head; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.next;
      }
      return arr;
    };
    Yallist.prototype.toArrayReverse = function() {
      var arr = new Array(this.length);
      for (var i = 0, walker = this.tail; walker !== null; i++) {
        arr[i] = walker.value;
        walker = walker.prev;
      }
      return arr;
    };
    Yallist.prototype.slice = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = 0, walker = this.head; walker !== null && i < from; i++) {
        walker = walker.next;
      }
      for (; walker !== null && i < to; i++, walker = walker.next) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.sliceReverse = function(from, to) {
      to = to || this.length;
      if (to < 0) {
        to += this.length;
      }
      from = from || 0;
      if (from < 0) {
        from += this.length;
      }
      var ret = new Yallist();
      if (to < from || to < 0) {
        return ret;
      }
      if (from < 0) {
        from = 0;
      }
      if (to > this.length) {
        to = this.length;
      }
      for (var i = this.length, walker = this.tail; walker !== null && i > to; i--) {
        walker = walker.prev;
      }
      for (; walker !== null && i > from; i--, walker = walker.prev) {
        ret.push(walker.value);
      }
      return ret;
    };
    Yallist.prototype.reverse = function() {
      var head = this.head;
      var tail = this.tail;
      for (var walker = head; walker !== null; walker = walker.prev) {
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
      }
      this.head = tail;
      this.tail = head;
      return this;
    };
    function push(self2, item) {
      self2.tail = new Node(item, self2.tail, null, self2);
      if (!self2.head) {
        self2.head = self2.tail;
      }
      self2.length++;
    }
    function unshift(self2, item) {
      self2.head = new Node(item, null, self2.head, self2);
      if (!self2.tail) {
        self2.tail = self2.head;
      }
      self2.length++;
    }
    function Node(value, prev, next, list) {
      if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
      }
      this.list = list;
      this.value = value;
      if (prev) {
        prev.next = this;
        this.prev = prev;
      } else {
        this.prev = null;
      }
      if (next) {
        next.prev = this;
        this.next = next;
      } else {
        this.next = null;
      }
    }
  }
});

// node_modules/lru-memoizer/node_modules/lru-cache/lib/lru-cache.js
var require_lru_cache = __commonJS({
  "node_modules/lru-memoizer/node_modules/lru-cache/lib/lru-cache.js"(exports, module) {
    module.exports = LRUCache;
    var Map2 = require_map();
    var util = require_util();
    var Yallist = require_yallist();
    var symbols = {};
    var hasSymbol = typeof Symbol === "function";
    var makeSymbol;
    if (hasSymbol) {
      makeSymbol = function(key) {
        return Symbol.for(key);
      };
    } else {
      makeSymbol = function(key) {
        return "_" + key;
      };
    }
    function priv(obj, key, val) {
      var sym;
      if (symbols[key]) {
        sym = symbols[key];
      } else {
        sym = makeSymbol(key);
        symbols[key] = sym;
      }
      if (arguments.length === 2) {
        return obj[sym];
      } else {
        obj[sym] = val;
        return val;
      }
    }
    function naiveLength() {
      return 1;
    }
    function LRUCache(options) {
      if (!(this instanceof LRUCache)) {
        return new LRUCache(options);
      }
      if (typeof options === "number") {
        options = { max: options };
      }
      if (!options) {
        options = {};
      }
      var max = priv(this, "max", options.max);
      if (!max || !(typeof max === "number") || max <= 0) {
        priv(this, "max", Infinity);
      }
      var lc = options.length || naiveLength;
      if (typeof lc !== "function") {
        lc = naiveLength;
      }
      priv(this, "lengthCalculator", lc);
      priv(this, "allowStale", options.stale || false);
      priv(this, "maxAge", options.maxAge || 0);
      priv(this, "dispose", options.dispose);
      this.reset();
    }
    Object.defineProperty(LRUCache.prototype, "max", {
      set: function(mL) {
        if (!mL || !(typeof mL === "number") || mL <= 0) {
          mL = Infinity;
        }
        priv(this, "max", mL);
        trim(this);
      },
      get: function() {
        return priv(this, "max");
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "allowStale", {
      set: function(allowStale) {
        priv(this, "allowStale", !!allowStale);
      },
      get: function() {
        return priv(this, "allowStale");
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "maxAge", {
      set: function(mA) {
        if (!mA || !(typeof mA === "number") || mA < 0) {
          mA = 0;
        }
        priv(this, "maxAge", mA);
        trim(this);
      },
      get: function() {
        return priv(this, "maxAge");
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "lengthCalculator", {
      set: function(lC) {
        if (typeof lC !== "function") {
          lC = naiveLength;
        }
        if (lC !== priv(this, "lengthCalculator")) {
          priv(this, "lengthCalculator", lC);
          priv(this, "length", 0);
          priv(this, "lruList").forEach(function(hit) {
            hit.length = priv(this, "lengthCalculator").call(this, hit.value, hit.key);
            priv(this, "length", priv(this, "length") + hit.length);
          }, this);
        }
        trim(this);
      },
      get: function() {
        return priv(this, "lengthCalculator");
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "length", {
      get: function() {
        return priv(this, "length");
      },
      enumerable: true
    });
    Object.defineProperty(LRUCache.prototype, "itemCount", {
      get: function() {
        return priv(this, "lruList").length;
      },
      enumerable: true
    });
    LRUCache.prototype.rforEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = priv(this, "lruList").tail; walker !== null; ) {
        var prev = walker.prev;
        forEachStep(this, fn, walker, thisp);
        walker = prev;
      }
    };
    function forEachStep(self2, fn, node, thisp) {
      var hit = node.value;
      if (isStale(self2, hit)) {
        del(self2, node);
        if (!priv(self2, "allowStale")) {
          hit = void 0;
        }
      }
      if (hit) {
        fn.call(thisp, hit.value, hit.key, self2);
      }
    }
    LRUCache.prototype.forEach = function(fn, thisp) {
      thisp = thisp || this;
      for (var walker = priv(this, "lruList").head; walker !== null; ) {
        var next = walker.next;
        forEachStep(this, fn, walker, thisp);
        walker = next;
      }
    };
    LRUCache.prototype.keys = function() {
      return priv(this, "lruList").toArray().map(function(k) {
        return k.key;
      }, this);
    };
    LRUCache.prototype.values = function() {
      return priv(this, "lruList").toArray().map(function(k) {
        return k.value;
      }, this);
    };
    LRUCache.prototype.reset = function() {
      if (priv(this, "dispose") && priv(this, "lruList") && priv(this, "lruList").length) {
        priv(this, "lruList").forEach(function(hit) {
          priv(this, "dispose").call(this, hit.key, hit.value);
        }, this);
      }
      priv(this, "cache", new Map2());
      priv(this, "lruList", new Yallist());
      priv(this, "length", 0);
    };
    LRUCache.prototype.dump = function() {
      return priv(this, "lruList").map(function(hit) {
        if (!isStale(this, hit)) {
          return {
            k: hit.key,
            v: hit.value,
            e: hit.now + (hit.maxAge || 0)
          };
        }
      }, this).toArray().filter(function(h) {
        return h;
      });
    };
    LRUCache.prototype.dumpLru = function() {
      return priv(this, "lruList");
    };
    LRUCache.prototype.inspect = function(n, opts) {
      var str = "LRUCache {";
      var extras = false;
      var as = priv(this, "allowStale");
      if (as) {
        str += "\n  allowStale: true";
        extras = true;
      }
      var max = priv(this, "max");
      if (max && max !== Infinity) {
        if (extras) {
          str += ",";
        }
        str += "\n  max: " + util.inspect(max, opts);
        extras = true;
      }
      var maxAge = priv(this, "maxAge");
      if (maxAge) {
        if (extras) {
          str += ",";
        }
        str += "\n  maxAge: " + util.inspect(maxAge, opts);
        extras = true;
      }
      var lc = priv(this, "lengthCalculator");
      if (lc && lc !== naiveLength) {
        if (extras) {
          str += ",";
        }
        str += "\n  length: " + util.inspect(priv(this, "length"), opts);
        extras = true;
      }
      var didFirst = false;
      priv(this, "lruList").forEach(function(item) {
        if (didFirst) {
          str += ",\n  ";
        } else {
          if (extras) {
            str += ",\n";
          }
          didFirst = true;
          str += "\n  ";
        }
        var key = util.inspect(item.key).split("\n").join("\n  ");
        var val = { value: item.value };
        if (item.maxAge !== maxAge) {
          val.maxAge = item.maxAge;
        }
        if (lc !== naiveLength) {
          val.length = item.length;
        }
        if (isStale(this, item)) {
          val.stale = true;
        }
        val = util.inspect(val, opts).split("\n").join("\n  ");
        str += key + " => " + val;
      });
      if (didFirst || extras) {
        str += "\n";
      }
      str += "}";
      return str;
    };
    LRUCache.prototype.set = function(key, value, maxAge) {
      maxAge = maxAge || priv(this, "maxAge");
      var now = maxAge ? Date.now() : 0;
      var len = priv(this, "lengthCalculator").call(this, value, key);
      if (priv(this, "cache").has(key)) {
        if (len > priv(this, "max")) {
          del(this, priv(this, "cache").get(key));
          return false;
        }
        var node = priv(this, "cache").get(key);
        var item = node.value;
        if (priv(this, "dispose")) {
          priv(this, "dispose").call(this, key, item.value);
        }
        item.now = now;
        item.maxAge = maxAge;
        item.value = value;
        priv(this, "length", priv(this, "length") + (len - item.length));
        item.length = len;
        this.get(key);
        trim(this);
        return true;
      }
      var hit = new Entry(key, value, len, now, maxAge);
      if (hit.length > priv(this, "max")) {
        if (priv(this, "dispose")) {
          priv(this, "dispose").call(this, key, value);
        }
        return false;
      }
      priv(this, "length", priv(this, "length") + hit.length);
      priv(this, "lruList").unshift(hit);
      priv(this, "cache").set(key, priv(this, "lruList").head);
      trim(this);
      return true;
    };
    LRUCache.prototype.has = function(key) {
      if (!priv(this, "cache").has(key))
        return false;
      var hit = priv(this, "cache").get(key).value;
      if (isStale(this, hit)) {
        return false;
      }
      return true;
    };
    LRUCache.prototype.get = function(key) {
      return get(this, key, true);
    };
    LRUCache.prototype.peek = function(key) {
      return get(this, key, false);
    };
    LRUCache.prototype.pop = function() {
      var node = priv(this, "lruList").tail;
      if (!node)
        return null;
      del(this, node);
      return node.value;
    };
    LRUCache.prototype.del = function(key) {
      del(this, priv(this, "cache").get(key));
    };
    LRUCache.prototype.load = function(arr) {
      this.reset();
      var now = Date.now();
      for (var l = arr.length - 1; l >= 0; l--) {
        var hit = arr[l];
        var expiresAt = hit.e || 0;
        if (expiresAt === 0) {
          this.set(hit.k, hit.v);
        } else {
          var maxAge = expiresAt - now;
          if (maxAge > 0) {
            this.set(hit.k, hit.v, maxAge);
          }
        }
      }
    };
    LRUCache.prototype.prune = function() {
      var self2 = this;
      priv(this, "cache").forEach(function(value, key) {
        get(self2, key, false);
      });
    };
    function get(self2, key, doUse) {
      var node = priv(self2, "cache").get(key);
      if (node) {
        var hit = node.value;
        if (isStale(self2, hit)) {
          del(self2, node);
          if (!priv(self2, "allowStale"))
            hit = void 0;
        } else {
          if (doUse) {
            priv(self2, "lruList").unshiftNode(node);
          }
        }
        if (hit)
          hit = hit.value;
      }
      return hit;
    }
    function isStale(self2, hit) {
      if (!hit || !hit.maxAge && !priv(self2, "maxAge")) {
        return false;
      }
      var stale = false;
      var diff = Date.now() - hit.now;
      if (hit.maxAge) {
        stale = diff > hit.maxAge;
      } else {
        stale = priv(self2, "maxAge") && diff > priv(self2, "maxAge");
      }
      return stale;
    }
    function trim(self2) {
      if (priv(self2, "length") > priv(self2, "max")) {
        for (var walker = priv(self2, "lruList").tail; priv(self2, "length") > priv(self2, "max") && walker !== null; ) {
          var prev = walker.prev;
          del(self2, walker);
          walker = prev;
        }
      }
    }
    function del(self2, node) {
      if (node) {
        var hit = node.value;
        if (priv(self2, "dispose")) {
          priv(self2, "dispose").call(this, hit.key, hit.value);
        }
        priv(self2, "length", priv(self2, "length") - hit.length);
        priv(self2, "cache").delete(hit.key);
        priv(self2, "lruList").removeNode(node);
      }
    }
    function Entry(key, value, length, now, maxAge) {
      this.key = key;
      this.value = value;
      this.length = length;
      this.now = now;
      this.maxAge = maxAge || 0;
    }
  }
});

// node_modules/lodash.clonedeep/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.clonedeep/index.js"(exports, module) {
    var LARGE_ARRAY_SIZE = 200;
    var HASH_UNDEFINED = "__lodash_hash_undefined__";
    var MAX_SAFE_INTEGER = 9007199254740991;
    var argsTag = "[object Arguments]";
    var arrayTag = "[object Array]";
    var boolTag = "[object Boolean]";
    var dateTag = "[object Date]";
    var errorTag = "[object Error]";
    var funcTag = "[object Function]";
    var genTag = "[object GeneratorFunction]";
    var mapTag = "[object Map]";
    var numberTag = "[object Number]";
    var objectTag = "[object Object]";
    var promiseTag = "[object Promise]";
    var regexpTag = "[object RegExp]";
    var setTag = "[object Set]";
    var stringTag = "[object String]";
    var symbolTag = "[object Symbol]";
    var weakMapTag = "[object WeakMap]";
    var arrayBufferTag = "[object ArrayBuffer]";
    var dataViewTag = "[object DataView]";
    var float32Tag = "[object Float32Array]";
    var float64Tag = "[object Float64Array]";
    var int8Tag = "[object Int8Array]";
    var int16Tag = "[object Int16Array]";
    var int32Tag = "[object Int32Array]";
    var uint8Tag = "[object Uint8Array]";
    var uint8ClampedTag = "[object Uint8ClampedArray]";
    var uint16Tag = "[object Uint16Array]";
    var uint32Tag = "[object Uint32Array]";
    var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
    var reFlags = /\w*$/;
    var reIsHostCtor = /^\[object .+?Constructor\]$/;
    var reIsUint = /^(?:0|[1-9]\d*)$/;
    var cloneableTags = {};
    cloneableTags[argsTag] = cloneableTags[arrayTag] = cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] = cloneableTags[boolTag] = cloneableTags[dateTag] = cloneableTags[float32Tag] = cloneableTags[float64Tag] = cloneableTags[int8Tag] = cloneableTags[int16Tag] = cloneableTags[int32Tag] = cloneableTags[mapTag] = cloneableTags[numberTag] = cloneableTags[objectTag] = cloneableTags[regexpTag] = cloneableTags[setTag] = cloneableTags[stringTag] = cloneableTags[symbolTag] = cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] = cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
    cloneableTags[errorTag] = cloneableTags[funcTag] = cloneableTags[weakMapTag] = false;
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    var freeExports = typeof exports == "object" && exports && !exports.nodeType && exports;
    var freeModule = freeExports && typeof module == "object" && module && !module.nodeType && module;
    var moduleExports = freeModule && freeModule.exports === freeExports;
    function addMapEntry(map, pair) {
      map.set(pair[0], pair[1]);
      return map;
    }
    function addSetEntry(set, value) {
      set.add(value);
      return set;
    }
    function arrayEach(array, iteratee) {
      var index = -1, length = array ? array.length : 0;
      while (++index < length) {
        if (iteratee(array[index], index, array) === false) {
          break;
        }
      }
      return array;
    }
    function arrayPush(array, values) {
      var index = -1, length = values.length, offset = array.length;
      while (++index < length) {
        array[offset + index] = values[index];
      }
      return array;
    }
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    function baseTimes(n, iteratee) {
      var index = -1, result = Array(n);
      while (++index < n) {
        result[index] = iteratee(index);
      }
      return result;
    }
    function getValue(object, key) {
      return object == null ? void 0 : object[key];
    }
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function mapToArray(map) {
      var index = -1, result = Array(map.size);
      map.forEach(function(value, key) {
        result[++index] = [key, value];
      });
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    function setToArray(set) {
      var index = -1, result = Array(set.size);
      set.forEach(function(value) {
        result[++index] = value;
      });
      return result;
    }
    var arrayProto = Array.prototype;
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var coreJsData = root["__core-js_shared__"];
    var maskSrcKey = function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
      return uid ? "Symbol(src)_1." + uid : "";
    }();
    var funcToString = funcProto.toString;
    var hasOwnProperty = objectProto.hasOwnProperty;
    var objectToString = objectProto.toString;
    var reIsNative = RegExp(
      "^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$"
    );
    var Buffer2 = moduleExports ? root.Buffer : void 0;
    var Symbol2 = root.Symbol;
    var Uint8Array2 = root.Uint8Array;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    var objectCreate = Object.create;
    var propertyIsEnumerable = objectProto.propertyIsEnumerable;
    var splice = arrayProto.splice;
    var nativeGetSymbols = Object.getOwnPropertySymbols;
    var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
    var nativeKeys = overArg(Object.keys, Object);
    var DataView = getNative(root, "DataView");
    var Map2 = getNative(root, "Map");
    var Promise2 = getNative(root, "Promise");
    var Set2 = getNative(root, "Set");
    var WeakMap2 = getNative(root, "WeakMap");
    var nativeCreate = getNative(Object, "create");
    var dataViewCtorString = toSource(DataView);
    var mapCtorString = toSource(Map2);
    var promiseCtorString = toSource(Promise2);
    var setCtorString = toSource(Set2);
    var weakMapCtorString = toSource(WeakMap2);
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
    function Hash(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
    }
    function hashDelete(key) {
      return this.has(key) && delete this.__data__[key];
    }
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? void 0 : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : void 0;
    }
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
    }
    function hashSet(key, value) {
      var data = this.__data__;
      data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
      return this;
    }
    Hash.prototype.clear = hashClear;
    Hash.prototype["delete"] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;
    function ListCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function listCacheClear() {
      this.__data__ = [];
    }
    function listCacheDelete(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      return true;
    }
    function listCacheGet(key) {
      var data = this.__data__, index = assocIndexOf(data, key);
      return index < 0 ? void 0 : data[index][1];
    }
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }
    function listCacheSet(key, value) {
      var data = this.__data__, index = assocIndexOf(data, key);
      if (index < 0) {
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype["delete"] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;
    function MapCache(entries) {
      var index = -1, length = entries ? entries.length : 0;
      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }
    function mapCacheClear() {
      this.__data__ = {
        "hash": new Hash(),
        "map": new (Map2 || ListCache)(),
        "string": new Hash()
      };
    }
    function mapCacheDelete(key) {
      return getMapData(this, key)["delete"](key);
    }
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }
    function mapCacheSet(key, value) {
      getMapData(this, key).set(key, value);
      return this;
    }
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype["delete"] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;
    function Stack(entries) {
      this.__data__ = new ListCache(entries);
    }
    function stackClear() {
      this.__data__ = new ListCache();
    }
    function stackDelete(key) {
      return this.__data__["delete"](key);
    }
    function stackGet(key) {
      return this.__data__.get(key);
    }
    function stackHas(key) {
      return this.__data__.has(key);
    }
    function stackSet(key, value) {
      var cache = this.__data__;
      if (cache instanceof ListCache) {
        var pairs = cache.__data__;
        if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
          pairs.push([key, value]);
          return this;
        }
        cache = this.__data__ = new MapCache(pairs);
      }
      cache.set(key, value);
      return this;
    }
    Stack.prototype.clear = stackClear;
    Stack.prototype["delete"] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;
    function arrayLikeKeys(value, inherited) {
      var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
      var length = result.length, skipIndexes = !!length;
      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
          result.push(key);
        }
      }
      return result;
    }
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
        object[key] = value;
      }
    }
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }
    function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
      var result;
      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== void 0) {
        return result;
      }
      if (!isObject2(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value), isFunc = tag == funcTag || tag == genTag;
        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || isFunc && !object) {
          if (isHostObject(value)) {
            return object ? value : {};
          }
          result = initCloneObject(isFunc ? {} : value);
          if (!isDeep) {
            return copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, baseClone, isDeep);
        }
      }
      stack || (stack = new Stack());
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);
      if (!isArr) {
        var props = isFull ? getAllKeys(value) : keys(value);
      }
      arrayEach(props || value, function(subValue, key2) {
        if (props) {
          key2 = subValue;
          subValue = value[key2];
        }
        assignValue(result, key2, baseClone(subValue, isDeep, isFull, customizer, key2, value, stack));
      });
      return result;
    }
    function baseCreate(proto) {
      return isObject2(proto) ? objectCreate(proto) : {};
    }
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }
    function baseGetTag(value) {
      return objectToString.call(value);
    }
    function baseIsNative(value) {
      if (!isObject2(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != "constructor") {
          result.push(key);
        }
      }
      return result;
    }
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var result = new buffer.constructor(buffer.length);
      buffer.copy(result);
      return result;
    }
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
      return result;
    }
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }
    function cloneMap(map, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
      return arrayReduce(array, addMapEntry, new map.constructor());
    }
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }
    function cloneSet(set, isDeep, cloneFunc) {
      var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
      return arrayReduce(array, addSetEntry, new set.constructor());
    }
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }
    function copyArray(source, array) {
      var index = -1, length = source.length;
      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }
    function copyObject(source, props, object, customizer) {
      object || (object = {});
      var index = -1, length = props.length;
      while (++index < length) {
        var key = props[index];
        var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
        assignValue(object, key, newValue === void 0 ? source[key] : newValue);
      }
      return object;
    }
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
    }
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : void 0;
    }
    var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;
    var getTag = baseGetTag;
    if (DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
      getTag = function(value) {
        var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString:
              return dataViewTag;
            case mapCtorString:
              return mapTag;
            case promiseCtorString:
              return promiseTag;
            case setCtorString:
              return setTag;
            case weakMapCtorString:
              return weakMapTag;
          }
        }
        return result;
      };
    }
    function initCloneArray(array) {
      var length = array.length, result = array.constructor(length);
      if (length && typeof array[0] == "string" && hasOwnProperty.call(array, "index")) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }
    function initCloneObject(object) {
      return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
    }
    function initCloneByTag(object, tag, cloneFunc, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);
        case boolTag:
        case dateTag:
          return new Ctor(+object);
        case dataViewTag:
          return cloneDataView(object, isDeep);
        case float32Tag:
        case float64Tag:
        case int8Tag:
        case int16Tag:
        case int32Tag:
        case uint8Tag:
        case uint8ClampedTag:
        case uint16Tag:
        case uint32Tag:
          return cloneTypedArray(object, isDeep);
        case mapTag:
          return cloneMap(object, isDeep, cloneFunc);
        case numberTag:
        case stringTag:
          return new Ctor(object);
        case regexpTag:
          return cloneRegExp(object);
        case setTag:
          return cloneSet(object, isDeep, cloneFunc);
        case symbolTag:
          return cloneSymbol(object);
      }
    }
    function isIndex(value, length) {
      length = length == null ? MAX_SAFE_INTEGER : length;
      return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
    }
    function isKeyable(value) {
      var type = typeof value;
      return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
    }
    function isMasked(func) {
      return !!maskSrcKey && maskSrcKey in func;
    }
    function isPrototype(value) {
      var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
      return value === proto;
    }
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {
        }
        try {
          return func + "";
        } catch (e) {
        }
      }
      return "";
    }
    function cloneDeep(value) {
      return baseClone(value, true, true);
    }
    function eq(value, other) {
      return value === other || value !== value && other !== other;
    }
    function isArguments(value) {
      return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
    }
    var isArray = Array.isArray;
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }
    function isArrayLikeObject(value) {
      return isObjectLike2(value) && isArrayLike(value);
    }
    var isBuffer = nativeIsBuffer || stubFalse;
    function isFunction(value) {
      var tag = isObject2(value) ? objectToString.call(value) : "";
      return tag == funcTag || tag == genTag;
    }
    function isLength(value) {
      return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }
    function isObject2(value) {
      var type = typeof value;
      return !!value && (type == "object" || type == "function");
    }
    function isObjectLike2(value) {
      return !!value && typeof value == "object";
    }
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }
    function stubArray() {
      return [];
    }
    function stubFalse() {
      return false;
    }
    module.exports = cloneDeep;
  }
});

// node_modules/lru-memoizer/lib/freeze.js
var require_freeze = __commonJS({
  "node_modules/lru-memoizer/lib/freeze.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.deepFreeze = void 0;
    function deepFreeze(o) {
      if (o) {
        Object.freeze(o);
        Object.getOwnPropertyNames(o).forEach(function(prop) {
          if (o.hasOwnProperty(prop) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && o[prop].constructor !== Buffer && !Object.isFrozen(o[prop])) {
            deepFreeze(o[prop]);
          }
        });
      }
      return o;
    }
    exports.deepFreeze = deepFreeze;
  }
});

// node_modules/lru-memoizer/lib/sync.js
var require_sync = __commonJS({
  "node_modules/lru-memoizer/lib/sync.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spread = exports && exports.__spread || function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.syncMemoizer = void 0;
    var lru_cache_1 = __importDefault(require_lru_cache());
    var events_1 = require_events();
    var lodash_clonedeep_1 = __importDefault(require_lodash());
    var freeze_1 = require_freeze();
    function syncMemoizer(options) {
      var cache = new lru_cache_1.default(options);
      var load = options.load;
      var hash = options.hash;
      var bypass = options.bypass;
      var itemMaxAge = options.itemMaxAge;
      var freeze = options.freeze;
      var clone2 = options.clone;
      var emitter = new events_1.EventEmitter();
      var defaultResult = Object.assign({
        del,
        reset: function() {
          return cache.reset();
        },
        keys: cache.keys.bind(cache),
        on: emitter.on.bind(emitter),
        once: emitter.once.bind(emitter)
      }, options);
      if (options.disable) {
        return Object.assign(load, defaultResult);
      }
      function del() {
        var key = hash.apply(void 0, __spread(arguments));
        cache.del(key);
      }
      function emit(event) {
        var parameters = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          parameters[_i - 1] = arguments[_i];
        }
        emitter.emit.apply(emitter, __spread([event], parameters));
      }
      function isPromise(result2) {
        return result2 && result2.then && typeof result2.then === "function";
      }
      function processResult(result2) {
        var res = result2;
        if (clone2) {
          if (isPromise(res)) {
            res = res.then(lodash_clonedeep_1.default);
          } else {
            res = lodash_clonedeep_1.default(res);
          }
        }
        if (freeze) {
          if (isPromise(res)) {
            res = res.then(freeze_1.deepFreeze);
          } else {
            freeze_1.deepFreeze(res);
          }
        }
        return res;
      }
      var result = function() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        if (bypass && bypass.apply(void 0, __spread(args))) {
          emit.apply(void 0, __spread(["miss"], args));
          return load.apply(void 0, __spread(args));
        }
        var key = hash.apply(void 0, __spread(args));
        var fromCache = cache.get(key);
        if (fromCache) {
          emit.apply(void 0, __spread(["hit"], args));
          return processResult(fromCache);
        }
        emit.apply(void 0, __spread(["miss"], args));
        var result2 = load.apply(void 0, __spread(args));
        if (itemMaxAge) {
          cache.set(key, result2, itemMaxAge.apply(void 0, __spread(args.concat([result2]))));
        } else {
          cache.set(key, result2);
        }
        return processResult(result2);
      };
      return Object.assign(result, defaultResult);
    }
    exports.syncMemoizer = syncMemoizer;
  }
});

// node_modules/lru-memoizer/lib/async.js
var require_async = __commonJS({
  "node_modules/lru-memoizer/lib/async.js"(exports) {
    "use strict";
    var __read = exports && exports.__read || function(o, n) {
      var m = typeof Symbol === "function" && o[Symbol.iterator];
      if (!m)
        return o;
      var i = m.call(o), r, ar = [], e;
      try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
          ar.push(r.value);
      } catch (error) {
        e = { error };
      } finally {
        try {
          if (r && !r.done && (m = i["return"]))
            m.call(i);
        } finally {
          if (e)
            throw e.error;
        }
      }
      return ar;
    };
    var __spread = exports && exports.__spread || function() {
      for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
      return ar;
    };
    var __values = exports && exports.__values || function(o) {
      var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
      if (m)
        return m.call(o);
      if (o && typeof o.length === "number")
        return {
          next: function() {
            if (o && i >= o.length)
              o = void 0;
            return { value: o && o[i++], done: !o };
          }
        };
      throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
    };
    var __importDefault = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.asyncMemoizer = void 0;
    var lru_cache_1 = __importDefault(require_lru_cache());
    var events_1 = require_events();
    var lodash_clonedeep_1 = __importDefault(require_lodash());
    var freeze_1 = require_freeze();
    var sync_1 = require_sync();
    function asyncMemoizer(options) {
      var cache = new lru_cache_1.default(options);
      var load = options.load;
      var hash = options.hash;
      var bypass = options.bypass;
      var itemMaxAge = options.itemMaxAge;
      var freeze = options.freeze;
      var clone2 = options.clone;
      var queueMaxAge = options.queueMaxAge || 1e3;
      var loading = /* @__PURE__ */ new Map();
      var emitter = new events_1.EventEmitter();
      var memoizerMethods = Object.assign({
        del,
        reset: function() {
          return cache.reset();
        },
        keys: cache.keys.bind(cache),
        on: emitter.on.bind(emitter),
        once: emitter.once.bind(emitter)
      }, options);
      if (options.disable) {
        return Object.assign(load, memoizerMethods);
      }
      function del() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var key = hash.apply(void 0, __spread(args));
        cache.del(key);
      }
      function add(key, parameters, result) {
        if (freeze) {
          result.forEach(freeze_1.deepFreeze);
        }
        if (itemMaxAge) {
          cache.set(key, result, itemMaxAge.apply(void 0, __spread(parameters.concat(result))));
        } else {
          cache.set(key, result);
        }
      }
      function runCallbacks(callbacks, args) {
        var e_1, _a;
        try {
          for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
            var callback = callbacks_1_1.value;
            if (clone2) {
              setImmediate.apply(void 0, __spread([callback], args.map(lodash_clonedeep_1.default)));
            } else {
              setImmediate.apply(void 0, __spread([callback], args));
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (callbacks_1_1 && !callbacks_1_1.done && (_a = callbacks_1.return))
              _a.call(callbacks_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      function emit(event) {
        var parameters = [];
        for (var _i = 1; _i < arguments.length; _i++) {
          parameters[_i - 1] = arguments[_i];
        }
        emitter.emit.apply(emitter, __spread([event], parameters));
      }
      function memoizedFunction() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          args[_i] = arguments[_i];
        }
        var parameters = args.slice(0, -1);
        var callback = args.slice(-1).pop();
        var key;
        if (bypass && bypass.apply(void 0, __spread(parameters))) {
          emit.apply(void 0, __spread(["miss"], parameters));
          return load.apply(void 0, __spread(args));
        }
        if (parameters.length === 0 && !hash) {
          key = "_";
        } else {
          key = hash.apply(void 0, __spread(parameters));
        }
        var fromCache = cache.get(key);
        if (fromCache) {
          emit.apply(void 0, __spread(["hit"], parameters));
          return runCallbacks([callback], [null].concat(fromCache));
        }
        var pendingLoad = loading.get(key);
        if (pendingLoad && pendingLoad.expiresAt > Date.now()) {
          pendingLoad.queue.push(callback);
          emit.apply(void 0, __spread(["queue"], parameters));
          return;
        }
        emit.apply(void 0, __spread(["miss"], parameters));
        var started = Date.now();
        var queue = [callback];
        loading.set(key, {
          queue,
          expiresAt: started + queueMaxAge
        });
        var loadHandler = function() {
          var args2 = [];
          for (var _i2 = 0; _i2 < arguments.length; _i2++) {
            args2[_i2] = arguments[_i2];
          }
          var err = args2[0];
          if (!err) {
            add(key, parameters, args2.slice(1));
          }
          loading.delete(key);
          emit.apply(void 0, __spread(["loaded", Date.now() - started], parameters));
          runCallbacks(queue, args2);
        };
        load.apply(void 0, __spread(parameters, [loadHandler]));
      }
      ;
      return Object.assign(memoizedFunction, memoizerMethods);
    }
    exports.asyncMemoizer = asyncMemoizer;
    asyncMemoizer.sync = sync_1.syncMemoizer;
  }
});

// node_modules/lru-memoizer/lib/index.js
var require_lib = __commonJS({
  "node_modules/lru-memoizer/lib/index.js"(exports, module) {
    "use strict";
    var async_1 = require_async();
    module.exports = async_1.asyncMemoizer;
  }
});

// node_modules/jwks-rsa/src/wrappers/cache.js
var require_cache = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/cache.js"(exports, module) {
    var logger = require_browser()("jwks");
    var memoizer = require_lib();
    var { promisify, callbackify } = require_util();
    function cacheWrapper(client, { cacheMaxEntries = 5, cacheMaxAge = 6e5 }) {
      logger(`Configured caching of signing keys. Max: ${cacheMaxEntries} / Age: ${cacheMaxAge}`);
      return promisify(memoizer({
        hash: (kid) => kid,
        load: callbackify(client.getSigningKey.bind(client)),
        maxAge: cacheMaxAge,
        max: cacheMaxEntries
      }));
    }
    module.exports.default = cacheWrapper;
  }
});

// node_modules/limiter/lib/tokenBucket.js
var require_tokenBucket = __commonJS({
  "node_modules/limiter/lib/tokenBucket.js"(exports, module) {
    var TokenBucket = function(bucketSize, tokensPerInterval, interval, parentBucket) {
      this.bucketSize = bucketSize;
      this.tokensPerInterval = tokensPerInterval;
      if (typeof interval === "string") {
        switch (interval) {
          case "sec":
          case "second":
            this.interval = 1e3;
            break;
          case "min":
          case "minute":
            this.interval = 1e3 * 60;
            break;
          case "hr":
          case "hour":
            this.interval = 1e3 * 60 * 60;
            break;
          case "day":
            this.interval = 1e3 * 60 * 60 * 24;
            break;
          default:
            throw new Error("Invaid interval " + interval);
        }
      } else {
        this.interval = interval;
      }
      this.parentBucket = parentBucket;
      this.content = 0;
      this.lastDrip = +/* @__PURE__ */ new Date();
    };
    TokenBucket.prototype = {
      bucketSize: 1,
      tokensPerInterval: 1,
      interval: 1e3,
      parentBucket: null,
      content: 0,
      lastDrip: 0,
      /**
       * Remove the requested number of tokens and fire the given callback. If the
       * bucket (and any parent buckets) contains enough tokens this will happen
       * immediately. Otherwise, the removal and callback will happen when enough
       * tokens become available.
       * @param {Number} count The number of tokens to remove.
       * @param {Function} callback(err, remainingTokens)
       * @returns {Boolean} True if the callback was fired immediately, otherwise
       *  false.
       */
      removeTokens: function(count, callback) {
        var self2 = this;
        if (!this.bucketSize) {
          process.nextTick(callback.bind(null, null, count, Number.POSITIVE_INFINITY));
          return true;
        }
        if (count > this.bucketSize) {
          process.nextTick(callback.bind(null, "Requested tokens " + count + " exceeds bucket size " + this.bucketSize, null));
          return false;
        }
        this.drip();
        if (count > this.content)
          return comeBackLater();
        if (this.parentBucket) {
          return this.parentBucket.removeTokens(count, function(err, remainingTokens) {
            if (err)
              return callback(err, null);
            if (count > self2.content)
              return comeBackLater();
            self2.content -= count;
            callback(null, Math.min(remainingTokens, self2.content));
          });
        } else {
          this.content -= count;
          process.nextTick(callback.bind(null, null, this.content));
          return true;
        }
        function comeBackLater() {
          var waitInterval = Math.ceil(
            (count - self2.content) * (self2.interval / self2.tokensPerInterval)
          );
          setTimeout(function() {
            self2.removeTokens(count, callback);
          }, waitInterval);
          return false;
        }
      },
      /**
       * Attempt to remove the requested number of tokens and return immediately.
       * If the bucket (and any parent buckets) contains enough tokens this will
       * return true, otherwise false is returned.
       * @param {Number} count The number of tokens to remove.
       * @param {Boolean} True if the tokens were successfully removed, otherwise
       *  false.
       */
      tryRemoveTokens: function(count) {
        if (!this.bucketSize)
          return true;
        if (count > this.bucketSize)
          return false;
        this.drip();
        if (count > this.content)
          return false;
        if (this.parentBucket && !this.parentBucket.tryRemoveTokens(count))
          return false;
        this.content -= count;
        return true;
      },
      /**
       * Add any new tokens to the bucket since the last drip.
       * @returns {Boolean} True if new tokens were added, otherwise false.
       */
      drip: function() {
        if (!this.tokensPerInterval) {
          this.content = this.bucketSize;
          return;
        }
        var now = +/* @__PURE__ */ new Date();
        var deltaMS = Math.max(now - this.lastDrip, 0);
        this.lastDrip = now;
        var dripAmount = deltaMS * (this.tokensPerInterval / this.interval);
        this.content = Math.min(this.content + dripAmount, this.bucketSize);
      }
    };
    module.exports = TokenBucket;
  }
});

// node_modules/limiter/lib/clock.js
var require_clock = __commonJS({
  "node_modules/limiter/lib/clock.js"(exports, module) {
    var getMilliseconds = function() {
      if (typeof process !== "undefined" && process.hrtime) {
        var hrtime = process.hrtime();
        var seconds = hrtime[0];
        var nanoseconds = hrtime[1];
        return seconds * 1e3 + Math.floor(nanoseconds / 1e6);
      }
      return (/* @__PURE__ */ new Date()).getTime();
    };
    module.exports = getMilliseconds;
  }
});

// node_modules/limiter/lib/rateLimiter.js
var require_rateLimiter = __commonJS({
  "node_modules/limiter/lib/rateLimiter.js"(exports, module) {
    var TokenBucket = require_tokenBucket();
    var getMilliseconds = require_clock();
    var RateLimiter = function(tokensPerInterval, interval, fireImmediately) {
      this.tokenBucket = new TokenBucket(
        tokensPerInterval,
        tokensPerInterval,
        interval,
        null
      );
      this.tokenBucket.content = tokensPerInterval;
      this.curIntervalStart = getMilliseconds();
      this.tokensThisInterval = 0;
      this.fireImmediately = fireImmediately;
    };
    RateLimiter.prototype = {
      tokenBucket: null,
      curIntervalStart: 0,
      tokensThisInterval: 0,
      fireImmediately: false,
      /**
       * Remove the requested number of tokens and fire the given callback. If the
       * rate limiter contains enough tokens and we haven't spent too many tokens
       * in this interval already, this will happen immediately. Otherwise, the
       * removal and callback will happen when enough tokens become available.
       * @param {Number} count The number of tokens to remove.
       * @param {Function} callback(err, remainingTokens)
       * @returns {Boolean} True if the callback was fired immediately, otherwise
       *  false.
       */
      removeTokens: function(count, callback) {
        if (count > this.tokenBucket.bucketSize) {
          process.nextTick(callback.bind(
            null,
            "Requested tokens " + count + " exceeds maximum tokens per interval " + this.tokenBucket.bucketSize,
            null
          ));
          return false;
        }
        var self2 = this;
        var now = getMilliseconds();
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
          this.curIntervalStart = now;
          this.tokensThisInterval = 0;
        }
        if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval) {
          if (this.fireImmediately) {
            process.nextTick(callback.bind(null, null, -1));
          } else {
            var waitInterval = Math.ceil(
              this.curIntervalStart + this.tokenBucket.interval - now
            );
            setTimeout(function() {
              self2.tokenBucket.removeTokens(count, afterTokensRemoved);
            }, waitInterval);
          }
          return false;
        }
        return this.tokenBucket.removeTokens(count, afterTokensRemoved);
        function afterTokensRemoved(err, tokensRemaining) {
          if (err)
            return callback(err, null);
          self2.tokensThisInterval += count;
          callback(null, tokensRemaining);
        }
      },
      /**
       * Attempt to remove the requested number of tokens and return immediately.
       * If the bucket (and any parent buckets) contains enough tokens and we
       * haven't spent too many tokens in this interval already, this will return
       * true. Otherwise, false is returned.
       * @param {Number} count The number of tokens to remove.
       * @param {Boolean} True if the tokens were successfully removed, otherwise
       *  false.
       */
      tryRemoveTokens: function(count) {
        if (count > this.tokenBucket.bucketSize)
          return false;
        var now = getMilliseconds();
        if (now < this.curIntervalStart || now - this.curIntervalStart >= this.tokenBucket.interval) {
          this.curIntervalStart = now;
          this.tokensThisInterval = 0;
        }
        if (count > this.tokenBucket.tokensPerInterval - this.tokensThisInterval)
          return false;
        var removed = this.tokenBucket.tryRemoveTokens(count);
        if (removed) {
          this.tokensThisInterval += count;
        }
        return removed;
      },
      /**
       * Returns the number of tokens remaining in the TokenBucket.
       * @returns {Number} The number of tokens remaining.
       */
      getTokensRemaining: function() {
        this.tokenBucket.drip();
        return this.tokenBucket.content;
      }
    };
    module.exports = RateLimiter;
  }
});

// node_modules/limiter/index.js
var require_limiter = __commonJS({
  "node_modules/limiter/index.js"(exports) {
    exports.RateLimiter = require_rateLimiter();
    exports.TokenBucket = require_tokenBucket();
  }
});

// node_modules/jwks-rsa/src/errors/JwksRateLimitError.js
var require_JwksRateLimitError = __commonJS({
  "node_modules/jwks-rsa/src/errors/JwksRateLimitError.js"(exports, module) {
    function JwksRateLimitError(message2) {
      Error.call(this, message2);
      Error.captureStackTrace(this, this.constructor);
      this.name = "JwksRateLimitError";
      this.message = message2;
    }
    JwksRateLimitError.prototype = Object.create(Error.prototype);
    JwksRateLimitError.prototype.constructor = JwksRateLimitError;
    module.exports = JwksRateLimitError;
  }
});

// node_modules/jwks-rsa/src/wrappers/rateLimit.js
var require_rateLimit = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/rateLimit.js"(exports, module) {
    var logger = require_browser()("jwks");
    var { RateLimiter } = require_limiter();
    var JwksRateLimitError = require_JwksRateLimitError();
    function rateLimitWrapper(client, { jwksRequestsPerMinute = 10 }) {
      const getSigningKey = client.getSigningKey.bind(client);
      const limiter = new RateLimiter(jwksRequestsPerMinute, "minute", true);
      logger(`Configured rate limiting to JWKS endpoint at ${jwksRequestsPerMinute}/minute`);
      return async (kid) => await new Promise((resolve, reject) => {
        limiter.removeTokens(1, async (err, remaining) => {
          if (err) {
            reject(err);
          }
          logger("Requests to the JWKS endpoint available for the next minute:", remaining);
          if (remaining < 0) {
            logger("Too many requests to the JWKS endpoint");
            reject(new JwksRateLimitError("Too many requests to the JWKS endpoint"));
          } else {
            try {
              const key = await getSigningKey(kid);
              resolve(key);
            } catch (error) {
              reject(error);
            }
          }
        });
      });
    }
    module.exports.default = rateLimitWrapper;
  }
});

// node_modules/jwks-rsa/src/wrappers/interceptor.js
var require_interceptor = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/interceptor.js"(exports, module) {
    var retrieveSigningKeys = require_utils2().retrieveSigningKeys;
    function getKeysInterceptor(client, { getKeysInterceptor: getKeysInterceptor2 }) {
      const getSigningKey = client.getSigningKey.bind(client);
      return async (kid) => {
        const keys = await getKeysInterceptor2();
        let signingKeys;
        if (keys && keys.length) {
          signingKeys = await retrieveSigningKeys(keys);
        }
        if (signingKeys && signingKeys.length) {
          const key = signingKeys.find((k) => !kid || k.kid === kid);
          if (key) {
            return key;
          }
        }
        return getSigningKey(kid);
      };
    }
    module.exports.default = getKeysInterceptor;
  }
});

// node_modules/jwks-rsa/src/wrappers/callbackSupport.js
var require_callbackSupport = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/callbackSupport.js"(exports, module) {
    var { callbackify } = require_util();
    var callbackSupport = (client) => {
      const getSigningKey = client.getSigningKey.bind(client);
      return (kid, cb) => {
        if (cb) {
          const callbackFunc = callbackify(getSigningKey);
          return callbackFunc(kid, cb);
        }
        return getSigningKey(kid);
      };
    };
    module.exports.default = callbackSupport;
  }
});

// node_modules/jwks-rsa/src/wrappers/index.js
var require_wrappers = __commonJS({
  "node_modules/jwks-rsa/src/wrappers/index.js"(exports, module) {
    module.exports = {
      request: require_request().default,
      cacheSigningKey: require_cache().default,
      rateLimitSigningKey: require_rateLimit().default,
      getKeysInterceptor: require_interceptor().default,
      callbackSupport: require_callbackSupport().default
    };
  }
});

// node_modules/jwks-rsa/src/errors/SigningKeyNotFoundError.js
var require_SigningKeyNotFoundError = __commonJS({
  "node_modules/jwks-rsa/src/errors/SigningKeyNotFoundError.js"(exports, module) {
    function SigningKeyNotFoundError(message2) {
      Error.call(this, message2);
      Error.captureStackTrace(this, this.constructor);
      this.name = "SigningKeyNotFoundError";
      this.message = message2;
    }
    SigningKeyNotFoundError.prototype = Object.create(Error.prototype);
    SigningKeyNotFoundError.prototype.constructor = SigningKeyNotFoundError;
    module.exports = SigningKeyNotFoundError;
  }
});

// node_modules/jwks-rsa/src/JwksClient.js
var require_JwksClient = __commonJS({
  "node_modules/jwks-rsa/src/JwksClient.js"(exports, module) {
    var logger = require_browser()("jwks");
    var { retrieveSigningKeys } = require_utils2();
    var { request, cacheSigningKey, rateLimitSigningKey, getKeysInterceptor, callbackSupport } = require_wrappers();
    var JwksError = require_JwksError();
    var SigningKeyNotFoundError = require_SigningKeyNotFoundError();
    var JwksClient = class {
      constructor(options) {
        this.options = {
          rateLimit: false,
          cache: true,
          timeout: 3e4,
          ...options
        };
        if (this.options.getKeysInterceptor) {
          this.getSigningKey = getKeysInterceptor(this, options);
        }
        if (this.options.rateLimit) {
          this.getSigningKey = rateLimitSigningKey(this, options);
        }
        if (this.options.cache) {
          this.getSigningKey = cacheSigningKey(this, options);
        }
        this.getSigningKey = callbackSupport(this, options);
      }
      async getKeys() {
        logger(`Fetching keys from '${this.options.jwksUri}'`);
        try {
          const res = await request({
            uri: this.options.jwksUri,
            headers: this.options.requestHeaders,
            agent: this.options.requestAgent,
            timeout: this.options.timeout,
            fetcher: this.options.fetcher
          });
          logger("Keys:", res.keys);
          return res.keys;
        } catch (err) {
          const { errorMsg } = err;
          logger("Failure:", errorMsg || err);
          throw errorMsg ? new JwksError(errorMsg) : err;
        }
      }
      async getSigningKeys() {
        const keys = await this.getKeys();
        if (!keys || !keys.length) {
          throw new JwksError("The JWKS endpoint did not contain any keys");
        }
        const signingKeys = await retrieveSigningKeys(keys);
        if (!signingKeys.length) {
          throw new JwksError("The JWKS endpoint did not contain any signing keys");
        }
        logger("Signing Keys:", signingKeys);
        return signingKeys;
      }
      async getSigningKey(kid) {
        logger(`Fetching signing key for '${kid}'`);
        const keys = await this.getSigningKeys();
        const kidDefined = kid !== void 0 && kid !== null;
        if (!kidDefined && keys.length > 1) {
          logger("No KID specified and JWKS endpoint returned more than 1 key");
          throw new SigningKeyNotFoundError("No KID specified and JWKS endpoint returned more than 1 key");
        }
        const key = keys.find((k) => !kidDefined || k.kid === kid);
        if (key) {
          return key;
        } else {
          logger(`Unable to find a signing key that matches '${kid}'`);
          throw new SigningKeyNotFoundError(`Unable to find a signing key that matches '${kid}'`);
        }
      }
    };
    module.exports = {
      JwksClient
    };
  }
});

// node_modules/jwks-rsa/src/errors/ArgumentError.js
var require_ArgumentError = __commonJS({
  "node_modules/jwks-rsa/src/errors/ArgumentError.js"(exports, module) {
    function ArgumentError(message2) {
      Error.call(this, message2);
      Error.captureStackTrace(this, this.constructor);
      this.name = "ArgumentError";
      this.message = message2;
    }
    ArgumentError.prototype = Object.create(Error.prototype);
    ArgumentError.prototype.constructor = ArgumentError;
    module.exports = ArgumentError;
  }
});

// node_modules/jwks-rsa/src/errors/index.js
var require_errors = __commonJS({
  "node_modules/jwks-rsa/src/errors/index.js"(exports, module) {
    module.exports = {
      ArgumentError: require_ArgumentError(),
      JwksError: require_JwksError(),
      JwksRateLimitError: require_JwksRateLimitError(),
      SigningKeyNotFoundError: require_SigningKeyNotFoundError()
    };
  }
});

// node_modules/jwks-rsa/src/integrations/config.js
var require_config = __commonJS({
  "node_modules/jwks-rsa/src/integrations/config.js"(exports, module) {
    var allowedSignatureAlg = [
      "RS256",
      "RS384",
      "RS512",
      "PS256",
      "PS384",
      "PS512",
      "ES256",
      "ES256K",
      "ES384",
      "ES512",
      "EdDSA"
    ];
    module.exports = allowedSignatureAlg;
  }
});

// node_modules/jwks-rsa/src/integrations/hapi.js
var require_hapi = __commonJS({
  "node_modules/jwks-rsa/src/integrations/hapi.js"(exports, module) {
    var { ArgumentError } = require_errors();
    var { JwksClient } = require_JwksClient();
    var supportedAlg = require_config();
    var handleSigningKeyError = (err, cb) => {
      if (err && err.name === "SigningKeyNotFoundError") {
        return cb(err, null, null);
      }
      if (err) {
        return cb(err, null, null);
      }
    };
    module.exports.hapiJwt2KeyAsync = (options) => {
      const secretProvider = module.exports.hapiJwt2Key(options);
      return function(decoded) {
        return new Promise((resolve, reject) => {
          const cb = (err, key) => {
            !key || err ? reject(err) : resolve({ key });
          };
          secretProvider(decoded, cb);
        });
      };
    };
    module.exports.hapiJwt2Key = function(options) {
      if (options === null || options === void 0) {
        throw new ArgumentError("An options object must be provided when initializing hapiJwt2Key");
      }
      const client = new JwksClient(options);
      const onError = options.handleSigningKeyError || handleSigningKeyError;
      return function secretProvider(decoded, cb) {
        if (!decoded || !decoded.header) {
          return cb(new Error("Cannot find a signing certificate if there is no header"), null, null);
        }
        if (!supportedAlg.includes(decoded.header.alg)) {
          return cb(new Error("Unsupported algorithm " + decoded.header.alg + " supplied."), null, null);
        }
        client.getSigningKey(decoded.header.kid).then((key) => {
          return cb(null, key.publicKey || key.rsaPublicKey, key);
        }).catch((err) => {
          return onError(err, (newError) => cb(newError, null, null));
        });
      };
    };
  }
});

// node_modules/jwks-rsa/src/integrations/express.js
var require_express = __commonJS({
  "node_modules/jwks-rsa/src/integrations/express.js"(exports, module) {
    var { ArgumentError } = require_errors();
    var { JwksClient } = require_JwksClient();
    var supportedAlg = require_config();
    var handleSigningKeyError = (err, cb) => {
      if (err && err.name === "SigningKeyNotFoundError") {
        return cb(null);
      }
      if (err) {
        return cb(err);
      }
    };
    module.exports.expressJwtSecret = function(options) {
      if (options === null || options === void 0) {
        throw new ArgumentError("An options object must be provided when initializing expressJwtSecret");
      }
      const client = new JwksClient(options);
      const onError = options.handleSigningKeyError || handleSigningKeyError;
      const expressJwt7Provider = async (req, token) => {
        if (!token) {
          return;
        }
        const header = token.header;
        if (!header || !supportedAlg.includes(header.alg)) {
          return;
        }
        try {
          const key = await client.getSigningKey(header.kid);
          return key.publicKey || key.rsaPublicKey;
        } catch (err) {
          return new Promise((resolve, reject) => {
            onError(err, (newError) => {
              if (!newError) {
                return resolve();
              }
              reject(newError);
            });
          });
        }
      };
      return function secretProvider(req, header, payload, cb) {
        if (arguments.length === 4) {
          expressJwt7Provider(req, { header }).then((key) => {
            setImmediate(cb, null, key);
          }).catch((err) => {
            setImmediate(cb, err);
          });
          return;
        }
        return expressJwt7Provider(req, arguments[1]);
      };
    };
  }
});

// node_modules/jwks-rsa/src/integrations/koa.js
var require_koa = __commonJS({
  "node_modules/jwks-rsa/src/integrations/koa.js"(exports, module) {
    var { ArgumentError } = require_errors();
    var { JwksClient } = require_JwksClient();
    var supportedAlg = require_config();
    module.exports.koaJwtSecret = function(options = {}) {
      if (!options.jwksUri) {
        throw new ArgumentError("No JWKS provided. Please provide a jwksUri");
      }
      const client = new JwksClient(options);
      return function secretProvider({ alg, kid } = {}) {
        return new Promise((resolve, reject) => {
          if (!supportedAlg.includes(alg)) {
            return reject(new Error("Missing / invalid token algorithm"));
          }
          client.getSigningKey(kid).then((key) => {
            resolve(key.publicKey || key.rsaPublicKey);
          }).catch((err) => {
            if (options.handleSigningKeyError) {
              return options.handleSigningKeyError(err).then(reject);
            }
            return reject(err);
          });
        });
      };
    };
  }
});

// node_modules/jwks-rsa/src/integrations/passport.js
var require_passport = __commonJS({
  "node_modules/jwks-rsa/src/integrations/passport.js"(exports, module) {
    var jose = (init_browser(), __toCommonJS(browser_exports));
    var { ArgumentError } = require_errors();
    var { JwksClient } = require_JwksClient();
    var supportedAlg = require_config();
    var handleSigningKeyError = (err, cb) => {
      if (err && err.name === "SigningKeyNotFoundError") {
        return cb(null);
      }
      if (err) {
        return cb(err);
      }
    };
    module.exports.passportJwtSecret = function(options) {
      if (options === null || options === void 0) {
        throw new ArgumentError("An options object must be provided when initializing passportJwtSecret");
      }
      if (!options.jwksUri) {
        throw new ArgumentError("No JWKS provided. Please provide a jwksUri");
      }
      const client = new JwksClient(options);
      const onError = options.handleSigningKeyError || handleSigningKeyError;
      return function secretProvider(req, rawJwtToken, cb) {
        let decoded;
        try {
          decoded = {
            payload: jose.decodeJwt(rawJwtToken),
            header: jose.decodeProtectedHeader(rawJwtToken)
          };
        } catch (err) {
          decoded = null;
        }
        if (!decoded || !supportedAlg.includes(decoded.header.alg)) {
          return cb(null, null);
        }
        client.getSigningKey(decoded.header.kid).then((key) => {
          cb(null, key.publicKey || key.rsaPublicKey);
        }).catch((err) => {
          onError(err, (newError) => cb(newError, null));
        });
      };
    };
  }
});

// node_modules/jwks-rsa/src/index.js
var require_src = __commonJS({
  "node_modules/jwks-rsa/src/index.js"(exports, module) {
    var { JwksClient } = require_JwksClient();
    var errors = require_errors();
    var { hapiJwt2Key, hapiJwt2KeyAsync } = require_hapi();
    var { expressJwtSecret } = require_express();
    var { koaJwtSecret } = require_koa();
    var { passportJwtSecret } = require_passport();
    module.exports = (options) => {
      return new JwksClient(options);
    };
    module.exports.JwksClient = JwksClient;
    module.exports.ArgumentError = errors.ArgumentError;
    module.exports.JwksError = errors.JwksError;
    module.exports.JwksRateLimitError = errors.JwksRateLimitError;
    module.exports.SigningKeyNotFoundError = errors.SigningKeyNotFoundError;
    module.exports.expressJwtSecret = expressJwtSecret;
    module.exports.hapiJwt2Key = hapiJwt2Key;
    module.exports.hapiJwt2KeyAsync = hapiJwt2KeyAsync;
    module.exports.koaJwtSecret = koaJwtSecret;
    module.exports.passportJwtSecret = passportJwtSecret;
  }
});

// node_modules/firebase-admin/lib/utils/jwt.js
var require_jwt = __commonJS({
  "node_modules/firebase-admin/lib/utils/jwt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JwtErrorCode = exports.JwtError = exports.decodeJwt = exports.verifyJwtSignature = exports.EmulatorSignatureVerifier = exports.PublicKeySignatureVerifier = exports.UrlKeyFetcher = exports.JwksFetcher = exports.ALGORITHM_RS256 = void 0;
    var validator = require_validator();
    var jwt = require_jsonwebtoken();
    var jwks = require_src();
    var api_request_1 = require_api_request();
    exports.ALGORITHM_RS256 = "RS256";
    var JWT_CALLBACK_ERROR_PREFIX = "error in secret or public key callback: ";
    var NO_MATCHING_KID_ERROR_MESSAGE = "no-matching-kid-error";
    var NO_KID_IN_HEADER_ERROR_MESSAGE = "no-kid-in-header-error";
    var HOUR_IN_SECONDS = 3600;
    var JwksFetcher = class {
      constructor(jwksUrl) {
        this.publicKeysExpireAt = 0;
        if (!validator.isURL(jwksUrl)) {
          throw new Error("The provided JWKS URL is not a valid URL.");
        }
        this.client = jwks({
          jwksUri: jwksUrl,
          cache: false
          // disable jwks-rsa LRU cache as the keys are always cached for 6 hours.
        });
      }
      fetchPublicKeys() {
        if (this.shouldRefresh()) {
          return this.refresh();
        }
        return Promise.resolve(this.publicKeys);
      }
      shouldRefresh() {
        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();
      }
      refresh() {
        return this.client.getSigningKeys().then((signingKeys) => {
          this.publicKeysExpireAt = 0;
          const newKeys = signingKeys.reduce((map, signingKey) => {
            map[signingKey.kid] = signingKey.getPublicKey();
            return map;
          }, {});
          this.publicKeysExpireAt = Date.now() + HOUR_IN_SECONDS * 6 * 1e3;
          this.publicKeys = newKeys;
          return newKeys;
        }).catch((err) => {
          throw new Error(`Error fetching Json Web Keys: ${err.message}`);
        });
      }
    };
    exports.JwksFetcher = JwksFetcher;
    var UrlKeyFetcher = class {
      constructor(clientCertUrl, httpAgent) {
        this.clientCertUrl = clientCertUrl;
        this.httpAgent = httpAgent;
        this.publicKeysExpireAt = 0;
        if (!validator.isURL(clientCertUrl)) {
          throw new Error("The provided public client certificate URL is not a valid URL.");
        }
      }
      /**
       * Fetches the public keys for the Google certs.
       *
       * @returns A promise fulfilled with public keys for the Google certs.
       */
      fetchPublicKeys() {
        if (this.shouldRefresh()) {
          return this.refresh();
        }
        return Promise.resolve(this.publicKeys);
      }
      /**
       * Checks if the cached public keys need to be refreshed.
       *
       * @returns Whether the keys should be fetched from the client certs url or not.
       */
      shouldRefresh() {
        return !this.publicKeys || this.publicKeysExpireAt <= Date.now();
      }
      refresh() {
        const client = new api_request_1.HttpClient();
        const request = {
          method: "GET",
          url: this.clientCertUrl,
          httpAgent: this.httpAgent
        };
        return client.send(request).then((resp) => {
          if (!resp.isJson() || resp.data.error) {
            throw new api_request_1.HttpError(resp);
          }
          this.publicKeysExpireAt = 0;
          if (Object.prototype.hasOwnProperty.call(resp.headers, "cache-control")) {
            const cacheControlHeader = resp.headers["cache-control"];
            const parts = cacheControlHeader.split(",");
            parts.forEach((part) => {
              const subParts = part.trim().split("=");
              if (subParts[0] === "max-age") {
                const maxAge = +subParts[1];
                this.publicKeysExpireAt = Date.now() + maxAge * 1e3;
              }
            });
          }
          this.publicKeys = resp.data;
          return resp.data;
        }).catch((err) => {
          if (err instanceof api_request_1.HttpError) {
            let errorMessage = "Error fetching public keys for Google certs: ";
            const resp = err.response;
            if (resp.isJson() && resp.data.error) {
              errorMessage += `${resp.data.error}`;
              if (resp.data.error_description) {
                errorMessage += " (" + resp.data.error_description + ")";
              }
            } else {
              errorMessage += `${resp.text}`;
            }
            throw new Error(errorMessage);
          }
          throw err;
        });
      }
    };
    exports.UrlKeyFetcher = UrlKeyFetcher;
    var PublicKeySignatureVerifier = class _PublicKeySignatureVerifier {
      constructor(keyFetcher) {
        this.keyFetcher = keyFetcher;
        if (!validator.isNonNullObject(keyFetcher)) {
          throw new Error("The provided key fetcher is not an object or null.");
        }
      }
      static withCertificateUrl(clientCertUrl, httpAgent) {
        return new _PublicKeySignatureVerifier(new UrlKeyFetcher(clientCertUrl, httpAgent));
      }
      static withJwksUrl(jwksUrl) {
        return new _PublicKeySignatureVerifier(new JwksFetcher(jwksUrl));
      }
      verify(token) {
        if (!validator.isString(token)) {
          return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, "The provided token must be a string."));
        }
        return verifyJwtSignature(token, getKeyCallback(this.keyFetcher), { algorithms: [exports.ALGORITHM_RS256] }).catch((error) => {
          if (error.code === JwtErrorCode.NO_KID_IN_HEADER) {
            return this.verifyWithoutKid(token);
          }
          throw error;
        });
      }
      verifyWithoutKid(token) {
        return this.keyFetcher.fetchPublicKeys().then((publicKeys) => this.verifyWithAllKeys(token, publicKeys));
      }
      verifyWithAllKeys(token, keys) {
        const promises = [];
        Object.values(keys).forEach((key) => {
          const result = verifyJwtSignature(token, key).then(() => true).catch((error) => {
            if (error.code === JwtErrorCode.TOKEN_EXPIRED) {
              throw error;
            }
            return false;
          });
          promises.push(result);
        });
        return Promise.all(promises).then((result) => {
          if (result.every((r) => r === false)) {
            throw new JwtError(JwtErrorCode.INVALID_SIGNATURE, "Invalid token signature.");
          }
        });
      }
    };
    exports.PublicKeySignatureVerifier = PublicKeySignatureVerifier;
    var EmulatorSignatureVerifier = class {
      verify(token) {
        return verifyJwtSignature(token, void 0, { algorithms: ["none"] });
      }
    };
    exports.EmulatorSignatureVerifier = EmulatorSignatureVerifier;
    function getKeyCallback(fetcher) {
      return (header, callback) => {
        if (!header.kid) {
          callback(new Error(NO_KID_IN_HEADER_ERROR_MESSAGE));
        }
        const kid = header.kid || "";
        fetcher.fetchPublicKeys().then((publicKeys) => {
          if (!Object.prototype.hasOwnProperty.call(publicKeys, kid)) {
            callback(new Error(NO_MATCHING_KID_ERROR_MESSAGE));
          } else {
            callback(null, publicKeys[kid]);
          }
        }).catch((error) => {
          callback(error);
        });
      };
    }
    function verifyJwtSignature(token, secretOrPublicKey, options) {
      if (!validator.isString(token)) {
        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, "The provided token must be a string."));
      }
      return new Promise((resolve, reject) => {
        jwt.verify(token, secretOrPublicKey, options, (error) => {
          if (!error) {
            return resolve();
          }
          if (error.name === "TokenExpiredError") {
            return reject(new JwtError(JwtErrorCode.TOKEN_EXPIRED, "The provided token has expired. Get a fresh token from your client app and try again."));
          } else if (error.name === "JsonWebTokenError") {
            if (error.message && error.message.includes(JWT_CALLBACK_ERROR_PREFIX)) {
              const message2 = error.message.split(JWT_CALLBACK_ERROR_PREFIX).pop() || "Error fetching public keys.";
              let code = JwtErrorCode.KEY_FETCH_ERROR;
              if (message2 === NO_MATCHING_KID_ERROR_MESSAGE) {
                code = JwtErrorCode.NO_MATCHING_KID;
              } else if (message2 === NO_KID_IN_HEADER_ERROR_MESSAGE) {
                code = JwtErrorCode.NO_KID_IN_HEADER;
              }
              return reject(new JwtError(code, message2));
            }
          }
          return reject(new JwtError(JwtErrorCode.INVALID_SIGNATURE, error.message));
        });
      });
    }
    exports.verifyJwtSignature = verifyJwtSignature;
    function decodeJwt2(jwtToken) {
      if (!validator.isString(jwtToken)) {
        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, "The provided token must be a string."));
      }
      const fullDecodedToken = jwt.decode(jwtToken, {
        complete: true
      });
      if (!fullDecodedToken) {
        return Promise.reject(new JwtError(JwtErrorCode.INVALID_ARGUMENT, "Decoding token failed."));
      }
      const header = fullDecodedToken == null ? void 0 : fullDecodedToken.header;
      const payload = fullDecodedToken == null ? void 0 : fullDecodedToken.payload;
      return Promise.resolve({ header, payload });
    }
    exports.decodeJwt = decodeJwt2;
    var JwtError = class _JwtError extends Error {
      constructor(code, message2) {
        super(message2);
        this.code = code;
        this.message = message2;
        this.__proto__ = _JwtError.prototype;
      }
    };
    exports.JwtError = JwtError;
    var JwtErrorCode;
    (function(JwtErrorCode2) {
      JwtErrorCode2["INVALID_ARGUMENT"] = "invalid-argument";
      JwtErrorCode2["INVALID_CREDENTIAL"] = "invalid-credential";
      JwtErrorCode2["TOKEN_EXPIRED"] = "token-expired";
      JwtErrorCode2["INVALID_SIGNATURE"] = "invalid-token";
      JwtErrorCode2["NO_MATCHING_KID"] = "no-matching-kid-error";
      JwtErrorCode2["NO_KID_IN_HEADER"] = "no-kid-error";
      JwtErrorCode2["KEY_FETCH_ERROR"] = "key-fetch-error";
    })(JwtErrorCode = exports.JwtErrorCode || (exports.JwtErrorCode = {}));
  }
});

// node_modules/firebase-admin/lib/auth/token-verifier.js
var require_token_verifier = __commonJS({
  "node_modules/firebase-admin/lib/auth/token-verifier.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createSessionCookieVerifier = exports.createAuthBlockingTokenVerifier = exports.createIdTokenVerifier = exports.FirebaseTokenVerifier = exports.SESSION_COOKIE_INFO = exports.AUTH_BLOCKING_TOKEN_INFO = exports.ID_TOKEN_INFO = void 0;
    var error_1 = require_error();
    var util = require_utils();
    var validator = require_validator();
    var jwt_1 = require_jwt();
    var FIREBASE_AUDIENCE = "https://identitytoolkit.googleapis.com/google.identity.identitytoolkit.v1.IdentityToolkit";
    var CLIENT_CERT_URL = "https://www.googleapis.com/robot/v1/metadata/x509/securetoken@system.gserviceaccount.com";
    var SESSION_COOKIE_CERT_URL = "https://www.googleapis.com/identitytoolkit/v3/relyingparty/publicKeys";
    var EMULATOR_VERIFIER = new jwt_1.EmulatorSignatureVerifier();
    exports.ID_TOKEN_INFO = {
      url: "https://firebase.google.com/docs/auth/admin/verify-id-tokens",
      verifyApiName: "verifyIdToken()",
      jwtName: "Firebase ID token",
      shortName: "ID token",
      expiredErrorCode: error_1.AuthClientErrorCode.ID_TOKEN_EXPIRED
    };
    exports.AUTH_BLOCKING_TOKEN_INFO = {
      url: "https://cloud.google.com/identity-platform/docs/blocking-functions",
      verifyApiName: "_verifyAuthBlockingToken()",
      jwtName: "Firebase Auth Blocking token",
      shortName: "Auth Blocking token",
      expiredErrorCode: error_1.AuthClientErrorCode.AUTH_BLOCKING_TOKEN_EXPIRED
    };
    exports.SESSION_COOKIE_INFO = {
      url: "https://firebase.google.com/docs/auth/admin/manage-cookies",
      verifyApiName: "verifySessionCookie()",
      jwtName: "Firebase session cookie",
      shortName: "session cookie",
      expiredErrorCode: error_1.AuthClientErrorCode.SESSION_COOKIE_EXPIRED
    };
    var FirebaseTokenVerifier = class {
      constructor(clientCertUrl, issuer, tokenInfo, app) {
        this.issuer = issuer;
        this.tokenInfo = tokenInfo;
        this.app = app;
        if (!validator.isURL(clientCertUrl)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The provided public client certificate URL is an invalid URL.");
        } else if (!validator.isURL(issuer)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The provided JWT issuer is an invalid URL.");
        } else if (!validator.isNonNullObject(tokenInfo)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The provided JWT information is not an object or null.");
        } else if (!validator.isURL(tokenInfo.url)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The provided JWT verification documentation URL is invalid.");
        } else if (!validator.isNonEmptyString(tokenInfo.verifyApiName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT verify API name must be a non-empty string.");
        } else if (!validator.isNonEmptyString(tokenInfo.jwtName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT public full name must be a non-empty string.");
        } else if (!validator.isNonEmptyString(tokenInfo.shortName)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT public short name must be a non-empty string.");
        } else if (!validator.isNonNullObject(tokenInfo.expiredErrorCode) || !("code" in tokenInfo.expiredErrorCode)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "The JWT expiration error code must be a non-null ErrorInfo object.");
        }
        this.shortNameArticle = tokenInfo.shortName.charAt(0).match(/[aeiou]/i) ? "an" : "a";
        this.signatureVerifier = jwt_1.PublicKeySignatureVerifier.withCertificateUrl(clientCertUrl, app.options.httpAgent);
      }
      /**
       * Verifies the format and signature of a Firebase Auth JWT token.
       *
       * @param jwtToken - The Firebase Auth JWT token to verify.
       * @param isEmulator - Whether to accept Auth Emulator tokens.
       * @returns A promise fulfilled with the decoded claims of the Firebase Auth ID token.
       */
      verifyJWT(jwtToken, isEmulator = false) {
        if (!validator.isString(jwtToken)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `First argument to ${this.tokenInfo.verifyApiName} must be a ${this.tokenInfo.jwtName} string.`);
        }
        return this.ensureProjectId().then((projectId) => {
          return this.decodeAndVerify(jwtToken, projectId, isEmulator);
        }).then((decoded) => {
          const decodedIdToken = decoded.payload;
          decodedIdToken.uid = decodedIdToken.sub;
          return decodedIdToken;
        });
      }
      /** @alpha */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      _verifyAuthBlockingToken(jwtToken, isEmulator, audience) {
        if (!validator.isString(jwtToken)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, `First argument to ${this.tokenInfo.verifyApiName} must be a ${this.tokenInfo.jwtName} string.`);
        }
        return this.ensureProjectId().then((projectId) => {
          if (typeof audience === "undefined") {
            audience = `${projectId}.cloudfunctions.net/`;
          }
          return this.decodeAndVerify(jwtToken, projectId, isEmulator, audience);
        }).then((decoded) => {
          const decodedAuthBlockingToken = decoded.payload;
          decodedAuthBlockingToken.uid = decodedAuthBlockingToken.sub;
          return decodedAuthBlockingToken;
        });
      }
      ensureProjectId() {
        return util.findProjectId(this.app).then((projectId) => {
          if (!validator.isNonEmptyString(projectId)) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CREDENTIAL, `Must initialize app with a cert credential or set your Firebase project ID as the GOOGLE_CLOUD_PROJECT environment variable to call ${this.tokenInfo.verifyApiName}.`);
          }
          return Promise.resolve(projectId);
        });
      }
      decodeAndVerify(token, projectId, isEmulator, audience) {
        return this.safeDecode(token).then((decodedToken) => {
          this.verifyContent(decodedToken, projectId, isEmulator, audience);
          return this.verifySignature(token, isEmulator).then(() => decodedToken);
        });
      }
      safeDecode(jwtToken) {
        return (0, jwt_1.decodeJwt)(jwtToken).catch((err) => {
          if (err.code === jwt_1.JwtErrorCode.INVALID_ARGUMENT) {
            const verifyJwtTokenDocsMessage = ` See ${this.tokenInfo.url} for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`;
            const errorMessage = `Decoding ${this.tokenInfo.jwtName} failed. Make sure you passed the entire string JWT which represents ${this.shortNameArticle} ${this.tokenInfo.shortName}.` + verifyJwtTokenDocsMessage;
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
          }
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, err.message);
        });
      }
      /**
       * Verifies the content of a Firebase Auth JWT.
       *
       * @param fullDecodedToken - The decoded JWT.
       * @param projectId - The Firebase Project Id.
       * @param isEmulator - Whether the token is an Emulator token.
       */
      verifyContent(fullDecodedToken, projectId, isEmulator, audience) {
        const header = fullDecodedToken && fullDecodedToken.header;
        const payload = fullDecodedToken && fullDecodedToken.payload;
        const projectIdMatchMessage = ` Make sure the ${this.tokenInfo.shortName} comes from the same Firebase project as the service account used to authenticate this SDK.`;
        const verifyJwtTokenDocsMessage = ` See ${this.tokenInfo.url} for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`;
        let errorMessage;
        if (!isEmulator && typeof header.kid === "undefined") {
          const isCustomToken = payload.aud === FIREBASE_AUDIENCE;
          const isLegacyCustomToken = header.alg === "HS256" && payload.v === 0 && "d" in payload && "uid" in payload.d;
          if (isCustomToken) {
            errorMessage = `${this.tokenInfo.verifyApiName} expects ${this.shortNameArticle} ${this.tokenInfo.shortName}, but was given a custom token.`;
          } else if (isLegacyCustomToken) {
            errorMessage = `${this.tokenInfo.verifyApiName} expects ${this.shortNameArticle} ${this.tokenInfo.shortName}, but was given a legacy custom token.`;
          } else {
            errorMessage = `${this.tokenInfo.jwtName} has no "kid" claim.`;
          }
          errorMessage += verifyJwtTokenDocsMessage;
        } else if (!isEmulator && header.alg !== jwt_1.ALGORITHM_RS256) {
          errorMessage = `${this.tokenInfo.jwtName} has incorrect algorithm. Expected "` + jwt_1.ALGORITHM_RS256 + '" but got "' + header.alg + '".' + verifyJwtTokenDocsMessage;
        } else if (typeof audience !== "undefined" && !payload.aud.includes(audience)) {
          errorMessage = `${this.tokenInfo.jwtName} has incorrect "aud" (audience) claim. Expected "` + audience + '" but got "' + payload.aud + '".' + verifyJwtTokenDocsMessage;
        } else if (typeof audience === "undefined" && payload.aud !== projectId) {
          errorMessage = `${this.tokenInfo.jwtName} has incorrect "aud" (audience) claim. Expected "` + projectId + '" but got "' + payload.aud + '".' + projectIdMatchMessage + verifyJwtTokenDocsMessage;
        } else if (payload.iss !== this.issuer + projectId) {
          errorMessage = `${this.tokenInfo.jwtName} has incorrect "iss" (issuer) claim. Expected "${this.issuer}` + projectId + '" but got "' + payload.iss + '".' + projectIdMatchMessage + verifyJwtTokenDocsMessage;
        } else if (typeof payload.sub !== "string") {
          errorMessage = `${this.tokenInfo.jwtName} has no "sub" (subject) claim.` + verifyJwtTokenDocsMessage;
        } else if (payload.sub === "") {
          errorMessage = `${this.tokenInfo.jwtName} has an empty string "sub" (subject) claim.` + verifyJwtTokenDocsMessage;
        } else if (payload.sub.length > 128) {
          errorMessage = `${this.tokenInfo.jwtName} has "sub" (subject) claim longer than 128 characters.` + verifyJwtTokenDocsMessage;
        }
        if (errorMessage) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
        }
      }
      verifySignature(jwtToken, isEmulator) {
        const verifier = isEmulator ? EMULATOR_VERIFIER : this.signatureVerifier;
        return verifier.verify(jwtToken).catch((error) => {
          throw this.mapJwtErrorToAuthError(error);
        });
      }
      /**
       * Maps JwtError to FirebaseAuthError
       *
       * @param error - JwtError to be mapped.
       * @returns FirebaseAuthError or Error instance.
       */
      mapJwtErrorToAuthError(error) {
        const verifyJwtTokenDocsMessage = ` See ${this.tokenInfo.url} for details on how to retrieve ${this.shortNameArticle} ${this.tokenInfo.shortName}.`;
        if (error.code === jwt_1.JwtErrorCode.TOKEN_EXPIRED) {
          const errorMessage = `${this.tokenInfo.jwtName} has expired. Get a fresh ${this.tokenInfo.shortName} from your client app and try again (auth/${this.tokenInfo.expiredErrorCode.code}).` + verifyJwtTokenDocsMessage;
          return new error_1.FirebaseAuthError(this.tokenInfo.expiredErrorCode, errorMessage);
        } else if (error.code === jwt_1.JwtErrorCode.INVALID_SIGNATURE) {
          const errorMessage = `${this.tokenInfo.jwtName} has invalid signature.` + verifyJwtTokenDocsMessage;
          return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
        } else if (error.code === jwt_1.JwtErrorCode.NO_MATCHING_KID) {
          const errorMessage = `${this.tokenInfo.jwtName} has "kid" claim which does not correspond to a known public key. Most likely the ${this.tokenInfo.shortName} is expired, so get a fresh token from your client app and try again.`;
          return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, errorMessage);
        }
        return new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, error.message);
      }
    };
    exports.FirebaseTokenVerifier = FirebaseTokenVerifier;
    function createIdTokenVerifier(app) {
      return new FirebaseTokenVerifier(CLIENT_CERT_URL, "https://securetoken.google.com/", exports.ID_TOKEN_INFO, app);
    }
    exports.createIdTokenVerifier = createIdTokenVerifier;
    function createAuthBlockingTokenVerifier(app) {
      return new FirebaseTokenVerifier(CLIENT_CERT_URL, "https://securetoken.google.com/", exports.AUTH_BLOCKING_TOKEN_INFO, app);
    }
    exports.createAuthBlockingTokenVerifier = createAuthBlockingTokenVerifier;
    function createSessionCookieVerifier(app) {
      return new FirebaseTokenVerifier(SESSION_COOKIE_CERT_URL, "https://session.firebase.google.com/", exports.SESSION_COOKIE_INFO, app);
    }
    exports.createSessionCookieVerifier = createSessionCookieVerifier;
  }
});

// node_modules/firebase-admin/lib/auth/user-record.js
var require_user_record = __commonJS({
  "node_modules/firebase-admin/lib/auth/user-record.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserRecord = exports.UserInfo = exports.UserMetadata = exports.MultiFactorSettings = exports.TotpMultiFactorInfo = exports.TotpInfo = exports.PhoneMultiFactorInfo = exports.MultiFactorInfo = void 0;
    var deep_copy_1 = require_deep_copy();
    var validator_1 = require_validator();
    var utils = require_utils();
    var error_1 = require_error();
    var B64_REDACTED = Buffer.from("REDACTED").toString("base64");
    function parseDate(time) {
      try {
        const date = new Date(parseInt(time, 10));
        if (!isNaN(date.getTime())) {
          return date.toUTCString();
        }
      } catch (e) {
      }
      return null;
    }
    var MultiFactorId;
    (function(MultiFactorId2) {
      MultiFactorId2["Phone"] = "phone";
      MultiFactorId2["Totp"] = "totp";
    })(MultiFactorId || (MultiFactorId = {}));
    var MultiFactorInfo2 = class {
      /**
       * Initializes the MultiFactorInfo associated subclass using the server side.
       * If no MultiFactorInfo is associated with the response, null is returned.
       *
       * @param response - The server side response.
       * @internal
       */
      static initMultiFactorInfo(response) {
        let multiFactorInfo = null;
        try {
          if (response.phoneInfo !== void 0) {
            multiFactorInfo = new PhoneMultiFactorInfo2(response);
          } else if (response.totpInfo !== void 0) {
            multiFactorInfo = new TotpMultiFactorInfo(response);
          } else {
          }
        } catch (e) {
        }
        return multiFactorInfo;
      }
      /**
       * Initializes the MultiFactorInfo object using the server side response.
       *
       * @param response - The server side response.
       * @constructor
       * @internal
       */
      constructor(response) {
        this.initFromServerResponse(response);
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        return {
          uid: this.uid,
          displayName: this.displayName,
          factorId: this.factorId,
          enrollmentTime: this.enrollmentTime
        };
      }
      /**
       * Initializes the MultiFactorInfo object using the provided server response.
       *
       * @param response - The server side response.
       */
      initFromServerResponse(response) {
        const factorId = response && this.getFactorId(response);
        if (!factorId || !response || !response.mfaEnrollmentId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor info response");
        }
        utils.addReadonlyGetter(this, "uid", response.mfaEnrollmentId);
        utils.addReadonlyGetter(this, "factorId", factorId);
        utils.addReadonlyGetter(this, "displayName", response.displayName);
        if (response.enrolledAt) {
          utils.addReadonlyGetter(this, "enrollmentTime", new Date(response.enrolledAt).toUTCString());
        } else {
          utils.addReadonlyGetter(this, "enrollmentTime", null);
        }
      }
    };
    exports.MultiFactorInfo = MultiFactorInfo2;
    var PhoneMultiFactorInfo2 = class extends MultiFactorInfo2 {
      /**
       * Initializes the PhoneMultiFactorInfo object using the server side response.
       *
       * @param response - The server side response.
       * @constructor
       * @internal
       */
      constructor(response) {
        super(response);
        utils.addReadonlyGetter(this, "phoneNumber", response.phoneInfo);
      }
      /**
       * {@inheritdoc MultiFactorInfo.toJSON}
       */
      toJSON() {
        return Object.assign(super.toJSON(), {
          phoneNumber: this.phoneNumber
        });
      }
      /**
       * Returns the factor ID based on the response provided.
       *
       * @param response - The server side response.
       * @returns The multi-factor ID associated with the provided response. If the response is
       *     not associated with any known multi-factor ID, null is returned.
       *
       * @internal
       */
      getFactorId(response) {
        return response && response.phoneInfo ? MultiFactorId.Phone : null;
      }
    };
    exports.PhoneMultiFactorInfo = PhoneMultiFactorInfo2;
    var TotpInfo = class {
    };
    exports.TotpInfo = TotpInfo;
    var TotpMultiFactorInfo = class extends MultiFactorInfo2 {
      /**
       * Initializes the `TotpMultiFactorInfo` object using the server side response.
       *
       * @param response - The server side response.
       * @constructor
       * @internal
       */
      constructor(response) {
        super(response);
        utils.addReadonlyGetter(this, "totpInfo", response.totpInfo);
      }
      /**
       * {@inheritdoc MultiFactorInfo.toJSON}
       */
      toJSON() {
        return Object.assign(super.toJSON(), {
          totpInfo: this.totpInfo
        });
      }
      /**
       * Returns the factor ID based on the response provided.
       *
       * @param response - The server side response.
       * @returns The multi-factor ID associated with the provided response. If the response is
       *     not associated with any known multi-factor ID, `null` is returned.
       *
       * @internal
       */
      getFactorId(response) {
        return response && response.totpInfo ? MultiFactorId.Totp : null;
      }
    };
    exports.TotpMultiFactorInfo = TotpMultiFactorInfo;
    var MultiFactorSettings2 = class {
      /**
       * Initializes the `MultiFactor` object using the server side or JWT format response.
       *
       * @param response - The server side response.
       * @constructor
       * @internal
       */
      constructor(response) {
        const parsedEnrolledFactors = [];
        if (!(0, validator_1.isNonNullObject)(response)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid multi-factor response");
        } else if (response.mfaInfo) {
          response.mfaInfo.forEach((factorResponse) => {
            const multiFactorInfo = MultiFactorInfo2.initMultiFactorInfo(factorResponse);
            if (multiFactorInfo) {
              parsedEnrolledFactors.push(multiFactorInfo);
            }
          });
        }
        utils.addReadonlyGetter(this, "enrolledFactors", Object.freeze(parsedEnrolledFactors));
      }
      /**
       * Returns a JSON-serializable representation of this multi-factor object.
       *
       * @returns A JSON-serializable representation of this multi-factor object.
       */
      toJSON() {
        return {
          enrolledFactors: this.enrolledFactors.map((info) => info.toJSON())
        };
      }
    };
    exports.MultiFactorSettings = MultiFactorSettings2;
    var UserMetadata2 = class {
      /**
       * @param response - The server side response returned from the `getAccountInfo`
       *     endpoint.
       * @constructor
       * @internal
       */
      constructor(response) {
        utils.addReadonlyGetter(this, "creationTime", parseDate(response.createdAt));
        utils.addReadonlyGetter(this, "lastSignInTime", parseDate(response.lastLoginAt));
        const lastRefreshAt = response.lastRefreshAt ? new Date(response.lastRefreshAt).toUTCString() : null;
        utils.addReadonlyGetter(this, "lastRefreshTime", lastRefreshAt);
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        return {
          lastSignInTime: this.lastSignInTime,
          creationTime: this.creationTime,
          lastRefreshTime: this.lastRefreshTime
        };
      }
    };
    exports.UserMetadata = UserMetadata2;
    var UserInfo2 = class {
      /**
       * @param response - The server side response returned from the `getAccountInfo`
       *     endpoint.
       * @constructor
       * @internal
       */
      constructor(response) {
        if (!response.rawId || !response.providerId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid user info response");
        }
        utils.addReadonlyGetter(this, "uid", response.rawId);
        utils.addReadonlyGetter(this, "displayName", response.displayName);
        utils.addReadonlyGetter(this, "email", response.email);
        utils.addReadonlyGetter(this, "photoURL", response.photoUrl);
        utils.addReadonlyGetter(this, "providerId", response.providerId);
        utils.addReadonlyGetter(this, "phoneNumber", response.phoneNumber);
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        return {
          uid: this.uid,
          displayName: this.displayName,
          email: this.email,
          photoURL: this.photoURL,
          providerId: this.providerId,
          phoneNumber: this.phoneNumber
        };
      }
    };
    exports.UserInfo = UserInfo2;
    var UserRecord2 = class {
      /**
       * @param response - The server side response returned from the getAccountInfo
       *     endpoint.
       * @constructor
       * @internal
       */
      constructor(response) {
        if (!response.localId) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "INTERNAL ASSERT FAILED: Invalid user response");
        }
        utils.addReadonlyGetter(this, "uid", response.localId);
        utils.addReadonlyGetter(this, "email", response.email);
        utils.addReadonlyGetter(this, "emailVerified", !!response.emailVerified);
        utils.addReadonlyGetter(this, "displayName", response.displayName);
        utils.addReadonlyGetter(this, "photoURL", response.photoUrl);
        utils.addReadonlyGetter(this, "phoneNumber", response.phoneNumber);
        utils.addReadonlyGetter(this, "disabled", response.disabled || false);
        utils.addReadonlyGetter(this, "metadata", new UserMetadata2(response));
        const providerData = [];
        for (const entry of response.providerUserInfo || []) {
          providerData.push(new UserInfo2(entry));
        }
        utils.addReadonlyGetter(this, "providerData", providerData);
        if (response.passwordHash === B64_REDACTED) {
          utils.addReadonlyGetter(this, "passwordHash", void 0);
        } else {
          utils.addReadonlyGetter(this, "passwordHash", response.passwordHash);
        }
        utils.addReadonlyGetter(this, "passwordSalt", response.salt);
        if (response.customAttributes) {
          utils.addReadonlyGetter(this, "customClaims", JSON.parse(response.customAttributes));
        }
        let validAfterTime = null;
        if (typeof response.validSince !== "undefined") {
          validAfterTime = parseDate(parseInt(response.validSince, 10) * 1e3);
        }
        utils.addReadonlyGetter(this, "tokensValidAfterTime", validAfterTime || void 0);
        utils.addReadonlyGetter(this, "tenantId", response.tenantId);
        const multiFactor = new MultiFactorSettings2(response);
        if (multiFactor.enrolledFactors.length > 0) {
          utils.addReadonlyGetter(this, "multiFactor", multiFactor);
        }
      }
      /**
       * Returns a JSON-serializable representation of this object.
       *
       * @returns A JSON-serializable representation of this object.
       */
      toJSON() {
        const json = {
          uid: this.uid,
          email: this.email,
          emailVerified: this.emailVerified,
          displayName: this.displayName,
          photoURL: this.photoURL,
          phoneNumber: this.phoneNumber,
          disabled: this.disabled,
          // Convert metadata to json.
          metadata: this.metadata.toJSON(),
          passwordHash: this.passwordHash,
          passwordSalt: this.passwordSalt,
          customClaims: (0, deep_copy_1.deepCopy)(this.customClaims),
          tokensValidAfterTime: this.tokensValidAfterTime,
          tenantId: this.tenantId
        };
        if (this.multiFactor) {
          json.multiFactor = this.multiFactor.toJSON();
        }
        json.providerData = [];
        for (const entry of this.providerData) {
          json.providerData.push(entry.toJSON());
        }
        return json;
      }
    };
    exports.UserRecord = UserRecord2;
  }
});

// node_modules/firebase-admin/lib/auth/base-auth.js
var require_base_auth = __commonJS({
  "node_modules/firebase-admin/lib/auth/base-auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseAuth = exports.createFirebaseTokenGenerator = void 0;
    var error_1 = require_error();
    var deep_copy_1 = require_deep_copy();
    var validator = require_validator();
    var auth_api_request_1 = require_auth_api_request();
    var token_generator_1 = require_token_generator();
    var token_verifier_1 = require_token_verifier();
    var auth_config_1 = require_auth_config();
    var user_record_1 = require_user_record();
    var identifier_1 = require_identifier();
    var crypto_signer_1 = require_crypto_signer();
    function createFirebaseTokenGenerator(app, tenantId) {
      try {
        const signer = (0, auth_api_request_1.useEmulator)() ? new token_generator_1.EmulatedSigner() : (0, crypto_signer_1.cryptoSignerFromApp)(app);
        return new token_generator_1.FirebaseTokenGenerator(signer, tenantId);
      } catch (err) {
        throw (0, token_generator_1.handleCryptoSignerError)(err);
      }
    }
    exports.createFirebaseTokenGenerator = createFirebaseTokenGenerator;
    var BaseAuth2 = class {
      /**
       * The BaseAuth class constructor.
       *
       * @param app - The FirebaseApp to associate with this Auth instance.
       * @param authRequestHandler - The RPC request handler for this instance.
       * @param tokenGenerator - Optional token generator. If not specified, a
       *     (non-tenant-aware) instance will be created. Use this paramter to
       *     specify a tenant-aware tokenGenerator.
       * @constructor
       * @internal
       */
      constructor(app, authRequestHandler, tokenGenerator) {
        this.authRequestHandler = authRequestHandler;
        if (tokenGenerator) {
          this.tokenGenerator = tokenGenerator;
        } else {
          this.tokenGenerator = createFirebaseTokenGenerator(app);
        }
        this.sessionCookieVerifier = (0, token_verifier_1.createSessionCookieVerifier)(app);
        this.idTokenVerifier = (0, token_verifier_1.createIdTokenVerifier)(app);
        this.authBlockingTokenVerifier = (0, token_verifier_1.createAuthBlockingTokenVerifier)(app);
      }
      /**
       * Creates a new Firebase custom token (JWT) that can be sent back to a client
       * device to use to sign in with the client SDKs' `signInWithCustomToken()`
       * methods. (Tenant-aware instances will also embed the tenant ID in the
       * token.)
       *
       * See {@link https://firebase.google.com/docs/auth/admin/create-custom-tokens | Create Custom Tokens}
       * for code samples and detailed documentation.
       *
       * @param uid - The `uid` to use as the custom token's subject.
       * @param developerClaims - Optional additional claims to include
       *   in the custom token's payload.
       *
       * @returns A promise fulfilled with a custom token for the
       *   provided `uid` and payload.
       */
      createCustomToken(uid, developerClaims) {
        return this.tokenGenerator.createCustomToken(uid, developerClaims);
      }
      /**
       * Verifies a Firebase ID token (JWT). If the token is valid, the promise is
       * fulfilled with the token's decoded claims; otherwise, the promise is
       * rejected.
       *
       * If `checkRevoked` is set to true, first verifies whether the corresponding
       * user is disabled. If yes, an `auth/user-disabled` error is thrown. If no,
       * verifies if the session corresponding to the ID token was revoked. If the
       * corresponding user's session was invalidated, an `auth/id-token-revoked`
       * error is thrown. If not specified the check is not applied.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/verify-id-tokens | Verify ID Tokens}
       * for code samples and detailed documentation.
       *
       * @param idToken - The ID token to verify.
       * @param checkRevoked - Whether to check if the ID token was revoked.
       *   This requires an extra request to the Firebase Auth backend to check
       *   the `tokensValidAfterTime` time for the corresponding user.
       *   When not specified, this additional check is not applied.
       *
       * @returns A promise fulfilled with the
       *   token's decoded claims if the ID token is valid; otherwise, a rejected
       *   promise.
       */
      verifyIdToken(idToken, checkRevoked = false) {
        const isEmulator = (0, auth_api_request_1.useEmulator)();
        return this.idTokenVerifier.verifyJWT(idToken, isEmulator).then((decodedIdToken) => {
          if (checkRevoked || isEmulator) {
            return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.ID_TOKEN_REVOKED);
          }
          return decodedIdToken;
        });
      }
      /**
       * Gets the user data for the user corresponding to a given `uid`.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
       * for code samples and detailed documentation.
       *
       * @param uid - The `uid` corresponding to the user whose data to fetch.
       *
       * @returns A promise fulfilled with the user
       *   data corresponding to the provided `uid`.
       */
      getUser(uid) {
        return this.authRequestHandler.getAccountInfoByUid(uid).then((response) => {
          return new user_record_1.UserRecord(response.users[0]);
        });
      }
      /**
       * Gets the user data for the user corresponding to a given email.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
       * for code samples and detailed documentation.
       *
       * @param email - The email corresponding to the user whose data to
       *   fetch.
       *
       * @returns A promise fulfilled with the user
       *   data corresponding to the provided email.
       */
      getUserByEmail(email) {
        return this.authRequestHandler.getAccountInfoByEmail(email).then((response) => {
          return new user_record_1.UserRecord(response.users[0]);
        });
      }
      /**
       * Gets the user data for the user corresponding to a given phone number. The
       * phone number has to conform to the E.164 specification.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
       * for code samples and detailed documentation.
       *
       * @param phoneNumber - The phone number corresponding to the user whose
       *   data to fetch.
       *
       * @returns A promise fulfilled with the user
       *   data corresponding to the provided phone number.
       */
      getUserByPhoneNumber(phoneNumber) {
        return this.authRequestHandler.getAccountInfoByPhoneNumber(phoneNumber).then((response) => {
          return new user_record_1.UserRecord(response.users[0]);
        });
      }
      /**
       * Gets the user data for the user corresponding to a given provider id.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#retrieve_user_data | Retrieve user data}
       * for code samples and detailed documentation.
       *
       * @param providerId - The provider ID, for example, "google.com" for the
       *   Google provider.
       * @param uid - The user identifier for the given provider.
       *
       * @returns A promise fulfilled with the user data corresponding to the
       *   given provider id.
       */
      getUserByProviderUid(providerId, uid) {
        if (providerId === "phone") {
          return this.getUserByPhoneNumber(uid);
        } else if (providerId === "email") {
          return this.getUserByEmail(uid);
        }
        return this.authRequestHandler.getAccountInfoByFederatedUid(providerId, uid).then((response) => {
          return new user_record_1.UserRecord(response.users[0]);
        });
      }
      /**
       * Gets the user data corresponding to the specified identifiers.
       *
       * There are no ordering guarantees; in particular, the nth entry in the result list is not
       * guaranteed to correspond to the nth entry in the input parameters list.
       *
       * Only a maximum of 100 identifiers may be supplied. If more than 100 identifiers are supplied,
       * this method throws a FirebaseAuthError.
       *
       * @param identifiers - The identifiers used to indicate which user records should be returned.
       *     Must not have more than 100 entries.
       * @returns A promise that resolves to the corresponding user records.
       * @throws FirebaseAuthError If any of the identifiers are invalid or if more than 100
       *     identifiers are specified.
       */
      getUsers(identifiers) {
        if (!validator.isArray(identifiers)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`identifiers` parameter must be an array");
        }
        return this.authRequestHandler.getAccountInfoByIdentifiers(identifiers).then((response) => {
          const isUserFound = (id, userRecords) => {
            return !!userRecords.find((userRecord) => {
              if ((0, identifier_1.isUidIdentifier)(id)) {
                return id.uid === userRecord.uid;
              } else if ((0, identifier_1.isEmailIdentifier)(id)) {
                return id.email === userRecord.email;
              } else if ((0, identifier_1.isPhoneIdentifier)(id)) {
                return id.phoneNumber === userRecord.phoneNumber;
              } else if ((0, identifier_1.isProviderIdentifier)(id)) {
                const matchingUserInfo = userRecord.providerData.find((userInfo) => {
                  return id.providerId === userInfo.providerId;
                });
                return !!matchingUserInfo && id.providerUid === matchingUserInfo.uid;
              } else {
                throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "Unhandled identifier type");
              }
            });
          };
          const users = response.users ? response.users.map((user) => new user_record_1.UserRecord(user)) : [];
          const notFound = identifiers.filter((id) => !isUserFound(id, users));
          return { users, notFound };
        });
      }
      /**
       * Retrieves a list of users (single batch only) with a size of `maxResults`
       * starting from the offset as specified by `pageToken`. This is used to
       * retrieve all the users of a specified project in batches.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#list_all_users | List all users}
       * for code samples and detailed documentation.
       *
       * @param maxResults - The page size, 1000 if undefined. This is also
       *   the maximum allowed limit.
       * @param pageToken - The next page token. If not specified, returns
       *   users starting without any offset.
       * @returns A promise that resolves with
       *   the current batch of downloaded users and the next page token.
       */
      listUsers(maxResults, pageToken) {
        return this.authRequestHandler.downloadAccount(maxResults, pageToken).then((response) => {
          const users = [];
          response.users.forEach((userResponse) => {
            users.push(new user_record_1.UserRecord(userResponse));
          });
          const result = {
            users,
            pageToken: response.nextPageToken
          };
          if (typeof result.pageToken === "undefined") {
            delete result.pageToken;
          }
          return result;
        });
      }
      /**
       * Creates a new user.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#create_a_user | Create a user}
       * for code samples and detailed documentation.
       *
       * @param properties - The properties to set on the
       *   new user record to be created.
       *
       * @returns A promise fulfilled with the user
       *   data corresponding to the newly created user.
       */
      createUser(properties) {
        return this.authRequestHandler.createNewAccount(properties).then((uid) => {
          return this.getUser(uid);
        }).catch((error) => {
          if (error.code === "auth/user-not-found") {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "Unable to create the user record provided.");
          }
          throw error;
        });
      }
      /**
       * Deletes an existing user.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#delete_a_user | Delete a user}
       * for code samples and detailed documentation.
       *
       * @param uid - The `uid` corresponding to the user to delete.
       *
       * @returns An empty promise fulfilled once the user has been
       *   deleted.
       */
      deleteUser(uid) {
        return this.authRequestHandler.deleteAccount(uid).then(() => {
        });
      }
      /**
       * Deletes the users specified by the given uids.
       *
       * Deleting a non-existing user won't generate an error (i.e. this method
       * is idempotent.) Non-existing users are considered to be successfully
       * deleted, and are therefore counted in the
       * `DeleteUsersResult.successCount` value.
       *
       * Only a maximum of 1000 identifiers may be supplied. If more than 1000
       * identifiers are supplied, this method throws a FirebaseAuthError.
       *
       * This API is currently rate limited at the server to 1 QPS. If you exceed
       * this, you may get a quota exceeded error. Therefore, if you want to
       * delete more than 1000 users, you may need to add a delay to ensure you
       * don't go over this limit.
       *
       * @param uids - The `uids` corresponding to the users to delete.
       *
       * @returns A Promise that resolves to the total number of successful/failed
       *     deletions, as well as the array of errors that corresponds to the
       *     failed deletions.
       */
      deleteUsers(uids) {
        if (!validator.isArray(uids)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "`uids` parameter must be an array");
        }
        return this.authRequestHandler.deleteAccounts(
          uids,
          /*force=*/
          true
        ).then((batchDeleteAccountsResponse) => {
          const result = {
            failureCount: 0,
            successCount: uids.length,
            errors: []
          };
          if (!validator.isNonEmptyArray(batchDeleteAccountsResponse.errors)) {
            return result;
          }
          result.failureCount = batchDeleteAccountsResponse.errors.length;
          result.successCount = uids.length - batchDeleteAccountsResponse.errors.length;
          result.errors = batchDeleteAccountsResponse.errors.map((batchDeleteErrorInfo) => {
            if (batchDeleteErrorInfo.index === void 0) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INTERNAL_ERROR, "Corrupt BatchDeleteAccountsResponse detected");
            }
            const errMsgToError = (msg) => {
              const code = msg && msg.startsWith("NOT_DISABLED") ? error_1.AuthClientErrorCode.USER_NOT_DISABLED : error_1.AuthClientErrorCode.INTERNAL_ERROR;
              return new error_1.FirebaseAuthError(code, batchDeleteErrorInfo.message);
            };
            return {
              index: batchDeleteErrorInfo.index,
              error: errMsgToError(batchDeleteErrorInfo.message)
            };
          });
          return result;
        });
      }
      /**
       * Updates an existing user.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-users#update_a_user | Update a user}
       * for code samples and detailed documentation.
       *
       * @param uid - The `uid` corresponding to the user to update.
       * @param properties - The properties to update on
       *   the provided user.
       *
       * @returns A promise fulfilled with the
       *   updated user data.
       */
      updateUser(uid, properties) {
        properties = (0, deep_copy_1.deepCopy)(properties);
        if (properties == null ? void 0 : properties.providerToLink) {
          if (properties.providerToLink.providerId === "email") {
            if (typeof properties.email !== "undefined") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.email and UpdateRequest.providerToLink.providerId='email' were set. To link to the email/password provider, only specify the UpdateRequest.email field.");
            }
            properties.email = properties.providerToLink.uid;
            delete properties.providerToLink;
          } else if (properties.providerToLink.providerId === "phone") {
            if (typeof properties.phoneNumber !== "undefined") {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.phoneNumber and UpdateRequest.providerToLink.providerId='phone' were set. To link to a phone provider, only specify the UpdateRequest.phoneNumber field.");
            }
            properties.phoneNumber = properties.providerToLink.uid;
            delete properties.providerToLink;
          }
        }
        if (properties == null ? void 0 : properties.providersToUnlink) {
          if (properties.providersToUnlink.indexOf("phone") !== -1) {
            if (properties.phoneNumber === null) {
              throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, "Both UpdateRequest.phoneNumber=null and UpdateRequest.providersToUnlink=['phone'] were set. To unlink from a phone provider, only specify the UpdateRequest.phoneNumber=null field.");
            }
          }
        }
        return this.authRequestHandler.updateExistingAccount(uid, properties).then((existingUid) => {
          return this.getUser(existingUid);
        });
      }
      /**
       * Sets additional developer claims on an existing user identified by the
       * provided `uid`, typically used to define user roles and levels of
       * access. These claims should propagate to all devices where the user is
       * already signed in (after token expiration or when token refresh is forced)
       * and the next time the user signs in. If a reserved OIDC claim name
       * is used (sub, iat, iss, etc), an error is thrown. They are set on the
       * authenticated user's ID token JWT.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/custom-claims |
       * Defining user roles and access levels}
       * for code samples and detailed documentation.
       *
       * @param uid - The `uid` of the user to edit.
       * @param customUserClaims - The developer claims to set. If null is
       *   passed, existing custom claims are deleted. Passing a custom claims payload
       *   larger than 1000 bytes will throw an error. Custom claims are added to the
       *   user's ID token which is transmitted on every authenticated request.
       *   For profile non-access related user attributes, use database or other
       *   separate storage systems.
       * @returns A promise that resolves when the operation completes
       *   successfully.
       */
      setCustomUserClaims(uid, customUserClaims) {
        return this.authRequestHandler.setCustomUserClaims(uid, customUserClaims).then(() => {
        });
      }
      /**
       * Revokes all refresh tokens for an existing user.
       *
       * This API will update the user's {@link UserRecord.tokensValidAfterTime} to
       * the current UTC. It is important that the server on which this is called has
       * its clock set correctly and synchronized.
       *
       * While this will revoke all sessions for a specified user and disable any
       * new ID tokens for existing sessions from getting minted, existing ID tokens
       * may remain active until their natural expiration (one hour). To verify that
       * ID tokens are revoked, use {@link BaseAuth.verifyIdToken}
       * where `checkRevoked` is set to true.
       *
       * @param uid - The `uid` corresponding to the user whose refresh tokens
       *   are to be revoked.
       *
       * @returns An empty promise fulfilled once the user's refresh
       *   tokens have been revoked.
       */
      revokeRefreshTokens(uid) {
        return this.authRequestHandler.revokeRefreshTokens(uid).then(() => {
        });
      }
      /**
       * Imports the provided list of users into Firebase Auth.
       * A maximum of 1000 users are allowed to be imported one at a time.
       * When importing users with passwords,
       * {@link UserImportOptions} are required to be
       * specified.
       * This operation is optimized for bulk imports and will ignore checks on `uid`,
       * `email` and other identifier uniqueness which could result in duplications.
       *
       * @param users - The list of user records to import to Firebase Auth.
       * @param options - The user import options, required when the users provided include
       *   password credentials.
       * @returns A promise that resolves when
       *   the operation completes with the result of the import. This includes the
       *   number of successful imports, the number of failed imports and their
       *   corresponding errors.
      */
      importUsers(users, options) {
        return this.authRequestHandler.uploadAccount(users, options);
      }
      /**
       * Creates a new Firebase session cookie with the specified options. The created
       * JWT string can be set as a server-side session cookie with a custom cookie
       * policy, and be used for session management. The session cookie JWT will have
       * the same payload claims as the provided ID token.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies | Manage Session Cookies}
       * for code samples and detailed documentation.
       *
       * @param idToken - The Firebase ID token to exchange for a session
       *   cookie.
       * @param sessionCookieOptions - The session
       *   cookie options which includes custom session duration.
       *
       * @returns A promise that resolves on success with the
       *   created session cookie.
       */
      createSessionCookie(idToken, sessionCookieOptions) {
        if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));
        }
        return this.authRequestHandler.createSessionCookie(idToken, sessionCookieOptions.expiresIn);
      }
      /**
       * Verifies a Firebase session cookie. Returns a Promise with the cookie claims.
       * Rejects the promise if the cookie could not be verified.
       *
       * If `checkRevoked` is set to true, first verifies whether the corresponding
       * user is disabled: If yes, an `auth/user-disabled` error is thrown. If no,
       * verifies if the session corresponding to the session cookie was revoked.
       * If the corresponding user's session was invalidated, an
       * `auth/session-cookie-revoked` error is thrown. If not specified the check
       * is not performed.
       *
       * See {@link https://firebase.google.com/docs/auth/admin/manage-cookies#verify_session_cookie_and_check_permissions |
       * Verify Session Cookies}
       * for code samples and detailed documentation
       *
       * @param sessionCookie - The session cookie to verify.
       * @param checkForRevocation -  Whether to check if the session cookie was
       *   revoked. This requires an extra request to the Firebase Auth backend to
       *   check the `tokensValidAfterTime` time for the corresponding user.
       *   When not specified, this additional check is not performed.
       *
       * @returns A promise fulfilled with the
       *   session cookie's decoded claims if the session cookie is valid; otherwise,
       *   a rejected promise.
       */
      verifySessionCookie(sessionCookie, checkRevoked = false) {
        const isEmulator = (0, auth_api_request_1.useEmulator)();
        return this.sessionCookieVerifier.verifyJWT(sessionCookie, isEmulator).then((decodedIdToken) => {
          if (checkRevoked || isEmulator) {
            return this.verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, error_1.AuthClientErrorCode.SESSION_COOKIE_REVOKED);
          }
          return decodedIdToken;
        });
      }
      /**
       * Generates the out of band email action link to reset a user's password.
       * The link is generated for the user with the specified email address. The
       * optional  {@link ActionCodeSettings} object
       * defines whether the link is to be handled by a mobile app or browser and the
       * additional state information to be passed in the deep link, etc.
       *
       * @example
       * ```javascript
       * var actionCodeSettings = {
       *   url: 'https://www.example.com/?email=user@example.com',
       *   iOS: {
       *     bundleId: 'com.example.ios'
       *   },
       *   android: {
       *     packageName: 'com.example.android',
       *     installApp: true,
       *     minimumVersion: '12'
       *   },
       *   handleCodeInApp: true,
       *   dynamicLinkDomain: 'custom.page.link'
       * };
       * admin.auth()
       *     .generatePasswordResetLink('user@example.com', actionCodeSettings)
       *     .then(function(link) {
       *       // The link was successfully generated.
       *     })
       *     .catch(function(error) {
       *       // Some error occurred, you can inspect the code: error.code
       *     });
       * ```
       *
       * @param email - The email address of the user whose password is to be
       *   reset.
       * @param actionCodeSettings - The action
       *     code settings. If specified, the state/continue URL is set as the
       *     "continueUrl" parameter in the password reset link. The default password
       *     reset landing page will use this to display a link to go back to the app
       *     if it is installed.
       *     If the actionCodeSettings is not specified, no URL is appended to the
       *     action URL.
       *     The state URL provided must belong to a domain that is whitelisted by the
       *     developer in the console. Otherwise an error is thrown.
       *     Mobile app redirects are only applicable if the developer configures
       *     and accepts the Firebase Dynamic Links terms of service.
       *     The Android package name and iOS bundle ID are respected only if they
       *     are configured in the same Firebase Auth project.
       * @returns A promise that resolves with the generated link.
       */
      generatePasswordResetLink(email, actionCodeSettings) {
        return this.authRequestHandler.getEmailActionLink("PASSWORD_RESET", email, actionCodeSettings);
      }
      /**
       * Generates the out of band email action link to verify the user's ownership
       * of the specified email. The {@link ActionCodeSettings} object provided
       * as an argument to this method defines whether the link is to be handled by a
       * mobile app or browser along with additional state information to be passed in
       * the deep link, etc.
       *
       * @example
       * ```javascript
       * var actionCodeSettings = {
       *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',
       *   iOS: {
       *     bundleId: 'com.example.ios'
       *   },
       *   android: {
       *     packageName: 'com.example.android',
       *     installApp: true,
       *     minimumVersion: '12'
       *   },
       *   handleCodeInApp: true,
       *   dynamicLinkDomain: 'custom.page.link'
       * };
       * admin.auth()
       *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)
       *     .then(function(link) {
       *       // The link was successfully generated.
       *     })
       *     .catch(function(error) {
       *       // Some error occurred, you can inspect the code: error.code
       *     });
       * ```
       *
       * @param email - The email account to verify.
       * @param actionCodeSettings - The action
       *     code settings. If specified, the state/continue URL is set as the
       *     "continueUrl" parameter in the email verification link. The default email
       *     verification landing page will use this to display a link to go back to
       *     the app if it is installed.
       *     If the actionCodeSettings is not specified, no URL is appended to the
       *     action URL.
       *     The state URL provided must belong to a domain that is whitelisted by the
       *     developer in the console. Otherwise an error is thrown.
       *     Mobile app redirects are only applicable if the developer configures
       *     and accepts the Firebase Dynamic Links terms of service.
       *     The Android package name and iOS bundle ID are respected only if they
       *     are configured in the same Firebase Auth project.
       * @returns A promise that resolves with the generated link.
       */
      generateEmailVerificationLink(email, actionCodeSettings) {
        return this.authRequestHandler.getEmailActionLink("VERIFY_EMAIL", email, actionCodeSettings);
      }
      /**
       * Generates an out-of-band email action link to verify the user's ownership
       * of the specified email. The {@link ActionCodeSettings} object provided
       * as an argument to this method defines whether the link is to be handled by a
       * mobile app or browser along with additional state information to be passed in
       * the deep link, etc.
       *
       * @param email - The current email account.
       * @param newEmail - The email address the account is being updated to.
       * @param actionCodeSettings - The action
       *     code settings. If specified, the state/continue URL is set as the
       *     "continueUrl" parameter in the email verification link. The default email
       *     verification landing page will use this to display a link to go back to
       *     the app if it is installed.
       *     If the actionCodeSettings is not specified, no URL is appended to the
       *     action URL.
       *     The state URL provided must belong to a domain that is authorized
       *     in the console, or an error will be thrown.
       *     Mobile app redirects are only applicable if the developer configures
       *     and accepts the Firebase Dynamic Links terms of service.
       *     The Android package name and iOS bundle ID are respected only if they
       *     are configured in the same Firebase Auth project.
       * @returns A promise that resolves with the generated link.
       */
      generateVerifyAndChangeEmailLink(email, newEmail, actionCodeSettings) {
        return this.authRequestHandler.getEmailActionLink("VERIFY_AND_CHANGE_EMAIL", email, actionCodeSettings, newEmail);
      }
      /**
       * Generates the out of band email action link to verify the user's ownership
       * of the specified email. The {@link ActionCodeSettings} object provided
       * as an argument to this method defines whether the link is to be handled by a
       * mobile app or browser along with additional state information to be passed in
       * the deep link, etc.
       *
       * @example
       * ```javascript
       * var actionCodeSettings = {
       *   url: 'https://www.example.com/cart?email=user@example.com&cartId=123',
       *   iOS: {
       *     bundleId: 'com.example.ios'
       *   },
       *   android: {
       *     packageName: 'com.example.android',
       *     installApp: true,
       *     minimumVersion: '12'
       *   },
       *   handleCodeInApp: true,
       *   dynamicLinkDomain: 'custom.page.link'
       * };
       * admin.auth()
       *     .generateEmailVerificationLink('user@example.com', actionCodeSettings)
       *     .then(function(link) {
       *       // The link was successfully generated.
       *     })
       *     .catch(function(error) {
       *       // Some error occurred, you can inspect the code: error.code
       *     });
       * ```
       *
       * @param email - The email account to verify.
       * @param actionCodeSettings - The action
       *     code settings. If specified, the state/continue URL is set as the
       *     "continueUrl" parameter in the email verification link. The default email
       *     verification landing page will use this to display a link to go back to
       *     the app if it is installed.
       *     If the actionCodeSettings is not specified, no URL is appended to the
       *     action URL.
       *     The state URL provided must belong to a domain that is whitelisted by the
       *     developer in the console. Otherwise an error is thrown.
       *     Mobile app redirects are only applicable if the developer configures
       *     and accepts the Firebase Dynamic Links terms of service.
       *     The Android package name and iOS bundle ID are respected only if they
       *     are configured in the same Firebase Auth project.
       * @returns A promise that resolves with the generated link.
       */
      generateSignInWithEmailLink(email, actionCodeSettings) {
        return this.authRequestHandler.getEmailActionLink("EMAIL_SIGNIN", email, actionCodeSettings);
      }
      /**
       * Returns the list of existing provider configurations matching the filter
       * provided. At most, 100 provider configs can be listed at a time.
       *
       * SAML and OIDC provider support requires Google Cloud's Identity Platform
       * (GCIP). To learn more about GCIP, including pricing and features,
       * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
       *
       * @param options - The provider config filter to apply.
       * @returns A promise that resolves with the list of provider configs meeting the
       *   filter requirements.
       */
      listProviderConfigs(options) {
        const processResponse = (response, providerConfigs) => {
          const result = {
            providerConfigs
          };
          if (Object.prototype.hasOwnProperty.call(response, "nextPageToken")) {
            result.pageToken = response.nextPageToken;
          }
          return result;
        };
        if (options && options.type === "oidc") {
          return this.authRequestHandler.listOAuthIdpConfigs(options.maxResults, options.pageToken).then((response) => {
            const providerConfigs = [];
            response.oauthIdpConfigs.forEach((configResponse) => {
              providerConfigs.push(new auth_config_1.OIDCConfig(configResponse));
            });
            return processResponse(response, providerConfigs);
          });
        } else if (options && options.type === "saml") {
          return this.authRequestHandler.listInboundSamlConfigs(options.maxResults, options.pageToken).then((response) => {
            const providerConfigs = [];
            response.inboundSamlConfigs.forEach((configResponse) => {
              providerConfigs.push(new auth_config_1.SAMLConfig(configResponse));
            });
            return processResponse(response, providerConfigs);
          });
        }
        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ARGUMENT, '"AuthProviderConfigFilter.type" must be either "saml" or "oidc"'));
      }
      /**
       * Looks up an Auth provider configuration by the provided ID.
       * Returns a promise that resolves with the provider configuration
       * corresponding to the provider ID specified. If the specified ID does not
       * exist, an `auth/configuration-not-found` error is thrown.
       *
       * SAML and OIDC provider support requires Google Cloud's Identity Platform
       * (GCIP). To learn more about GCIP, including pricing and features,
       * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
       *
       * @param providerId - The provider ID corresponding to the provider
       *     config to return.
       * @returns A promise that resolves
       *     with the configuration corresponding to the provided ID.
       */
      getProviderConfig(providerId) {
        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return this.authRequestHandler.getOAuthIdpConfig(providerId).then((response) => {
            return new auth_config_1.OIDCConfig(response);
          });
        } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return this.authRequestHandler.getInboundSamlConfig(providerId).then((response) => {
            return new auth_config_1.SAMLConfig(response);
          });
        }
        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
      }
      /**
       * Deletes the provider configuration corresponding to the provider ID passed.
       * If the specified ID does not exist, an `auth/configuration-not-found` error
       * is thrown.
       *
       * SAML and OIDC provider support requires Google Cloud's Identity Platform
       * (GCIP). To learn more about GCIP, including pricing and features,
       * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
       *
       * @param providerId - The provider ID corresponding to the provider
       *     config to delete.
       * @returns A promise that resolves on completion.
       */
      deleteProviderConfig(providerId) {
        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return this.authRequestHandler.deleteOAuthIdpConfig(providerId);
        } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return this.authRequestHandler.deleteInboundSamlConfig(providerId);
        }
        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
      }
      /**
       * Returns a promise that resolves with the updated `AuthProviderConfig`
       * corresponding to the provider ID specified.
       * If the specified ID does not exist, an `auth/configuration-not-found` error
       * is thrown.
       *
       * SAML and OIDC provider support requires Google Cloud's Identity Platform
       * (GCIP). To learn more about GCIP, including pricing and features,
       * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
       *
       * @param providerId - The provider ID corresponding to the provider
       *     config to update.
       * @param updatedConfig - The updated configuration.
       * @returns A promise that resolves with the updated provider configuration.
       */
      updateProviderConfig(providerId, updatedConfig) {
        if (!validator.isNonNullObject(updatedConfig)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing "UpdateAuthProviderRequest" configuration.'));
        }
        if (auth_config_1.OIDCConfig.isProviderId(providerId)) {
          return this.authRequestHandler.updateOAuthIdpConfig(providerId, updatedConfig).then((response) => {
            return new auth_config_1.OIDCConfig(response);
          });
        } else if (auth_config_1.SAMLConfig.isProviderId(providerId)) {
          return this.authRequestHandler.updateInboundSamlConfig(providerId, updatedConfig).then((response) => {
            return new auth_config_1.SAMLConfig(response);
          });
        }
        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
      }
      /**
       * Returns a promise that resolves with the newly created `AuthProviderConfig`
       * when the new provider configuration is created.
       *
       * SAML and OIDC provider support requires Google Cloud's Identity Platform
       * (GCIP). To learn more about GCIP, including pricing and features,
       * see the {@link https://cloud.google.com/identity-platform | GCIP documentation}.
       *
       * @param config - The provider configuration to create.
       * @returns A promise that resolves with the created provider configuration.
       */
      createProviderConfig(config) {
        if (!validator.isNonNullObject(config)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_CONFIG, 'Request is missing "AuthProviderConfig" configuration.'));
        }
        if (auth_config_1.OIDCConfig.isProviderId(config.providerId)) {
          return this.authRequestHandler.createOAuthIdpConfig(config).then((response) => {
            return new auth_config_1.OIDCConfig(response);
          });
        } else if (auth_config_1.SAMLConfig.isProviderId(config.providerId)) {
          return this.authRequestHandler.createInboundSamlConfig(config).then((response) => {
            return new auth_config_1.SAMLConfig(response);
          });
        }
        return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_PROVIDER_ID));
      }
      /** @alpha */
      // eslint-disable-next-line @typescript-eslint/naming-convention
      _verifyAuthBlockingToken(token, audience) {
        const isEmulator = (0, auth_api_request_1.useEmulator)();
        return this.authBlockingTokenVerifier._verifyAuthBlockingToken(token, isEmulator, audience).then((decodedAuthBlockingToken) => {
          return decodedAuthBlockingToken;
        });
      }
      /**
       * Verifies the decoded Firebase issued JWT is not revoked or disabled. Returns a promise that
       * resolves with the decoded claims on success. Rejects the promise with revocation error if revoked
       * or user disabled.
       *
       * @param decodedIdToken - The JWT's decoded claims.
       * @param revocationErrorInfo - The revocation error info to throw on revocation
       *     detection.
       * @returns A promise that will be fulfilled after a successful verification.
       */
      verifyDecodedJWTNotRevokedOrDisabled(decodedIdToken, revocationErrorInfo) {
        return this.getUser(decodedIdToken.sub).then((user) => {
          if (user.disabled) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.USER_DISABLED, "The user record is disabled.");
          }
          if (user.tokensValidAfterTime) {
            const authTimeUtc = decodedIdToken.auth_time * 1e3;
            const validSinceUtc = new Date(user.tokensValidAfterTime).getTime();
            if (authTimeUtc < validSinceUtc) {
              throw new error_1.FirebaseAuthError(revocationErrorInfo);
            }
          }
          return decodedIdToken;
        });
      }
    };
    exports.BaseAuth = BaseAuth2;
  }
});

// node_modules/firebase-admin/lib/auth/tenant-manager.js
var require_tenant_manager = __commonJS({
  "node_modules/firebase-admin/lib/auth/tenant-manager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TenantManager = exports.TenantAwareAuth = void 0;
    var validator = require_validator();
    var utils = require_utils();
    var error_1 = require_error();
    var base_auth_1 = require_base_auth();
    var tenant_1 = require_tenant();
    var auth_api_request_1 = require_auth_api_request();
    var TenantAwareAuth2 = class extends base_auth_1.BaseAuth {
      /**
       * The TenantAwareAuth class constructor.
       *
       * @param app - The app that created this tenant.
       * @param tenantId - The corresponding tenant ID.
       * @constructor
       * @internal
       */
      constructor(app, tenantId) {
        super(app, new auth_api_request_1.TenantAwareAuthRequestHandler(app, tenantId), (0, base_auth_1.createFirebaseTokenGenerator)(app, tenantId));
        utils.addReadonlyGetter(this, "tenantId", tenantId);
      }
      /**
       * {@inheritdoc BaseAuth.verifyIdToken}
       */
      verifyIdToken(idToken, checkRevoked = false) {
        return super.verifyIdToken(idToken, checkRevoked).then((decodedClaims) => {
          if (decodedClaims.firebase.tenant !== this.tenantId) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);
          }
          return decodedClaims;
        });
      }
      /**
       * {@inheritdoc BaseAuth.createSessionCookie}
       */
      createSessionCookie(idToken, sessionCookieOptions) {
        if (!validator.isNonEmptyString(idToken)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_ID_TOKEN));
        }
        if (!validator.isNonNullObject(sessionCookieOptions) || !validator.isNumber(sessionCookieOptions.expiresIn)) {
          return Promise.reject(new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_SESSION_COOKIE_DURATION));
        }
        return this.verifyIdToken(idToken).then(() => {
          return super.createSessionCookie(idToken, sessionCookieOptions);
        });
      }
      /**
       * {@inheritdoc BaseAuth.verifySessionCookie}
       */
      verifySessionCookie(sessionCookie, checkRevoked = false) {
        return super.verifySessionCookie(sessionCookie, checkRevoked).then((decodedClaims) => {
          if (decodedClaims.firebase.tenant !== this.tenantId) {
            throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.MISMATCHING_TENANT_ID);
          }
          return decodedClaims;
        });
      }
    };
    exports.TenantAwareAuth = TenantAwareAuth2;
    var TenantManager2 = class {
      /**
       * Initializes a TenantManager instance for a specified FirebaseApp.
       *
       * @param app - The app for this TenantManager instance.
       *
       * @constructor
       * @internal
       */
      constructor(app) {
        this.app = app;
        this.authRequestHandler = new auth_api_request_1.AuthRequestHandler(app);
        this.tenantsMap = {};
      }
      /**
       * Returns a `TenantAwareAuth` instance bound to the given tenant ID.
       *
       * @param tenantId - The tenant ID whose `TenantAwareAuth` instance is to be returned.
       *
       * @returns The `TenantAwareAuth` instance corresponding to this tenant identifier.
       */
      authForTenant(tenantId) {
        if (!validator.isNonEmptyString(tenantId)) {
          throw new error_1.FirebaseAuthError(error_1.AuthClientErrorCode.INVALID_TENANT_ID);
        }
        if (typeof this.tenantsMap[tenantId] === "undefined") {
          this.tenantsMap[tenantId] = new TenantAwareAuth2(this.app, tenantId);
        }
        return this.tenantsMap[tenantId];
      }
      /**
       * Gets the tenant configuration for the tenant corresponding to a given `tenantId`.
       *
       * @param tenantId - The tenant identifier corresponding to the tenant whose data to fetch.
       *
       * @returns A promise fulfilled with the tenant configuration to the provided `tenantId`.
       */
      getTenant(tenantId) {
        return this.authRequestHandler.getTenant(tenantId).then((response) => {
          return new tenant_1.Tenant(response);
        });
      }
      /**
       * Retrieves a list of tenants (single batch only) with a size of `maxResults`
       * starting from the offset as specified by `pageToken`. This is used to
       * retrieve all the tenants of a specified project in batches.
       *
       * @param maxResults - The page size, 1000 if undefined. This is also
       *   the maximum allowed limit.
       * @param pageToken - The next page token. If not specified, returns
       *   tenants starting without any offset.
       *
       * @returns A promise that resolves with
       *   a batch of downloaded tenants and the next page token.
       */
      listTenants(maxResults, pageToken) {
        return this.authRequestHandler.listTenants(maxResults, pageToken).then((response) => {
          const tenants = [];
          response.tenants.forEach((tenantResponse) => {
            tenants.push(new tenant_1.Tenant(tenantResponse));
          });
          const result = {
            tenants,
            pageToken: response.nextPageToken
          };
          if (typeof result.pageToken === "undefined") {
            delete result.pageToken;
          }
          return result;
        });
      }
      /**
       * Deletes an existing tenant.
       *
       * @param tenantId - The `tenantId` corresponding to the tenant to delete.
       *
       * @returns An empty promise fulfilled once the tenant has been deleted.
       */
      deleteTenant(tenantId) {
        return this.authRequestHandler.deleteTenant(tenantId);
      }
      /**
       * Creates a new tenant.
       * When creating new tenants, tenants that use separate billing and quota will require their
       * own project and must be defined as `full_service`.
       *
       * @param tenantOptions - The properties to set on the new tenant configuration to be created.
       *
       * @returns A promise fulfilled with the tenant configuration corresponding to the newly
       *   created tenant.
       */
      createTenant(tenantOptions) {
        return this.authRequestHandler.createTenant(tenantOptions).then((response) => {
          return new tenant_1.Tenant(response);
        });
      }
      /**
       * Updates an existing tenant configuration.
       *
       * @param tenantId - The `tenantId` corresponding to the tenant to delete.
       * @param tenantOptions - The properties to update on the provided tenant.
       *
       * @returns A promise fulfilled with the update tenant data.
       */
      updateTenant(tenantId, tenantOptions) {
        return this.authRequestHandler.updateTenant(tenantId, tenantOptions).then((response) => {
          return new tenant_1.Tenant(response);
        });
      }
    };
    exports.TenantManager = TenantManager2;
  }
});

// node_modules/firebase-admin/lib/auth/project-config-manager.js
var require_project_config_manager = __commonJS({
  "node_modules/firebase-admin/lib/auth/project-config-manager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProjectConfigManager = void 0;
    var project_config_1 = require_project_config();
    var auth_api_request_1 = require_auth_api_request();
    var ProjectConfigManager2 = class {
      /**
       * Initializes a ProjectConfigManager instance for a specified FirebaseApp.
       *
       * @param app - The app for this ProjectConfigManager instance.
       *
       * @constructor
       * @internal
       */
      constructor(app) {
        this.authRequestHandler = new auth_api_request_1.AuthRequestHandler(app);
      }
      /**
       * Get the project configuration.
       *
       * @returns A promise fulfilled with the project configuration.
       */
      getProjectConfig() {
        return this.authRequestHandler.getProjectConfig().then((response) => {
          return new project_config_1.ProjectConfig(response);
        });
      }
      /**
       * Updates an existing project configuration.
       *
       * @param projectConfigOptions - The properties to update on the project.
       *
       * @returns A promise fulfilled with the updated project config.
       */
      updateProjectConfig(projectConfigOptions) {
        return this.authRequestHandler.updateProjectConfig(projectConfigOptions).then((response) => {
          return new project_config_1.ProjectConfig(response);
        });
      }
    };
    exports.ProjectConfigManager = ProjectConfigManager2;
  }
});

// node_modules/firebase-admin/lib/auth/auth.js
var require_auth = __commonJS({
  "node_modules/firebase-admin/lib/auth/auth.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Auth = void 0;
    var auth_api_request_1 = require_auth_api_request();
    var tenant_manager_1 = require_tenant_manager();
    var base_auth_1 = require_base_auth();
    var project_config_manager_1 = require_project_config_manager();
    var Auth2 = class extends base_auth_1.BaseAuth {
      /**
       * @param app - The app for this Auth service.
       * @constructor
       * @internal
       */
      constructor(app) {
        super(app, new auth_api_request_1.AuthRequestHandler(app));
        this.app_ = app;
        this.tenantManager_ = new tenant_manager_1.TenantManager(app);
        this.projectConfigManager_ = new project_config_manager_1.ProjectConfigManager(app);
      }
      /**
       * Returns the app associated with this Auth instance.
       *
       * @returns The app associated with this Auth instance.
       */
      get app() {
        return this.app_;
      }
      /**
       * Returns the tenant manager instance associated with the current project.
       *
       * @returns The tenant manager instance associated with the current project.
       */
      tenantManager() {
        return this.tenantManager_;
      }
      /**
       * Returns the project config manager instance associated with the current project.
       *
       * @returns The project config manager instance associated with the current project.
       */
      projectConfigManager() {
        return this.projectConfigManager_;
      }
    };
    exports.Auth = Auth2;
  }
});

// node_modules/firebase-admin/lib/auth/index.js
var require_auth2 = __commonJS({
  "node_modules/firebase-admin/lib/auth/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UserRecord = exports.UserMetadata = exports.UserInfo = exports.PhoneMultiFactorInfo = exports.MultiFactorSettings = exports.MultiFactorInfo = exports.ProjectConfigManager = exports.ProjectConfig = exports.TenantManager = exports.TenantAwareAuth = exports.Tenant = exports.BaseAuth = exports.Auth = exports.getAuth = void 0;
    var index_1 = require_app();
    var auth_1 = require_auth();
    function getAuth2(app) {
      if (typeof app === "undefined") {
        app = (0, index_1.getApp)();
      }
      const firebaseApp = app;
      return firebaseApp.getOrInitService("auth", (app2) => new auth_1.Auth(app2));
    }
    exports.getAuth = getAuth2;
    var auth_2 = require_auth();
    Object.defineProperty(exports, "Auth", { enumerable: true, get: function() {
      return auth_2.Auth;
    } });
    var base_auth_1 = require_base_auth();
    Object.defineProperty(exports, "BaseAuth", { enumerable: true, get: function() {
      return base_auth_1.BaseAuth;
    } });
    var tenant_1 = require_tenant();
    Object.defineProperty(exports, "Tenant", { enumerable: true, get: function() {
      return tenant_1.Tenant;
    } });
    var tenant_manager_1 = require_tenant_manager();
    Object.defineProperty(exports, "TenantAwareAuth", { enumerable: true, get: function() {
      return tenant_manager_1.TenantAwareAuth;
    } });
    Object.defineProperty(exports, "TenantManager", { enumerable: true, get: function() {
      return tenant_manager_1.TenantManager;
    } });
    var project_config_1 = require_project_config();
    Object.defineProperty(exports, "ProjectConfig", { enumerable: true, get: function() {
      return project_config_1.ProjectConfig;
    } });
    var project_config_manager_1 = require_project_config_manager();
    Object.defineProperty(exports, "ProjectConfigManager", { enumerable: true, get: function() {
      return project_config_manager_1.ProjectConfigManager;
    } });
    var user_record_1 = require_user_record();
    Object.defineProperty(exports, "MultiFactorInfo", { enumerable: true, get: function() {
      return user_record_1.MultiFactorInfo;
    } });
    Object.defineProperty(exports, "MultiFactorSettings", { enumerable: true, get: function() {
      return user_record_1.MultiFactorSettings;
    } });
    Object.defineProperty(exports, "PhoneMultiFactorInfo", { enumerable: true, get: function() {
      return user_record_1.PhoneMultiFactorInfo;
    } });
    Object.defineProperty(exports, "UserInfo", { enumerable: true, get: function() {
      return user_record_1.UserInfo;
    } });
    Object.defineProperty(exports, "UserMetadata", { enumerable: true, get: function() {
      return user_record_1.UserMetadata;
    } });
    Object.defineProperty(exports, "UserRecord", { enumerable: true, get: function() {
      return user_record_1.UserRecord;
    } });
  }
});

// node_modules/firebase-admin/lib/esm/auth/index.js
var import_auth = __toESM(require_auth2());
var Auth = import_auth.default.Auth;
var BaseAuth = import_auth.default.BaseAuth;
var MultiFactorInfo = import_auth.default.MultiFactorInfo;
var MultiFactorSettings = import_auth.default.MultiFactorSettings;
var PhoneMultiFactorInfo = import_auth.default.PhoneMultiFactorInfo;
var ProjectConfig = import_auth.default.ProjectConfig;
var ProjectConfigManager = import_auth.default.ProjectConfigManager;
var Tenant = import_auth.default.Tenant;
var TenantAwareAuth = import_auth.default.TenantAwareAuth;
var TenantManager = import_auth.default.TenantManager;
var UserInfo = import_auth.default.UserInfo;
var UserMetadata = import_auth.default.UserMetadata;
var UserRecord = import_auth.default.UserRecord;
var getAuth = import_auth.default.getAuth;
export {
  Auth,
  BaseAuth,
  MultiFactorInfo,
  MultiFactorSettings,
  PhoneMultiFactorInfo,
  ProjectConfig,
  ProjectConfigManager,
  Tenant,
  TenantAwareAuth,
  TenantManager,
  UserInfo,
  UserMetadata,
  UserRecord,
  getAuth
};
/*! Bundled license information:

firebase-admin/lib/auth/user-import-builder.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * Copyright 2018 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/action-code-settings-builder.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * Copyright 2018 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/auth-config.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * Copyright 2018 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/tenant.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * Copyright 2019 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/identifier.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * Copyright 2020 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/project-config.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * Copyright 2022 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/auth-api-request.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/utils/crypto-signer.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * @license
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/token-generator.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/utils/jwt.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/token-verifier.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * Copyright 2018 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/user-record.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/base-auth.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * Copyright 2021 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/tenant-manager.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * Copyright 2019 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/project-config-manager.js:
  (*! firebase-admin v11.11.0 *)

firebase-admin/lib/auth/auth.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * @license
   * Copyright 2017 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase-admin/lib/auth/index.js:
  (*! firebase-admin v11.11.0 *)
  (*!
   * Copyright 2020 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=firebase-admin_auth.js.map
